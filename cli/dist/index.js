// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = import.meta.require;

// node_modules/ini/lib/ini.js
var require_ini = __commonJS((exports, module) => {
  var { hasOwnProperty } = Object.prototype;
  var encode = (obj, opt = {}) => {
    if (typeof opt === "string") {
      opt = { section: opt };
    }
    opt.align = opt.align === true;
    opt.newline = opt.newline === true;
    opt.sort = opt.sort === true;
    opt.whitespace = opt.whitespace === true || opt.align === true;
    opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
    opt.bracketedArray = opt.bracketedArray !== false;
    const eol = opt.platform === "win32" ? `\r
` : `
`;
    const separator = opt.whitespace ? " = " : "=";
    const children2 = [];
    const keys5 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
    let padToChars = 0;
    if (opt.align) {
      padToChars = safe(keys5.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)).length;
    }
    let out = "";
    const arraySuffix = opt.bracketedArray ? "[]" : "";
    for (const k of keys5) {
      const val = obj[k];
      if (val && Array.isArray(val)) {
        for (const item of val) {
          out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
        }
      } else if (val && typeof val === "object") {
        children2.push(k);
      } else {
        out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
      }
    }
    if (opt.section && out.length) {
      out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
    }
    for (const k of children2) {
      const nk = splitSections(k, ".").join("\\.");
      const section = (opt.section ? opt.section + "." : "") + nk;
      const child = encode(obj[k], {
        ...opt,
        section
      });
      if (out.length && child.length) {
        out += eol;
      }
      out += child;
    }
    return out;
  };
  function splitSections(str, separator) {
    var lastMatchIndex = 0;
    var lastSeparatorIndex = 0;
    var nextIndex = 0;
    var sections = [];
    do {
      nextIndex = str.indexOf(separator, lastMatchIndex);
      if (nextIndex !== -1) {
        lastMatchIndex = nextIndex + separator.length;
        if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
          continue;
        }
        sections.push(str.slice(lastSeparatorIndex, nextIndex));
        lastSeparatorIndex = nextIndex + separator.length;
      }
    } while (nextIndex !== -1);
    sections.push(str.slice(lastSeparatorIndex));
    return sections;
  }
  var decode2 = (str, opt = {}) => {
    opt.bracketedArray = opt.bracketedArray !== false;
    const out = Object.create(null);
    let p3 = out;
    let section = null;
    const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    const duplicates = {};
    for (const line4 of lines) {
      if (!line4 || line4.match(/^\s*[;#]/) || line4.match(/^\s*$/)) {
        continue;
      }
      const match20 = line4.match(re);
      if (!match20) {
        continue;
      }
      if (match20[1] !== undefined) {
        section = unsafe(match20[1]);
        if (section === "__proto__") {
          p3 = Object.create(null);
          continue;
        }
        p3 = out[section] = out[section] || Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match20[2]);
      let isArray2;
      if (opt.bracketedArray) {
        isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
      } else {
        duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
        isArray2 = duplicates[keyRaw] > 1;
      }
      const key = isArray2 && keyRaw.endsWith("[]") ? keyRaw.slice(0, -2) : keyRaw;
      if (key === "__proto__") {
        continue;
      }
      const valueRaw = match20[3] ? unsafe(match20[4]) : true;
      const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      if (isArray2) {
        if (!hasOwnProperty.call(p3, key)) {
          p3[key] = [];
        } else if (!Array.isArray(p3[key])) {
          p3[key] = [p3[key]];
        }
      }
      if (Array.isArray(p3[key])) {
        p3[key].push(value);
      } else {
        p3[key] = value;
      }
    }
    const remove9 = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
        continue;
      }
      const parts2 = splitSections(k, ".");
      p3 = out;
      const l = parts2.pop();
      const nl = l.replace(/\\\./g, ".");
      for (const part of parts2) {
        if (part === "__proto__") {
          continue;
        }
        if (!hasOwnProperty.call(p3, part) || typeof p3[part] !== "object") {
          p3[part] = Object.create(null);
        }
        p3 = p3[part];
      }
      if (p3 === out && nl === l) {
        continue;
      }
      p3[nl] = out[k];
      remove9.push(k);
    }
    for (const del of remove9) {
      delete out[del];
    }
    return out;
  };
  var isQuoted = (val) => {
    return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
  };
  var safe = (val) => {
    if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
      return JSON.stringify(val);
    }
    return val.split(";").join("\\;").split("#").join("\\#");
  };
  var unsafe = (val) => {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'") {
        val = val.slice(1, -1);
      }
      try {
        val = JSON.parse(val);
      } catch {}
    } else {
      let esc = false;
      let unesc = "";
      for (let i = 0, l = val.length;i < l; i++) {
        const c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1) {
            unesc += c;
          } else {
            unesc += "\\" + c;
          }
          esc = false;
        } else if (";#".indexOf(c) !== -1) {
          break;
        } else if (c === "\\") {
          esc = true;
        } else {
          unesc += c;
        }
      }
      if (esc) {
        unesc += "\\";
      }
      return unesc.trim();
    }
    return val;
  };
  module.exports = {
    parse: decode2,
    decode: decode2,
    stringify: encode,
    encode,
    safe,
    unsafe
  };
});

// node_modules/toml/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  module.exports = function() {
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
    }
    function SyntaxError2(message, expected, found, offset, line4, column3) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line4;
      this.column = column3;
      this.name = "SyntaxError";
    }
    peg$subclass(SyntaxError2, Error);
    function parse3(input) {
      var options3 = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
        return nodes;
      }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = undefined, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
        addNode(node("ObjectPath", name, line4, column3));
      }, peg$c12 = function(name) {
        addNode(node("ArrayPath", name, line4, column3));
      }, peg$c13 = function(parts2, name) {
        return parts2.concat(name);
      }, peg$c14 = function(name) {
        return [name];
      }, peg$c15 = function(name) {
        return name;
      }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
        addNode(node("Assign", value, line4, column3, key));
      }, peg$c21 = function(chars) {
        return chars.join("");
      }, peg$c22 = function(node2) {
        return node2.value;
      }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
        return node("String", chars.join(""), line4, column3);
      }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char4) {
        return char4;
      }, peg$c34 = function(char4) {
        return char4;
      }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
        return "";
      }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left3, right3) {
        return node("Float", parseFloat(left3 + "e" + right3), line4, column3);
      }, peg$c43 = function(text6) {
        return node("Float", parseFloat(text6), line4, column3);
      }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
        return digits.join("");
      }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
        return "-" + digits.join("");
      }, peg$c50 = function(text6) {
        return node("Integer", parseInt(text6, 10), line4, column3);
      }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
        return node("Boolean", true, line4, column3);
      }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
        return node("Boolean", false, line4, column3);
      }, peg$c57 = function() {
        return node("Array", [], line4, column3);
      }, peg$c58 = function(value) {
        return node("Array", value ? [value] : [], line4, column3);
      }, peg$c59 = function(values3) {
        return node("Array", values3, line4, column3);
      }, peg$c60 = function(values3, value) {
        return node("Array", values3.concat(value), line4, column3);
      }, peg$c61 = function(value) {
        return value;
      }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values3) {
        return node("InlineTable", values3, line4, column3);
      }, peg$c69 = function(key, value) {
        return node("InlineTableValue", value, line4, column3, key);
      }, peg$c70 = function(digits) {
        return "." + digits;
      }, peg$c71 = function(date2) {
        return date2.join("");
      }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time2) {
        return time2.join("");
      }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date2, time2) {
        return node("Date", new Date(date2 + "T" + time2 + "Z"), line4, column3);
      }, peg$c80 = function(date2, time2) {
        return node("Date", new Date(date2 + "T" + time2), line4, column3);
      }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = `
`, peg$c84 = { type: "literal", value: `
`, description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
        return "";
      }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
        return d.join("");
      }, peg$c97 = "\\\"", peg$c98 = { type: "literal", value: "\\\"", description: '"\\\\\\""' }, peg$c99 = function() {
        return '"';
      }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
        return "\\";
      }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
        return "\b";
      }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
        return "\t";
      }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
        return `
`;
      }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
        return "\f";
      }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
        return "\r";
      }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
        return convertCodePoint(digits.join(""));
      }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
      if ("startRule" in options3) {
        if (!(options3.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options3.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options3.startRule];
      }
      function text5() {
        return input.substring(peg$reportedPos, peg$currPos);
      }
      function offset() {
        return peg$reportedPos;
      }
      function line4() {
        return peg$computePosDetails(peg$reportedPos).line;
      }
      function column3() {
        return peg$computePosDetails(peg$reportedPos).column;
      }
      function expected(description) {
        throw peg$buildException(null, [{ type: "other", description }], peg$reportedPos);
      }
      function error4(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }
      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p3, ch;
          for (p3 = startPos;p3 < endPos; p3++) {
            ch = input.charAt(p3);
            if (ch === `
`) {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }
        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }
        return peg$cachedPosDetails;
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildException(message, expected2, pos) {
        function cleanupExpected(expected3) {
          var i = 1;
          expected3.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });
          while (i < expected3.length) {
            if (expected3[i - 1] === expected3[i]) {
              expected3.splice(i, 1);
            } else {
              i++;
            }
          }
        }
        function buildMessage(expected3, found2) {
          function stringEscape(s) {
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0180-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1080-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          }
          var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
          for (i = 0;i < expected3.length; i++) {
            expectedDescs[i] = expected3[i].description;
          }
          expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
          foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
          return "Expected " + expectedDesc + " but " + foundDesc + " found.";
        }
        var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
        if (expected2 !== null) {
          cleanupExpected(expected2);
        }
        return new SyntaxError2(message !== null ? message : buildMessage(expected2, found), expected2, found, pos, posDetails.line, posDetails.column);
      }
      function peg$parsestart() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 0, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseline();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 1, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsecomment();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsecomment();
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseNL();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseNL();
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseNL();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseNL();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseEOF();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseexpression() {
        var s0;
        var key = peg$currPos * 49 + 2, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepath();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetablearray();
            if (s0 === peg$FAILED) {
              s0 = peg$parseassignment();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 3, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseNL();
          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c5;
          } else {
            peg$currPos = s4;
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsepath() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 4, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable_key();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c9;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c11(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetablearray() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 49 + 5, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsetable_key();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c9;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s7 = peg$c9;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c12(s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 6, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedot_ended_table_key_part();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsedot_ended_table_key_part();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsetable_key_part();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetable_key_part();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key_part() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 7, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c15(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedot_ended_table_key_part() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 8, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 9, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c20(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsequoted_key();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsekey() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 10, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseASCII_BASIC();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseASCII_BASIC();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c21(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsequoted_key() {
        var s0, s1;
        var key = peg$currPos * 49 + 11, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedouble_quoted_single_line_string();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsesingle_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsevalue() {
        var s0;
        var key = peg$currPos * 49 + 12, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedatetime();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefloat();
            if (s0 === peg$FAILED) {
              s0 = peg$parseinteger();
              if (s0 === peg$FAILED) {
                s0 = peg$parseboolean();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsearray();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseinline_table();
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring() {
        var s0;
        var key = peg$currPos * 49 + 13, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parsedouble_quoted_multiline_string();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_quoted_single_line_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_single_line_string();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 14, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_string_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_string_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s4 = peg$c23;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 15, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestring_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestring_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 16, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s1 = peg$c29;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_literal_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_literal_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c29) {
                s4 = peg$c29;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 17, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseliteral_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseliteral_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c31;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 18, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseliteral_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 19, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 20, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemultiline_string_delim();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s2 = peg$c23;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c34(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_delim() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 21, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseNLS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseNLS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c37();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_literal_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 22, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s2 = peg$c29;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 23, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsefloat_text();
        if (s1 === peg$FAILED) {
          s1 = peg$parseinteger_text();
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 101) {
            s2 = peg$c38;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
              s2 = peg$c40;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c41);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinteger_text();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c42(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c43(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat_text() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 24, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseDIGITS();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger() {
        var s0, s1;
        var key = peg$currPos * 49 + 25, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseinteger_text();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger_text() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 26, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c5;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseboolean() {
        var s0, s1;
        var key = peg$currPos * 49 + 27, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c51) {
          s1 = peg$c51;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c54) {
            s1 = peg$c54;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c55);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 28, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_sep();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_sep();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearray_value();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c58(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_value_list();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearray_value_list();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c59(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsearray_value();
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c9;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c60(s2, s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 29, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 30, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c62;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c63);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsearray_sep();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsearray_sep();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_sep() {
        var s0;
        var key = peg$currPos * 49 + 31, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parseS();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomment();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 32, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c64;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseinline_table_assignment();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseinline_table_assignment();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c66;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c68(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table_assignment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 33, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue();
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseS();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseS();
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s8 = peg$c62;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c63);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = [];
                        s10 = peg$parseS();
                        while (s10 !== peg$FAILED) {
                          s9.push(s10);
                          s10 = peg$parseS();
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c69(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesecfragment() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 34, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDIGITS();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c70(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        var key = peg$currPos * 49 + 35, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDIGIT_OR_UNDER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c47;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDIGIT_OR_UNDER();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s9 = peg$c47;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c48);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseDIGIT_OR_UNDER();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseDIGIT_OR_UNDER();
                          if (s11 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 36, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime_with_offset() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
        var key = peg$currPos * 49 + 37, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s11 = peg$c47;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s11 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                              s11 = peg$c44;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c45);
                              }
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseDIGIT_OR_UNDER();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseDIGIT_OR_UNDER();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                  s14 = peg$c72;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c73);
                                  }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parseDIGIT_OR_UNDER();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseDIGIT_OR_UNDER();
                                    if (s16 !== peg$FAILED) {
                                      s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                      s1 = s2;
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedatetime() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 38, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedate();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 90) {
                s4 = peg$c77;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c79(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime_with_offset();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c80(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseS() {
        var s0;
        var key = peg$currPos * 49 + 39, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNL() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 40, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c83;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c85;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c83;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNLS() {
        var s0;
        var key = peg$currPos * 49 + 41, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$parseNL();
        if (s0 === peg$FAILED) {
          s0 = peg$parseS();
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        var key = peg$currPos * 49 + 42, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = peg$c5;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseHEX() {
        var s0;
        var key = peg$currPos * 49 + 43, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGIT_OR_UNDER() {
        var s0, s1;
        var key = peg$currPos * 49 + 44, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c91;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c93();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseASCII_BASIC() {
        var s0;
        var key = peg$currPos * 49 + 45, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGITS() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 46, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseDIGIT_OR_UNDER();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c96(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED() {
        var s0, s1;
        var key = peg$currPos * 49 + 47, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c99();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s1 = peg$c100;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c101);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c102();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c105();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c107);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c108();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c109) {
                  s1 = peg$c109;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c111();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c112) {
                    s1 = peg$c112;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c114();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c115) {
                      s1 = peg$c115;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c116);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c117();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseESCAPED_UNICODE();
                    }
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED_UNICODE() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 48, cached3 = peg$cache[key];
        if (cached3) {
          peg$currPos = cached3.nextPos;
          return cached3.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c118) {
          s1 = peg$c118;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseHEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHEX();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseHEX();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseHEX();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseHEX();
                        if (s10 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                          s2 = s3;
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s3 = [s3, s4, s5, s6];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      var nodes = [];
      function genError(err, line5, col) {
        var ex = new Error(err);
        ex.line = line5;
        ex.column = col;
        throw ex;
      }
      function addNode(node2) {
        nodes.push(node2);
      }
      function node(type, value, line5, column4, key) {
        var obj = { type, value, line: line5(), column: column4() };
        if (key)
          obj.key = key;
        return obj;
      }
      function convertCodePoint(str, line5, col) {
        var num = parseInt("0x" + str);
        if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
          genError("Invalid Unicode escape code: " + str, line5, col);
        } else {
          return fromCodePoint(num);
        }
      }
      function fromCodePoint() {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length3 = arguments.length;
        if (!length3) {
          return "";
        }
        var result = "";
        while (++index < length3) {
          var codePoint = Number(arguments[index]);
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length3 || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: "end", description: "end of input" });
        }
        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }
    return {
      SyntaxError: SyntaxError2,
      parse: parse3
    };
  }();
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS((exports, module) => {
  function compile(nodes) {
    var assignedPaths = [];
    var valueAssignments = [];
    var currentPath = "";
    var data = Object.create(null);
    var context8 = data;
    var arrayMode = false;
    return reduce16(nodes);
    function reduce16(nodes2) {
      var node;
      for (var i = 0;i < nodes2.length; i++) {
        node = nodes2[i];
        switch (node.type) {
          case "Assign":
            assign(node);
            break;
          case "ObjectPath":
            setPath(node);
            break;
          case "ArrayPath":
            addTableArray(node);
            break;
        }
      }
      return data;
    }
    function genError(err, line4, col) {
      var ex = new Error(err);
      ex.line = line4;
      ex.column = col;
      throw ex;
    }
    function assign(node) {
      var key = node.key;
      var value = node.value;
      var line4 = node.line;
      var column3 = node.column;
      var fullPath;
      if (currentPath) {
        fullPath = currentPath + "." + key;
      } else {
        fullPath = key;
      }
      if (typeof context8[key] !== "undefined") {
        genError("Cannot redefine existing key '" + fullPath + "'.", line4, column3);
      }
      context8[key] = reduceValueNode(value);
      if (!pathAssigned(fullPath)) {
        assignedPaths.push(fullPath);
        valueAssignments.push(fullPath);
      }
    }
    function pathAssigned(path) {
      return assignedPaths.indexOf(path) !== -1;
    }
    function reduceValueNode(node) {
      if (node.type === "Array") {
        return reduceArrayWithTypeChecking(node.value);
      } else if (node.type === "InlineTable") {
        return reduceInlineTableNode(node.value);
      } else {
        return node.value;
      }
    }
    function reduceInlineTableNode(values3) {
      var obj = Object.create(null);
      for (var i = 0;i < values3.length; i++) {
        var val = values3[i];
        if (val.value.type === "InlineTable") {
          obj[val.key] = reduceInlineTableNode(val.value.value);
        } else if (val.type === "InlineTableValue") {
          obj[val.key] = reduceValueNode(val.value);
        }
      }
      return obj;
    }
    function setPath(node) {
      var path = node.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line4 = node.line;
      var column3 = node.column;
      if (pathAssigned(quotedPath)) {
        genError("Cannot redefine existing key '" + path + "'.", line4, column3);
      }
      assignedPaths.push(quotedPath);
      context8 = deepRef(data, path, Object.create(null), line4, column3);
      currentPath = path;
    }
    function addTableArray(node) {
      var path = node.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line4 = node.line;
      var column3 = node.column;
      if (!pathAssigned(quotedPath)) {
        assignedPaths.push(quotedPath);
      }
      assignedPaths = assignedPaths.filter(function(p3) {
        return p3.indexOf(quotedPath) !== 0;
      });
      assignedPaths.push(quotedPath);
      context8 = deepRef(data, path, [], line4, column3);
      currentPath = quotedPath;
      if (context8 instanceof Array) {
        var newObj = Object.create(null);
        context8.push(newObj);
        context8 = newObj;
      } else {
        genError("Cannot redefine existing key '" + path + "'.", line4, column3);
      }
    }
    function deepRef(start3, keys5, value, line4, column3) {
      var traversed = [];
      var traversedPath = "";
      var path = keys5.join(".");
      var ctx = start3;
      for (var i = 0;i < keys5.length; i++) {
        var key = keys5[i];
        traversed.push(key);
        traversedPath = traversed.join(".");
        if (typeof ctx[key] === "undefined") {
          if (i === keys5.length - 1) {
            ctx[key] = value;
          } else {
            ctx[key] = Object.create(null);
          }
        } else if (i !== keys5.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
          genError("Cannot redefine existing key '" + traversedPath + "'.", line4, column3);
        }
        ctx = ctx[key];
        if (ctx instanceof Array && ctx.length && i < keys5.length - 1) {
          ctx = ctx[ctx.length - 1];
        }
      }
      return ctx;
    }
    function reduceArrayWithTypeChecking(array7) {
      var firstType = null;
      for (var i = 0;i < array7.length; i++) {
        var node = array7[i];
        if (firstType === null) {
          firstType = node.type;
        } else {
          if (node.type !== firstType) {
            genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
          }
        }
      }
      return array7.map(reduceValueNode);
    }
    function quoteDottedString(str) {
      if (str.indexOf(".") > -1) {
        return '"' + str + '"';
      } else {
        return str;
      }
    }
  }
  module.exports = {
    compile
  };
});

// node_modules/toml/index.js
var require_toml = __commonJS((exports, module) => {
  var parser = require_parser();
  var compiler = require_compiler();
  module.exports = {
    parse: function(input) {
      var nodes = parser.parse(input.toString());
      return compiler.compile(nodes);
    }
  };
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity3 = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity3.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity3.isNode(ctrl) || identity3.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity3.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity3.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity3.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity3.isNode(ctrl) || identity3.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity3.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity3.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity3.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity3.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity3.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity3.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity3.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity3.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity3.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity3.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity3.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity3 = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy4 = new Directives(this.yaml, this.tags);
      copy4.docStart = this.docStart;
      return copy4;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line4, onError4) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts2 = line4.trim().split(/[ \t]+/);
      const name = parts2.shift();
      switch (name) {
        case "%TAG": {
          if (parts2.length !== 2) {
            onError4(0, "%TAG directive should contain exactly two parts");
            if (parts2.length < 2)
              return false;
          }
          const [handle, prefix] = parts2;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts2.length !== 1) {
            onError4(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts2;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid2 = /^\d+\.\d+$/.test(version);
            onError4(6, `Unsupported YAML version ${version}`, isValid2);
            return false;
          }
        }
        default:
          onError4(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError4) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError4(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError4(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError4("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError4(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error4) {
          onError4(String(error4));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError4(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag2) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag2.startsWith(prefix))
          return handle + escapeTagName(tag2.substring(prefix.length));
      }
      return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity3.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity3.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity3 = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude3) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude3.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity3.isScalar(ref.node) || identity3.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error4 = new Error("Failed to resolve repeated object (this should not happen)");
            error4.source = source;
            throw error4;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity3 = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity3.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity3 = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity3.NODE_TYPE, { value: type });
    }
    clone() {
      const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity3.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count4, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count4);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity3 = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity3.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity3.isAlias(node) || identity3.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity3.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity3.isCollection(node)) {
      let count4 = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count4)
          count4 = c;
      }
      return count4;
    } else if (identity3.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity3 = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity3.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match20 = tags.filter((t) => t.tag === tagName);
      const tagObj = match20.find((t) => !t.format) ?? match20[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity3.isDocument(value))
      value = value.contents;
    if (identity3.isNode(value))
      return value;
    if (identity3.isPair(value)) {
      const map27 = ctx.schema[identity3.MAP].createNode?.(ctx.schema, null, ctx);
      map27.items.push(value);
      return map27;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity3.MAP] : (Symbol.iterator in Object(value)) ? schema[identity3.SEQ] : schema[identity3.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity3 = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy4.schema = schema;
      copy4.items = copy4.items.map((it) => identity3.isNode(it) || identity3.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity3.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity3.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity3.isScalar(node) ? node.value : node;
      else
        return identity3.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity3.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity3.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity3.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity3.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent3) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent3 ? comment.replace(/^(?! *$)/gm, indent3) : comment;
  }
  var lineComment = (str, indent3, comment) => str.endsWith(`
`) ? indentComment(comment, indent3) : comment.includes(`
`) ? `
` + indentComment(comment, indent3) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text5, indent3, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text5;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent3.length);
    if (text5.length <= endStep)
      return text5;
    const folds = [];
    const escapedFolds = {};
    let end6 = lineWidth - indent3.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end6 = lineWidth - indentAtStart;
    }
    let split2 = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text5, i, indent3.length);
      if (i !== -1)
        end6 = i + endStep;
    }
    for (let ch;ch = text5[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text5[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text5, i, indent3.length);
        end6 = i + indent3.length + endStep;
        split2 = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next4 = text5[i + 1];
          if (next4 && next4 !== " " && next4 !== `
` && next4 !== "\t")
            split2 = i;
        }
        if (i >= end6) {
          if (split2) {
            folds.push(split2);
            end6 = split2 + endStep;
            split2 = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text5[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text5;
            folds.push(j);
            escapedFolds[j] = true;
            end6 = j + endStep;
            split2 = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text5;
    if (onFold)
      onFold();
    let res = text5.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold2 = folds[i2];
      const end7 = folds[i2 + 1] || text5.length;
      if (fold2 === 0)
        res = `
${indent3}${text5.slice(0, end7)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold2])
          res += `${text5[fold2]}\\`;
        res += `
${indent3}${text5.slice(fold2 + 1, end7)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text5, i, indent3) {
    let end6 = i;
    let start3 = i + 1;
    let ch = text5[start3];
    while (ch === " " || ch === "\t") {
      if (i < start3 + indent3) {
        ch = text5[++i];
      } else {
        do {
          ch = text5[++i];
        } while (ch && ch !== `
`);
        end6 = i;
        start3 = i + 1;
        ch = text5[start3];
      }
    }
    return end6;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start3 = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start3 > limit)
          return true;
        start3 = i + 1;
        if (strLen - start3 <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent3 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start3 = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start3, i) + "\\ ";
        i += 1;
        start3 = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start3, i);
              const code2 = json.substr(i + 2, 4);
              switch (code2) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code2.substr(0, 2) === "00")
                    str += "\\x" + code2.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start3 = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start3, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent3;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start3 = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start3 ? str + json.slice(start3) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent3, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent3 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent3}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent3 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent3.length);
    if (!value)
      return literal2 ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end6 = value.substring(endStart);
    const endNlPos = end6.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end6 || endNlPos !== end6.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end6) {
      value = value.slice(0, -end6.length);
      if (end6[end6.length - 1] === `
`)
        end6 = end6.slice(0, -1);
      end6 = end6.replace(blockEndNewlines, `$&${indent3}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start3 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start3) {
      value = value.substring(start3.length);
      start3 = start3.replace(/\n+/g, `$&${indent3}`);
    }
    const indentSize = indent3 ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal2) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent3}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start3}${foldedValue}${end6}`, indent3, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent3}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent3}`);
    return `|${header}
${indent3}${start3}${value}${end6}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent: indent3, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent3 === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent3 === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent3}`);
    if (actualString) {
      const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity3 = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options3) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options3);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match20 = tags.filter((t) => t.tag === item.tag);
      if (match20.length > 0)
        return match20.find((t) => t.format === item.format) ?? match20[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity3.isScalar(item)) {
      obj = item.value;
      let match20 = tags.filter((t) => t.identify?.(obj));
      if (match20.length > 1) {
        const testMatch = match20.filter((t) => t.test);
        if (testMatch.length > 0)
          match20 = testMatch;
      }
      tagObj = match20.find((t) => t.format === item.format) ?? match20.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity3.isScalar(node) || identity3.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag2 = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag2)
      props.push(doc.directives.tagString(tag2));
    return props.join(" ");
  }
  function stringify2(item, ctx, onComment, onChompKeep) {
    if (identity3.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity3.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity3.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity3.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity3.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify2;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var stringify2 = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent: indent3, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity3.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity3.isCollection(key) || !identity3.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity3.isCollection(key) || (identity3.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent3 + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent3}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity3.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity3.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity3.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify2.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
`)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity3.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug2(logLevel2, ...messages) {
    if (logLevel2 === "debug")
      console.log(...messages);
  }
  function warn2(logLevel2, warning) {
    if (logLevel2 === "debug" || logLevel2 === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug2;
  exports.warn = warn2;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge9 = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge9.identify(key) || identity3.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge9.identify(key.value)) && ctx?.doc.schema.tags.some((tag2) => tag2.tag === merge9.tag && tag2.default);
  function addMergeToJSMap(ctx, map27, value) {
    value = ctx && identity3.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity3.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map27, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map27, it);
    else
      mergeValue(ctx, map27, value);
  }
  function mergeValue(ctx, map27, value) {
    const source = ctx && identity3.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity3.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map27 instanceof Map) {
        if (!map27.has(key))
          map27.set(key, value2);
      } else if (map27 instanceof Set) {
        map27.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map27, key)) {
        Object.defineProperty(map27, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map27;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge9;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log4 = require_log();
  var merge9 = require_merge();
  var stringify2 = require_stringify();
  var identity3 = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map27, { key, value }) {
    if (identity3.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map27, value);
    else if (merge9.isMergeKey(ctx, key))
      merge9.addMergeToJSMap(ctx, map27, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map27 instanceof Map) {
        map27.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map27 instanceof Set) {
        map27.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map27)
          Object.defineProperty(map27, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map27[stringKey] = jsValue;
      }
    }
    return map27;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity3.isNode(key) && ctx?.doc) {
      const strCtx = stringify2.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log4.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity3 = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity3.NODE_TYPE, { value: identity3.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity3.isNode(key))
        key = key.clone(schema);
      if (identity3.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity3 = require_identity();
  var stringify2 = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options3) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify3(collection, ctx, options3);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent: indent3, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity3.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity3.isPair(item)) {
        const ik = identity3.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify2.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line4 = lines[i];
        str += line4 ? `
${indent3}${line4}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent3);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent: indent3, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity3.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity3.isPair(item)) {
        const ik = identity3.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity3.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify2.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start: start3, end: end6 } = flowChars;
    if (lines.length === 0) {
      return start3 + end6;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum3, line4) => sum3 + line4.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start3;
        for (const line4 of lines)
          str += line4 ? `
${indentStep}${indent3}${line4}` : `
`;
        return `${str}
${indent3}${end6}`;
      } else {
        return `${start3}${fcPadding}${lines.join(" ")}${fcPadding}${end6}`;
      }
    }
  }
  function addCommentBefore({ indent: indent3, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent3);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity3 = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity3.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity3.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity3.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity3.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map27 = new this(schema);
      const add6 = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map27.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add6(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add6(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map27.items.sort(schema.sortMapEntries);
      }
      return map27;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity3.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity3.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity3.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type3) {
      const map27 = Type3 ? new Type3 : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map27);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map27, item);
      return map27;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity3.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity3 = require_identity();
  var YAMLMap = require_YAMLMap();
  var map27 = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map28, onError4) {
      if (!identity3.isMap(map28))
        onError4("Expected a mapping for this tag");
      return map28;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map27;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity3.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity3.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity3.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq2 = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq2);
      let i = 0;
      for (const item of this.items)
        seq2.push(toJS.toJS(item, String(i++), ctx));
      return seq2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq2.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq2;
    }
  }
  function asItemIndex(key) {
    let idx = identity3.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity3 = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq2 = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq3, onError4) {
      if (!identity3.isSeq(seq3))
        onError4("Expected a sequence for this tag");
      return seq3;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq2;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string7 = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string7;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format: format4, minFractionDigits, tag: tag2, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format4 && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot3 = str.indexOf(".");
      if (dot3 !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot3 - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map27 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string7 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map27.map,
    seq2.seq,
    string7.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map27 = require_map();
  var seq2 = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError4) {
      onError4(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map27.map, seq2.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError4) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer3 = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer3[i] = str.charCodeAt(i);
        return buffer3;
      } else {
        onError4("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity3 = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq2, onError4) {
    if (identity3.isSeq(seq2)) {
      for (let i = 0;i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (identity3.isPair(item))
          continue;
        else if (identity3.isMap(item)) {
          if (item.items.length > 1)
            onError4("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq2.items[i] = identity3.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError4("Expected a sequence for this tag");
    return seq2;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys5 = Object.keys(it);
          if (keys5.length === 1) {
            key = keys5[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys5.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity3 = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map27 = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map27);
      for (const pair of this.items) {
        let key, value;
        if (identity3.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map27.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map27.set(key, value);
      }
      return map27;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq2, onError4) {
      const pairs$1 = pairs.resolvePairs(seq2, onError4);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity3.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError4(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot3 = str.indexOf(".");
      if (dot3 !== -1) {
        const f = str.substring(dot3 + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign2 = str[0];
    if (sign2 === "-" || sign2 === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign2 === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign2 === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity3 = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity3.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity3.isPair(pair) ? identity3.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set9 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set9.items.push(Pair.createPair(value, null, ctx));
        }
      return set9;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set8 = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map27, onError4) {
      if (identity3.isMap(map27)) {
        if (map27.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map27);
        else
          onError4("Set items must all have null values");
      } else
        onError4("Expected a mapping for this tag");
      return map27;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set8;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign2 = str[0];
    const parts2 = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts2.replace(/_/g, "").split(":").reduce((res2, p3) => res2 * num(60) + num(p3), num(0));
    return sign2 === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign2 = "";
    if (value < 0) {
      sign2 = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts2 = [value % _60];
    if (value < 60) {
      parts2.unshift(0);
    } else {
      value = (value - parts2[0]) / _60;
      parts2.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts2[0]) / _60;
        parts2.unshift(value);
      }
    }
    return sign2 + parts2.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match20 = str.match(timestamp.test);
      if (!match20)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match20.map(Number);
      const millisec = match20[7] ? Number((match20[7] + "00").substr(1, 3)) : 0;
      let date2 = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match20[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date2 -= 60000 * d;
      }
      return new Date(date2);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map27 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string7 = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge9 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set8 = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map27.map,
    seq2.seq,
    string7.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge9.merge,
    omap.omap,
    pairs.pairs,
    set8.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map27 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string7 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge9 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set8 = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map27.map, seq2.seq, string7.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map27.map,
    merge: merge9.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq2.seq,
    set: set8.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge9.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set8.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge9.merge) ? schemaTags.concat(merge9.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys5 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys5} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag2 of customTags)
        tags = tags.concat(tag2);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge9.merge);
    return tags.reduce((tags2, tag2) => {
      const tagObj = typeof tag2 === "string" ? tagsByName[tag2] : tag2;
      if (!tagObj) {
        const tagName = JSON.stringify(tag2);
        const keys5 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys5}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity3 = require_identity();
  var map27 = require_map();
  var seq2 = require_seq();
  var string7 = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge: merge9, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge9);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity3.MAP, { value: map27.map });
      Object.defineProperty(this, identity3.SCALAR, { value: string7.string });
      Object.defineProperty(this, identity3.SEQ, { value: seq2.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy4 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy4.tags = this.tags.slice();
      return copy4;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity3 = require_identity();
  var stringify2 = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options3) {
    const lines = [];
    let hasDirectives = options3.directives === true;
    if (options3.directives !== false && doc.directives) {
      const dir2 = doc.directives.toString(doc);
      if (dir2) {
        lines.push(dir2);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify2.createStringifyContext(doc, options3);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity3.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify2.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity3 = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options3) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity3.NODE_TYPE, { value: identity3.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options3 === undefined && replacer) {
        options3 = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options3);
      this.options = opt;
      let { version } = opt;
      if (options3?._directives) {
        this.directives = options3._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options3);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options3);
    }
    clone() {
      const copy4 = Object.create(Document.prototype, {
        [identity3.NODE_TYPE]: { value: identity3.DOC }
      });
      copy4.commentBefore = this.commentBefore;
      copy4.comment = this.comment;
      copy4.errors = this.errors.slice();
      copy4.warnings = this.warnings.slice();
      copy4.options = Object.assign({}, this.options);
      if (this.directives)
        copy4.directives = this.directives.clone();
      copy4.schema = this.schema.clone();
      copy4.contents = identity3.isNode(this.contents) ? this.contents.clone(copy4.schema) : this.contents;
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options3) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options3 === undefined && replacer) {
        options3 = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options3 ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag2, ctx);
      if (flow && identity3.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options3 = {}) {
      const k = this.createNode(key, null, options3);
      const v = this.createNode(value, null, options3);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity3.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity3.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity3.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity3.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity3.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options3 = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options3.schema instanceof Object)
        this.schema = options3.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options3));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count4, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count4);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options3 = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options3 && (!Number.isInteger(options3.indent) || Number(options3.indent) <= 0)) {
        const s = JSON.stringify(options3.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options3);
    }
  }
  function assertCollection(contents) {
    if (identity3.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code2, message) {
      super();
      this.name = name;
      this.code = code2;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code2, message) {
      super("YAMLParseError", pos, code2, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code2, message) {
      super("YAMLWarning", pos, code2, message);
    }
  }
  var prettifyError = (src, lc) => (error4) => {
    if (error4.pos[0] === -1)
      return;
    error4.linePos = error4.pos.map((pos) => lc.linePos(pos));
    const { line: line4, col } = error4.linePos[0];
    error4.message += ` at line ${line4}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line4 - 1], lc.lineStarts[line4]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line4 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line4 - 2], lc.lineStarts[line4 - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `\u2026
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count4 = 1;
      const end6 = error4.linePos[1];
      if (end6 && end6.line === line4 && end6.col > col) {
        count4 = Math.max(1, Math.min(end6.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count4);
      error4.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next: next4, offset, onError: onError4, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag2 = null;
    let newlineAfterProp = null;
    let comma3 = null;
    let found = null;
    let start3 = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError4(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError4(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next4?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError4(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag2)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError4(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError4(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start3 ?? (start3 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag2)
            onError4(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag2 = token;
          start3 ?? (start3 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag2)
            onError4(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError4(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma3)
              onError4(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma3 = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError4(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last5 = tokens[tokens.length - 1];
    const end6 = last5 ? last5.offset + last5.source.length : offset;
    if (reqSpace && next4 && next4.type !== "space" && next4.type !== "newline" && next4.type !== "comma" && (next4.type !== "scalar" || next4.source !== "")) {
      onError4(next4.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next4?.type === "block-map" || next4?.type === "block-seq"))
      onError4(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma: comma3,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag: tag2,
      newlineAfterProp,
      end: end6,
      start: start3 ?? end6
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent3, fc, onError4) {
    if (fc?.type === "flow-collection") {
      const end6 = fc.end[0];
      if (end6.indent === indent3 && (end6.source === "]" || end6.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError4(end6, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity3 = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual2 = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity3.isScalar(a) && identity3.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual2(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError4, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLMap.YAMLMap;
    const map27 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start: start3, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start3, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError: onError4,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError4(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError4(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map27.comment)
              map27.comment += `
` + keyProps.comment;
            else
              map27.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError4(key ?? start3[start3.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError4(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError4) : composeEmptyNode(ctx, keyStart, start3, null, keyProps, onError4);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError4);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map27.items, keyNode))
        onError4(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError: onError4,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError4(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError4(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError4) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError4);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError4);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map27.items.push(pair);
      } else {
        if (implicitKey)
          onError4(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map27.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError4(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map27.range = [bm.offset, offset, commentEnd ?? offset];
    return map27;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError4, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start: start3, value } of bs.items) {
      const props = resolveProps.resolveProps(start3, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError: onError4,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError4(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError4(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq2.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError4) : composeEmptyNode(ctx, props.end, start3, null, props, onError4);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError4);
      offset = node.range[2];
      seq2.items.push(node);
    }
    seq2.range = [bs.offset, offset, commentEnd ?? offset];
    return seq2;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end6, offset, reqSpace, onError4) {
    let comment = "";
    if (end6) {
      let hasSpace = false;
      let sep = "";
      for (const token of end6) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError4(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError4(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity3 = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError4, tag2) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag2?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start: start3, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start3, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError: onError4,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError4(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError4(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError4(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError4(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError4(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start3) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity3.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError4) : composeEmptyNode(ctx, props.end, sep, null, props, onError4);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError4(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError4) : composeEmptyNode(ctx, keyStart, start3, null, props, onError4);
        if (isBlock(key))
          onError4(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError: onError4,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError4(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError4(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError4(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError4(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError4) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError4) : null;
        if (valueNode) {
          if (isBlock(value))
            onError4(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map27 = coll;
          if (utilMapIncludes.mapIncludes(ctx, map27.items, keyNode))
            onError4(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map27.items.push(pair);
        } else {
          const map27 = new YAMLMap.YAMLMap(ctx.schema);
          map27.flow = true;
          map27.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map27.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map27);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError4(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end6 = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError4);
      if (end6.comment) {
        if (coll.comment)
          coll.comment += `
` + end6.comment;
        else
          coll.comment = end6.comment;
      }
      coll.range = [fc.offset, cePos, end6.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError4, tagName, tag2) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError4, tag2) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError4, tag2) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError4, tag2);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError4) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError4(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError4(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError4, tagName);
    }
    let tag2 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag2) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag2 = kt;
      } else {
        if (kt) {
          onError4(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError4(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError4, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError4, tagName, tag2);
    const res = tag2.resolve?.(coll, (msg) => onError4(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity3.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag2?.format)
      node.format = tag2.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError4) {
    const start3 = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError4);
    if (!header)
      return { value: "", type: null, comment: "", range: [start3, start3, start3] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines4(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end7 = start3 + header.length;
      if (scalar.source)
        end7 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start3, end7, end7] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent3, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent3.length > trimIndent)
          trimIndent = indent3.length;
      } else {
        if (indent3.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError4(offset + indent3.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent3.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError4(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent3.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent3, content] = lines[i];
      offset += indent3.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent3.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError4(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent3 = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent3.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent3.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent3.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end6 = start3 + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start3, end6, end6] };
  }
  function parseBlockScalarHeader({ offset, props }, strict2, onError4) {
    if (props[0].type !== "block-scalar-header") {
      onError4(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent3 = 0;
    let chomp = "";
    let error4 = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent3 && n)
          indent3 = n;
        else if (error4 === -1)
          error4 = offset + i;
      }
    }
    if (error4 !== -1)
      onError4(error4, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length3 = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length3 += token.source.length;
          break;
        case "comment":
          if (strict2 && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError4(token, "MISSING_CHAR", message);
          }
          length3 += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError4(token, "UNEXPECTED_TOKEN", token.message);
          length3 += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError4(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length3 += ts.length;
        }
      }
    }
    return { mode, indent: indent3, chomp, comment, length: length3 };
  }
  function splitLines4(source) {
    const split2 = source.split(/\n( *)/);
    const first3 = split2[0];
    const m = first3.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first3.slice(m[1].length)] : ["", first3];
    const lines = [line0];
    for (let i = 1;i < split2.length; i += 2)
      lines.push([split2[i], split2[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict2, onError4) {
    const { offset, type, source, end: end6 } = scalar;
    let _type;
    let value;
    const _onError = (rel, code2, msg) => onError4(offset + rel, code2, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError4(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end6, valueEnd, strict2, onError4);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError4) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError4(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError4) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError4(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first3, line4;
    try {
      first3 = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line4 = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first3 = /(.*?)[ \t]*\r?\n/sy;
      line4 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match20 = first3.exec(source);
    if (!match20)
      return source;
    let res = match20[1];
    let sep = " ";
    let pos = first3.lastIndex;
    line4.lastIndex = pos;
    while (match20 = line4.exec(source)) {
      if (match20[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match20[1];
        sep = " ";
      }
      pos = line4.lastIndex;
    }
    const last5 = /[ \t]*(.*)/sy;
    last5.lastIndex = pos;
    match20 = last5.exec(source);
    return res + sep + (match20?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError4) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold: fold2, offset } = foldNewline(source, i);
        res += fold2;
        i = offset;
      } else if (ch === "\\") {
        let next4 = source[++i];
        const cc = escapeCodes[next4];
        if (cc)
          res += cc;
        else if (next4 === `
`) {
          next4 = source[i + 1];
          while (next4 === " " || next4 === "\t")
            next4 = source[++i + 1];
        } else if (next4 === "\r" && source[i + 1] === `
`) {
          next4 = source[++i + 1];
          while (next4 === " " || next4 === "\t")
            next4 = source[++i + 1];
        } else if (next4 === "x" || next4 === "u" || next4 === "U") {
          const length3 = { x: 2, u: 4, U: 8 }[next4];
          res += parseCharCode(source, i + 1, length3, onError4);
          i += length3;
        } else {
          const raw = source.substr(i - 1, 2);
          onError4(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next4 = source[i + 1];
        while (next4 === " " || next4 === "\t")
          next4 = source[++i + 1];
        if (next4 !== `
` && !(next4 === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError4(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold2 = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold2 += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold2)
      fold2 = " ";
    return { fold: fold2, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length3, onError4) {
    const cc = source.substr(offset, length3);
    const ok = cc.length === length3 && /^[0-9a-fA-F]+$/.test(cc);
    const code2 = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code2)) {
      const raw = source.substr(offset - 2, length3 + 2);
      onError4(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code2);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity3 = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError4) {
    const { value, type, comment, range: range3 } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError4) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError4);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError4(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag2;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag2 = ctx.schema[identity3.SCALAR];
    } else if (tagName)
      tag2 = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError4);
    else if (token.type === "scalar")
      tag2 = findScalarTagByTest(ctx, value, token, onError4);
    else
      tag2 = ctx.schema[identity3.SCALAR];
    let scalar;
    try {
      const res = tag2.resolve(value, (msg) => onError4(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity3.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error4) {
      const msg = error4 instanceof Error ? error4.message : String(error4);
      onError4(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range3;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag2.format)
      scalar.format = tag2.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError4) {
    if (tagName === "!")
      return schema[identity3.SCALAR];
    const matchWithTest = [];
    for (const tag2 of schema.tags) {
      if (!tag2.collection && tag2.tag === tagName) {
        if (tag2.default && tag2.test)
          matchWithTest.push(tag2);
        else
          return tag2;
      }
    }
    for (const tag2 of matchWithTest)
      if (tag2.test?.test(value))
        return tag2;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError4(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity3.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError4) {
    const tag2 = schema.tags.find((tag3) => (tag3.default === true || atKey && tag3.default === "key") && tag3.test?.test(value)) || schema[identity3.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema[identity3.SCALAR];
      if (tag2.tag !== compat.tag) {
        const ts = directives.tagString(tag2.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError4(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag2;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before2, pos) {
    if (before2) {
      pos ?? (pos = before2.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before2[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before2[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before2[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity3 = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError4) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag: tag2 } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError4);
        if (anchor || tag2)
          onError4(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag2, onError4);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError4);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError4(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError4);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError4(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity3.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError4(tag2 ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before2, pos, { spaceBefore, comment, anchor, tag: tag2, end: end6 }, onError4) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before2, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag2, onError4);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError4(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end6;
    }
    return node;
  }
  function composeAlias({ options: options3 }, { offset, source, end: end6 }, onError4) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError4(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError4(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end6, valueEnd, options3.strict, onError4);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options3, directives, { offset, start: start3, value, end: end6 }, onError4) {
    const opts = Object.assign({ _directives: directives }, options3);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start3, {
      indicator: "doc-start",
      next: value ?? end6?.[0],
      offset,
      onError: onError4,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError4(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError4) : composeNode.composeEmptyNode(ctx, props.end, start3, null, props, onError4);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end6, contentEnd, false, onError4);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity3 = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options3 = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code2, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code2, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code2, message));
      };
      this.directives = new directives.Directives({ version: options3.version || "1.2" });
      this.options = options3;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity3.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity3.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error4 = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error4);
          else
            this.doc.errors.push(error4);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end6 = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end6.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end6.comment}` : end6.comment;
          }
          this.doc.range[2] = end6.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict2 = true, onError4) {
    if (token) {
      const _onError = (pos, code2, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError4)
          onError4(offset, code2, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code2, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict2, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict: strict2 } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context8) {
    const { implicitKey = false, indent: indent3, inFlow = false, offset = -1, type = "PLAIN" } = context8;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent3 > 0 ? " ".repeat(indent3) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end6 = context8.end ?? [
      { type: "newline", offset: -1, indent: indent3, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head5 = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent: indent3, source: head5 }
        ];
        if (!addEndtoBlockProps(props, end6))
          props.push({ type: "newline", offset: -1, indent: indent3, source: `
` });
        return { type: "block-scalar", offset, indent: indent3, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent: indent3, source, end: end6 };
      case "'":
        return { type: "single-quoted-scalar", offset, indent: indent3, source, end: end6 };
      default:
        return { type: "scalar", offset, indent: indent3, source, end: end6 };
    }
  }
  function setScalarValue(token, value, context8 = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context8;
    let indent3 = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent3 === "number")
      indent3 += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent3 === null,
      indent: indent3 !== null && indent3 > 0 ? " ".repeat(indent3) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head5 = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head5;
      token.source = body;
    } else {
      const { offset } = token;
      const indent3 = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent: indent3, source: head5 }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent: indent3, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent: indent3, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end6) {
    if (end6)
      for (const st of end6)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end6 = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end6)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end: end6 });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent3 = "indent" in token ? token.indent : -1;
        const end6 = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent: indent3, source, end: end6 });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify2 = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start: start3, key, sep, value }) {
    let res = "";
    for (const st of start3)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify2;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty19(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next4 = this.next ?? "stream";
      while (next4 && (incomplete || this.hasChars(1)))
        next4 = yield* this.parseNext(next4);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent3 = 0;
        while (ch === " ")
          ch = this.buffer[++indent3 + offset];
        if (ch === "\r") {
          const next4 = this.buffer[indent3 + offset + 1];
          if (next4 === `
` || !next4 && !this.atEnd)
            return offset + indent3 + 1;
        }
        return ch === `
` || indent3 >= this.indentNext || !ch && !this.atEnd ? offset + indent3 : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty19(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end6 = this.lineEndPos;
      if (typeof end6 !== "number" || end6 !== -1 && end6 < this.pos) {
        end6 = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end6;
      }
      if (end6 === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end6 - 1] === "\r")
        end6 -= 1;
      return this.buffer.substring(this.pos, end6);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next4) {
      switch (next4) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line4 = this.getLine();
      if (line4 === null)
        return this.setNext("stream");
      if (line4[0] === cst.BOM) {
        yield* this.pushCount(1);
        line4 = line4.substring(1);
      }
      if (line4[0] === "%") {
        let dirEnd = line4.length;
        let cs = line4.indexOf("#");
        while (cs !== -1) {
          const ch = line4[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line4.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line4[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line4.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line4.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty19(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty19(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty19(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line4 = this.getLine();
      if (line4 === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line4[n]) {
        case "#":
          yield* this.pushCount(line4.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line4.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent3 = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent3 = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line4 = this.getLine();
      if (line4 === null)
        return this.setNext("flow");
      if (indent3 !== -1 && indent3 < this.indentNext && line4[0] !== "#" || indent3 === 0 && (line4.startsWith("---") || line4.startsWith("...")) && isEmpty19(line4[3])) {
        const atFlowEndMarker = indent3 === this.indentNext - 1 && this.flowLevel === 1 && (line4[0] === "]" || line4[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line4[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line4[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line4.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next4 = this.charAt(1);
          if (this.flowKey || isEmpty19(next4) || next4 === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end6 = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end6 !== -1 && this.buffer[end6 + 1] === "'")
          end6 = this.buffer.indexOf("'", end6 + 2);
      } else {
        while (end6 !== -1) {
          let n = 0;
          while (this.buffer[end6 - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end6 = this.buffer.indexOf('"', end6 + 1);
        }
      }
      const qb = this.buffer.substring(0, end6);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end6 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end6 === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end6 = this.buffer.length;
      }
      yield* this.pushToIndex(end6 + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty19(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent3 = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent3 += 1;
              break;
            case `
`:
              nl = i2;
              indent3 = 0;
              break;
            case "\r": {
              const next4 = this.buffer[i2 + 1];
              if (!next4 && !this.atEnd)
                return this.setNext("block-scalar");
              if (next4 === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent3 >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent3;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent3 > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end6 = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next4 = this.buffer[i + 1];
          if (isEmpty19(next4) || inFlow && flowIndicatorChars.has(next4))
            break;
          end6 = i;
        } else if (isEmpty19(ch)) {
          let next4 = this.buffer[i + 1];
          if (ch === "\r") {
            if (next4 === `
`) {
              i += 1;
              ch = `
`;
              next4 = this.buffer[i + 1];
            } else
              end6 = i;
          }
          if (next4 === "#" || inFlow && flowIndicatorChars.has(next4))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end6 = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end6 + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty19(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty19(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start3 = this.lineStarts[low - 1];
        return { line: low, col: offset - start3 + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser2 = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list3, type) {
    for (let i = 0;i < list3.length; ++i)
      if (list3[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list3) {
    for (let i = 0;i < list3.length; ++i) {
      switch (list3[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error4) {
      const token = error4 ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last5 = token.items[token.items.length - 1];
          if (last5 && !last5.sep && !last5.value && last5.start.length > 0 && findNonEmptyIndex(last5.start) === -1 && (token.indent === 0 || last5.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last5.start;
            else
              top.items.push({ start: last5.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start3 = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map27 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start: start3, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map27;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map27) {
      const it = map27.items[map27.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end6 = "end" in it.value ? it.value.end : undefined;
            const last5 = Array.isArray(end6) ? end6[end6.length - 1] : undefined;
            if (last5?.type === "comment")
              end6?.push(this.sourceToken);
            else
              map27.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map27.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map27.indent)) {
              const prev = map27.items[map27.items.length - 2];
              const end6 = prev?.value?.end;
              if (Array.isArray(end6)) {
                Array.prototype.push.apply(end6, it.start);
                end6.push(this.sourceToken);
                map27.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map27.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map27.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start3 = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map27.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start3 = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start3.push(this.sourceToken);
              map27.items.push({ start: start3 });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start3.push(this.sourceToken);
              map27.items.push({ start: start3, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start4 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start4, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map27.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start4 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start4, key, sep }]
                });
              } else if (start3.length > 0) {
                it.sep = it.sep.concat(start3, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map27.items.push({ start: start3, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map27.items.push({ start: start3, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map27);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map27.items.push({ start: start3 });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq2) {
      const it = seq2.items[seq2.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end6 = "end" in it.value ? it.value.end : undefined;
            const last5 = Array.isArray(end6) ? end6[end6.length - 1] : undefined;
            if (last5?.type === "comment")
              end6?.push(this.sourceToken);
            else
              seq2.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq2.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq2.indent)) {
              const prev = seq2.items[seq2.items.length - 2];
              const end6 = prev?.value?.end;
              if (Array.isArray(end6)) {
                Array.prototype.push.apply(end6, it.start);
                end6.push(this.sourceToken);
                seq2.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq2.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq2.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq2.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq2.indent) {
        const bv = this.startBlockValue(seq2);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map27 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start: start3, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map27;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          start3.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start3, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start3, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start3, indent3) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent3)
        return false;
      return start3.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log4 = require_log();
  var identity3 = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser2();
  function parseOptions(options3) {
    const prettyErrors2 = options3.prettyErrors !== false;
    const lineCounter$1 = options3.lineCounter || prettyErrors2 && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors: prettyErrors2 };
  }
  function parseAllDocuments(source, options3 = {}) {
    const { lineCounter: lineCounter2, prettyErrors: prettyErrors2 } = parseOptions(options3);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options3);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors2 && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options3 = {}) {
    const { lineCounter: lineCounter2, prettyErrors: prettyErrors2 } = parseOptions(options3);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options3);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors2 && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse3(src, reviver, options3) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options3 === undefined && reviver && typeof reviver === "object") {
      options3 = reviver;
    }
    const doc = parseDocument(src, options3);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log4.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options3));
  }
  function stringify2(value, replacer, options3) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options3 === undefined && replacer) {
      options3 = replacer;
    }
    if (typeof options3 === "string")
      options3 = options3.length;
    if (typeof options3 === "number") {
      const indent3 = Math.round(options3);
      options3 = indent3 < 1 ? undefined : indent3 > 8 ? { indent: 8 } : { indent: indent3 };
    }
    if (value === undefined) {
      const { keepUndefined } = options3 ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity3.isDocument(value) && !_replacer)
      return value.toString(options3);
    return new Document.Document(value, _replacer, options3).toString(options3);
  }
  exports.parse = parse3;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify2;
});

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.6.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path2 = __require("path");
  var os = __require("os");
  var crypto = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse8(src) {
    const obj = {};
    let lines3 = src.toString();
    lines3 = lines3.replace(/\r\n?/mg, `
`);
    let match21;
    while ((match21 = LINE.exec(lines3)) != null) {
      const key = match21[1];
      let value6 = match21[2] || "";
      value6 = value6.trim();
      const maybeQuote = value6[0];
      value6 = value6.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value6 = value6.replace(/\\n/g, `
`);
        value6 = value6.replace(/\\r/g, "\r");
      }
      obj[key] = value6;
    }
    return obj;
  }
  function _parseVault(options3) {
    options3 = options3 || {};
    const vaultPath = _vaultPath(options3);
    options3.path = vaultPath;
    const result = DotenvModule.configDotenv(options3);
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys5 = _dotenvKey(options3).split(",");
    const length3 = keys5.length;
    let decrypted;
    for (let i = 0;i < length3; i++) {
      try {
        const key = keys5[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error4) {
        if (i + 1 >= length3) {
          throw error4;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
  }
  function _dotenvKey(options3) {
    if (options3 && options3.DOTENV_KEY && options3.DOTENV_KEY.length > 0) {
      return options3.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error4) {
      if (error4.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error4;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment2 = uri.searchParams.get("environment");
    if (!environment2) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment2.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options3) {
    let possibleVaultPath = null;
    if (options3 && options3.path && options3.path.length > 0) {
      if (Array.isArray(options3.path)) {
        for (const filepath of options3.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options3.path.endsWith(".vault") ? options3.path : `${options3.path}.vault`;
      }
    } else {
      possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options3) {
    const debug2 = Boolean(options3 && options3.debug);
    const quiet = options3 && "quiet" in options3 ? options3.quiet : true;
    if (debug2 || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options3);
    let processEnv = process.env;
    if (options3 && options3.processEnv != null) {
      processEnv = options3.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options3);
    return { parsed };
  }
  function configDotenv(options3) {
    const dotenvPath = path2.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug2 = Boolean(options3 && options3.debug);
    const quiet = options3 && "quiet" in options3 ? options3.quiet : true;
    if (options3 && options3.encoding) {
      encoding = options3.encoding;
    } else {
      if (debug2) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options3 && options3.path) {
      if (!Array.isArray(options3.path)) {
        optionPaths = [_resolveHome(options3.path)];
      } else {
        optionPaths = [];
        for (const filepath of options3.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path3 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path3, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options3);
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${path3} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options3 && options3.processEnv != null) {
      processEnv = options3.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options3);
    if (debug2 || !quiet) {
      const keysCount = Object.keys(parsedAll).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path2.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug2) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config2(options3) {
    if (_dotenvKey(options3).length === 0) {
      return DotenvModule.configDotenv(options3);
    }
    const vaultPath = _vaultPath(options3);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options3);
    }
    return DotenvModule._configVault(options3);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error4) {
      const isRange = error4 instanceof RangeError;
      const invalidKeyLength = error4.message === "Invalid key length";
      const decryptionFailed = error4.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error4;
      }
    }
  }
  function populate(processEnv, parsed, options3 = {}) {
    const debug2 = Boolean(options3 && options3.debug);
    const override = Boolean(options3 && options3.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug2) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse8,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS((exports, module) => {
  var options3 = {};
  if (process.env.DOTENV_CONFIG_ENCODING != null) {
    options3.encoding = process.env.DOTENV_CONFIG_ENCODING;
  }
  if (process.env.DOTENV_CONFIG_PATH != null) {
    options3.path = process.env.DOTENV_CONFIG_PATH;
  }
  if (process.env.DOTENV_CONFIG_QUIET != null) {
    options3.quiet = process.env.DOTENV_CONFIG_QUIET;
  }
  if (process.env.DOTENV_CONFIG_DEBUG != null) {
    options3.debug = process.env.DOTENV_CONFIG_DEBUG;
  }
  if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
    options3.override = process.env.DOTENV_CONFIG_OVERRIDE;
  }
  if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
    options3.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
  }
  module.exports = options3;
});

// node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS((exports, module) => {
  var re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
  module.exports = function optionMatcher(args2) {
    const options3 = args2.reduce(function(acc, cur) {
      const matches = cur.match(re);
      if (matches) {
        acc[matches[1]] = matches[2];
      }
      return acc;
    }, {});
    if (!("quiet" in options3)) {
      options3.quiet = "true";
    }
    return options3;
  };
});

// node_modules/dotenv/config.js
var require_config = __commonJS(() => {
  (function() {
    require_main().config(Object.assign({}, require_env_options(), require_cli_options()(process.argv)));
  })();
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS((exports, module) => {
  var hasBuffer = typeof Buffer !== "undefined";
  var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function _parse(text11, reviver, options3) {
    if (options3 == null) {
      if (reviver !== null && typeof reviver === "object") {
        options3 = reviver;
        reviver = undefined;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text11)) {
      text11 = text11.toString();
    }
    if (text11 && text11.charCodeAt(0) === 65279) {
      text11 = text11.slice(1);
    }
    const obj = JSON.parse(text11, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options3 && options3.protoAction || "error";
    const constructorAction = options3 && options3.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text11) === false && suspectConstructorRx.test(text11) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text11) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text11) === false) {
        return obj;
      }
    }
    return filter13(obj, { protoAction, constructorAction, safe: options3 && options3.safe });
  }
  function filter13(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next4 = [obj];
    while (next4.length) {
      const nodes = next4;
      next4 = [];
      for (const node of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.constructor;
        }
        for (const key in node) {
          const value6 = node[key];
          if (value6 && typeof value6 === "object") {
            next4.push(value6);
          }
        }
      }
    }
    return obj;
  }
  function parse8(text11, reviver, options3) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text11, reviver, options3);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  function safeParse(text11, reviver) {
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text11, reviver, { safe: true });
    } catch (_e) {
      return null;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  module.exports = parse8;
  module.exports.default = parse8;
  module.exports.parse = parse8;
  module.exports.safeParse = safeParse;
  module.exports.scan = filter13;
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p3 in m)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
        __createBinding(exports2, m, p3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p3 in m)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
        __createBinding(exports2, m, p3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type2, instance, diag, allowOverride = false) {
    var _a16;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a16 !== undefined ? _a16 : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type2]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type2}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type2} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type2] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type2} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type2) {
    var _a16, _b;
    const globalVersion = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a16 === undefined ? undefined : _a16.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type2];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type2, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type2} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type2];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args2) {
      return logProxy("debug", this._namespace, args2);
    }
    error(...args2) {
      return logProxy("error", this._namespace, args2);
    }
    info(...args2) {
      return logProxy("info", this._namespace, args2);
    }
    warn(...args2) {
      return logProxy("warn", this._namespace, args2);
    }
    verbose(...args2) {
      return logProxy("verbose", this._namespace, args2);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args2) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args2.unshift(namespace);
    return logger[funcName](...args2);
  }
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {};
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args2) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args2);
        };
      }
      const self = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a16, _b, _c;
        if (logger === self) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a16 = err.stack) !== null && _a16 !== undefined ? _a16 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self);
      };
      self.createComponentLogger = (options3) => {
        return new ComponentLogger_1.DiagComponentLogger(options3);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries2) {
      this._entries = entries2 ? new Map(entries2) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys5) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys5) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries2 = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries2)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self = this;
      self._currentContext = parentContext ? new Map(parentContext) : new Map;
      self.getValue = (key) => self._currentContext.get(key);
      self.setValue = (key, value6) => {
        const context8 = new BaseContext(self._currentContext);
        context8._currentContext.set(key, value6);
        return context8;
      };
      self.deleteValue = (key) => {
        const context8 = new BaseContext(self._currentContext);
        context8._currentContext.delete(key);
        return context8;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args2) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args2);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {}
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback) {}
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {}
    removeCallback(_callback) {}
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value6) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value6;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args2) {
      return fn.call(thisArg, ...args2);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context8, fn, thisArg, ...args2) {
      return this._getContextManager().with(context8, fn, thisArg, ...args2);
    }
    bind(context8, target) {
      return this._getContextManager().bind(context8, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {}
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {}
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan2(context8) {
    return context8.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan2;
  function getActiveSpan() {
    return getSpan2(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context8, span3) {
    return context8.setValue(SPAN_KEY, span3);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context8) {
    return context8.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context8, spanContext) {
    return setSpan(context8, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context8) {
    var _a16;
    return (_a16 = getSpan2(context8)) === null || _a16 === undefined ? undefined : _a16.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name15, options3, context8 = contextApi.active()) {
      const root = Boolean(options3 === null || options3 === undefined ? undefined : options3.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context8 && (0, context_utils_1.getSpanContext)(context8);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name15, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span3 = this.startSpan(name15, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span3);
      return contextApi.with(contextWithSpanSet, fn, undefined, span3);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name15, version, options3) {
      this._provider = _provider;
      this.name = name15;
      this.version = version;
      this.options = options3;
    }
    startSpan(name15, options3, context8) {
      return this._getTracer().startSpan(name15, options3, context8);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer2 = this._getTracer();
      return Reflect.apply(tracer2.startActiveSpan, tracer2, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer2 = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer2) {
        return NOOP_TRACER;
      }
      this._delegate = tracer2;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version2, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name15, version, options3) {
      var _a16;
      return (_a16 = this.getDelegateTracer(name15, version, options3)) !== null && _a16 !== undefined ? _a16 : new ProxyTracer_1.ProxyTracer(this, name15, version, options3);
    }
    getDelegate() {
      var _a16;
      return (_a16 = this._delegate) !== null && _a16 !== undefined ? _a16 : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name15, version, options3) {
      var _a16;
      return (_a16 = this._delegate) === null || _a16 === undefined ? undefined : _a16.getTracer(name15, version, options3);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value6) {
    return VALID_VALUE_BASE_REGEX.test(value6) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value6);
  }
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value6) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value6);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value6 = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value6)) {
            agg.set(key, value6);
          } else {}
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version2, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name15, version, options3) {
      return this.getMeterProvider().getMeter(name15, version, options3);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {}
    extract(context8, _carrier) {
      return context8;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context8) {
    return context8.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context8, baggage) {
    return context8.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context8) {
    return context8.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context8, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context8, carrier, setter);
    }
    extract(context8, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context8, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name15, version) {
      return this.getTracerProvider().getTracer(name15, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/@notionhq/client/build/src/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObject = exports.pick = exports.assertNever = undefined;
  function assertNever(value6) {
    throw new Error(`Unexpected value should never occur: ${value6}`);
  }
  exports.assertNever = assertNever;
  function pick5(base, keys5) {
    const entries2 = keys5.map((key) => [key, base === null || base === undefined ? undefined : base[key]]);
    return Object.fromEntries(entries2);
  }
  exports.pick = pick5;
  function isObject3(o) {
    return typeof o === "object" && o !== null;
  }
  exports.isObject = isObject3;
});

// node_modules/@notionhq/client/build/src/logging.js
var require_logging = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logLevelSeverity = exports.makeConsoleLogger = exports.LogLevel = undefined;
  var utils_1 = require_utils3();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "debug";
    LogLevel2["INFO"] = "info";
    LogLevel2["WARN"] = "warn";
    LogLevel2["ERROR"] = "error";
  })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
  function makeConsoleLogger(name15) {
    return (level, message, extraInfo) => {
      console[level](`${name15} ${level}:`, message, extraInfo);
    };
  }
  exports.makeConsoleLogger = makeConsoleLogger;
  function logLevelSeverity(level) {
    switch (level) {
      case LogLevel.DEBUG:
        return 20;
      case LogLevel.INFO:
        return 40;
      case LogLevel.WARN:
        return 60;
      case LogLevel.ERROR:
        return 80;
      default:
        return (0, utils_1.assertNever)(level);
    }
  }
  exports.logLevelSeverity = logLevelSeverity;
});

// node_modules/@notionhq/client/build/src/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = undefined;
  var utils_1 = require_utils3();
  var APIErrorCode;
  (function(APIErrorCode2) {
    APIErrorCode2["Unauthorized"] = "unauthorized";
    APIErrorCode2["RestrictedResource"] = "restricted_resource";
    APIErrorCode2["ObjectNotFound"] = "object_not_found";
    APIErrorCode2["RateLimited"] = "rate_limited";
    APIErrorCode2["InvalidJSON"] = "invalid_json";
    APIErrorCode2["InvalidRequestURL"] = "invalid_request_url";
    APIErrorCode2["InvalidRequest"] = "invalid_request";
    APIErrorCode2["ValidationError"] = "validation_error";
    APIErrorCode2["ConflictError"] = "conflict_error";
    APIErrorCode2["InternalServerError"] = "internal_server_error";
    APIErrorCode2["ServiceUnavailable"] = "service_unavailable";
  })(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));
  var ClientErrorCode;
  (function(ClientErrorCode2) {
    ClientErrorCode2["RequestTimeout"] = "notionhq_client_request_timeout";
    ClientErrorCode2["ResponseError"] = "notionhq_client_response_error";
  })(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));

  class NotionClientErrorBase extends Error {
  }
  function isNotionClientError(error4) {
    return (0, utils_1.isObject)(error4) && error4 instanceof NotionClientErrorBase;
  }
  exports.isNotionClientError = isNotionClientError;
  function isNotionClientErrorWithCode(error4, codes) {
    return isNotionClientError(error4) && error4.code in codes;
  }

  class RequestTimeoutError extends NotionClientErrorBase {
    constructor(message = "Request to Notion API has timed out") {
      super(message);
      this.code = ClientErrorCode.RequestTimeout;
      this.name = "RequestTimeoutError";
    }
    static isRequestTimeoutError(error4) {
      return isNotionClientErrorWithCode(error4, {
        [ClientErrorCode.RequestTimeout]: true
      });
    }
    static rejectAfterTimeout(promise4, timeoutMS) {
      return new Promise((resolve4, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new RequestTimeoutError);
        }, timeoutMS);
        promise4.then(resolve4).catch(reject).then(() => clearTimeout(timeoutId));
      });
    }
  }
  exports.RequestTimeoutError = RequestTimeoutError;

  class HTTPResponseError extends NotionClientErrorBase {
    constructor(args2) {
      super(args2.message);
      this.name = "HTTPResponseError";
      const { code: code2, status: status2, headers, rawBodyText } = args2;
      this.code = code2;
      this.status = status2;
      this.headers = headers;
      this.body = rawBodyText;
    }
  }
  var httpResponseErrorCodes = {
    [ClientErrorCode.ResponseError]: true,
    [APIErrorCode.Unauthorized]: true,
    [APIErrorCode.RestrictedResource]: true,
    [APIErrorCode.ObjectNotFound]: true,
    [APIErrorCode.RateLimited]: true,
    [APIErrorCode.InvalidJSON]: true,
    [APIErrorCode.InvalidRequestURL]: true,
    [APIErrorCode.InvalidRequest]: true,
    [APIErrorCode.ValidationError]: true,
    [APIErrorCode.ConflictError]: true,
    [APIErrorCode.InternalServerError]: true,
    [APIErrorCode.ServiceUnavailable]: true
  };
  function isHTTPResponseError(error4) {
    if (!isNotionClientErrorWithCode(error4, httpResponseErrorCodes)) {
      return false;
    }
    return true;
  }
  exports.isHTTPResponseError = isHTTPResponseError;

  class UnknownHTTPResponseError extends HTTPResponseError {
    constructor(args2) {
      var _a16;
      super({
        ...args2,
        code: ClientErrorCode.ResponseError,
        message: (_a16 = args2.message) !== null && _a16 !== undefined ? _a16 : `Request to Notion API failed with status: ${args2.status}`
      });
      this.name = "UnknownHTTPResponseError";
    }
    static isUnknownHTTPResponseError(error4) {
      return isNotionClientErrorWithCode(error4, {
        [ClientErrorCode.ResponseError]: true
      });
    }
  }
  exports.UnknownHTTPResponseError = UnknownHTTPResponseError;
  var apiErrorCodes = {
    [APIErrorCode.Unauthorized]: true,
    [APIErrorCode.RestrictedResource]: true,
    [APIErrorCode.ObjectNotFound]: true,
    [APIErrorCode.RateLimited]: true,
    [APIErrorCode.InvalidJSON]: true,
    [APIErrorCode.InvalidRequestURL]: true,
    [APIErrorCode.InvalidRequest]: true,
    [APIErrorCode.ValidationError]: true,
    [APIErrorCode.ConflictError]: true,
    [APIErrorCode.InternalServerError]: true,
    [APIErrorCode.ServiceUnavailable]: true
  };

  class APIResponseError extends HTTPResponseError {
    constructor() {
      super(...arguments);
      this.name = "APIResponseError";
    }
    static isAPIResponseError(error4) {
      return isNotionClientErrorWithCode(error4, apiErrorCodes);
    }
  }
  exports.APIResponseError = APIResponseError;
  function buildRequestError(response, bodyText) {
    const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);
    if (apiErrorResponseBody !== undefined) {
      return new APIResponseError({
        code: apiErrorResponseBody.code,
        message: apiErrorResponseBody.message,
        headers: response.headers,
        status: response.status,
        rawBodyText: bodyText
      });
    }
    return new UnknownHTTPResponseError({
      message: undefined,
      headers: response.headers,
      status: response.status,
      rawBodyText: bodyText
    });
  }
  exports.buildRequestError = buildRequestError;
  function parseAPIErrorResponseBody(body) {
    if (typeof body !== "string") {
      return;
    }
    let parsed;
    try {
      parsed = JSON.parse(body);
    } catch (parseError3) {
      return;
    }
    if (!(0, utils_1.isObject)(parsed) || typeof parsed["message"] !== "string" || !isAPIErrorCode(parsed["code"])) {
      return;
    }
    return {
      ...parsed,
      code: parsed["code"],
      message: parsed["message"]
    };
  }
  function isAPIErrorCode(code2) {
    return typeof code2 === "string" && code2 in apiErrorCodes;
  }
});

// node_modules/@notionhq/client/build/src/api-endpoints.js
var require_api_endpoints = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oauthIntrospect = exports.oauthRevoke = exports.oauthToken = exports.listComments = exports.createComment = exports.search = exports.createDatabase = exports.listDatabases = exports.queryDatabase = exports.updateDatabase = exports.getDatabase = exports.appendBlockChildren = exports.listBlockChildren = exports.deleteBlock = exports.updateBlock = exports.getBlock = exports.getPageProperty = exports.updatePage = exports.getPage = exports.createPage = exports.listUsers = exports.getUser = exports.getSelf = undefined;
  exports.getSelf = {
    method: "get",
    pathParams: [],
    queryParams: [],
    bodyParams: [],
    path: () => `users/me`
  };
  exports.getUser = {
    method: "get",
    pathParams: ["user_id"],
    queryParams: [],
    bodyParams: [],
    path: (p3) => `users/${p3.user_id}`
  };
  exports.listUsers = {
    method: "get",
    pathParams: [],
    queryParams: ["start_cursor", "page_size"],
    bodyParams: [],
    path: () => `users`
  };
  exports.createPage = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["parent", "properties", "icon", "cover", "content", "children"],
    path: () => `pages`
  };
  exports.getPage = {
    method: "get",
    pathParams: ["page_id"],
    queryParams: ["filter_properties"],
    bodyParams: [],
    path: (p3) => `pages/${p3.page_id}`
  };
  exports.updatePage = {
    method: "patch",
    pathParams: ["page_id"],
    queryParams: [],
    bodyParams: ["properties", "icon", "cover", "archived", "in_trash"],
    path: (p3) => `pages/${p3.page_id}`
  };
  exports.getPageProperty = {
    method: "get",
    pathParams: ["page_id", "property_id"],
    queryParams: ["start_cursor", "page_size"],
    bodyParams: [],
    path: (p3) => `pages/${p3.page_id}/properties/${p3.property_id}`
  };
  exports.getBlock = {
    method: "get",
    pathParams: ["block_id"],
    queryParams: [],
    bodyParams: [],
    path: (p3) => `blocks/${p3.block_id}`
  };
  exports.updateBlock = {
    method: "patch",
    pathParams: ["block_id"],
    queryParams: [],
    bodyParams: [
      "embed",
      "type",
      "archived",
      "in_trash",
      "bookmark",
      "image",
      "video",
      "pdf",
      "file",
      "audio",
      "code",
      "equation",
      "divider",
      "breadcrumb",
      "table_of_contents",
      "link_to_page",
      "table_row",
      "heading_1",
      "heading_2",
      "heading_3",
      "paragraph",
      "bulleted_list_item",
      "numbered_list_item",
      "quote",
      "to_do",
      "toggle",
      "template",
      "callout",
      "synced_block",
      "table"
    ],
    path: (p3) => `blocks/${p3.block_id}`
  };
  exports.deleteBlock = {
    method: "delete",
    pathParams: ["block_id"],
    queryParams: [],
    bodyParams: [],
    path: (p3) => `blocks/${p3.block_id}`
  };
  exports.listBlockChildren = {
    method: "get",
    pathParams: ["block_id"],
    queryParams: ["start_cursor", "page_size"],
    bodyParams: [],
    path: (p3) => `blocks/${p3.block_id}/children`
  };
  exports.appendBlockChildren = {
    method: "patch",
    pathParams: ["block_id"],
    queryParams: [],
    bodyParams: ["children", "after"],
    path: (p3) => `blocks/${p3.block_id}/children`
  };
  exports.getDatabase = {
    method: "get",
    pathParams: ["database_id"],
    queryParams: [],
    bodyParams: [],
    path: (p3) => `databases/${p3.database_id}`
  };
  exports.updateDatabase = {
    method: "patch",
    pathParams: ["database_id"],
    queryParams: [],
    bodyParams: [
      "title",
      "description",
      "icon",
      "cover",
      "properties",
      "is_inline",
      "archived",
      "in_trash"
    ],
    path: (p3) => `databases/${p3.database_id}`
  };
  exports.queryDatabase = {
    method: "post",
    pathParams: ["database_id"],
    queryParams: ["filter_properties"],
    bodyParams: [
      "sorts",
      "filter",
      "start_cursor",
      "page_size",
      "archived",
      "in_trash"
    ],
    path: (p3) => `databases/${p3.database_id}/query`
  };
  exports.listDatabases = {
    method: "get",
    pathParams: [],
    queryParams: ["start_cursor", "page_size"],
    bodyParams: [],
    path: () => `databases`
  };
  exports.createDatabase = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: [
      "parent",
      "properties",
      "icon",
      "cover",
      "title",
      "description",
      "is_inline"
    ],
    path: () => `databases`
  };
  exports.search = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["sort", "query", "start_cursor", "page_size", "filter"],
    path: () => `search`
  };
  exports.createComment = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["parent", "rich_text", "discussion_id"],
    path: () => `comments`
  };
  exports.listComments = {
    method: "get",
    pathParams: [],
    queryParams: ["block_id", "start_cursor", "page_size"],
    bodyParams: [],
    path: () => `comments`
  };
  exports.oauthToken = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["grant_type", "code", "redirect_uri", "external_account"],
    path: () => `oauth/token`
  };
  exports.oauthRevoke = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["token"],
    path: () => `oauth/revoke`
  };
  exports.oauthIntrospect = {
    method: "post",
    pathParams: [],
    queryParams: [],
    bodyParams: ["token"],
    path: () => `oauth/introspect`
  };
});

// node_modules/@notionhq/client/build/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@notionhq/client",
    version: "2.3.0",
    description: "A simple and easy to use client for the Notion API",
    engines: {
      node: ">=12"
    },
    homepage: "https://developers.notion.com/docs/getting-started",
    bugs: {
      url: "https://github.com/makenotion/notion-sdk-js/issues"
    },
    repository: {
      type: "git",
      url: "https://github.com/makenotion/notion-sdk-js/"
    },
    keywords: [
      "notion",
      "notionapi",
      "rest",
      "notion-api"
    ],
    main: "./build/src",
    types: "./build/src/index.d.ts",
    scripts: {
      prepare: "npm run build",
      prepublishOnly: "npm run checkLoggedIn && npm run lint && npm run test",
      build: "tsc",
      prettier: "prettier --write .",
      lint: "prettier --check . && eslint . --ext .ts && cspell '**/*' ",
      test: "jest ./test",
      "check-links": "git ls-files | grep md$ | xargs -n 1 markdown-link-check",
      prebuild: "npm run clean",
      clean: "rm -rf ./build",
      checkLoggedIn: "./scripts/verifyLoggedIn.sh"
    },
    author: "",
    license: "MIT",
    files: [
      "build/package.json",
      "build/src/**"
    ],
    dependencies: {
      "@types/node-fetch": "^2.5.10",
      "node-fetch": "^2.6.1"
    },
    devDependencies: {
      "@types/jest": "^28.1.4",
      "@typescript-eslint/eslint-plugin": "^5.39.0",
      "@typescript-eslint/parser": "^5.39.0",
      cspell: "^5.4.1",
      eslint: "^7.24.0",
      jest: "^28.1.2",
      "markdown-link-check": "^3.8.7",
      prettier: "^2.8.8",
      "ts-jest": "^28.0.5",
      typescript: "^4.8.4"
    }
  };
});

// node_modules/@notionhq/client/build/src/Client.js
var require_Client = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value6, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value6) : f ? f.value = value6 : state.set(receiver, value6), value6;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Client_auth;
  var _Client_logLevel;
  var _Client_logger;
  var _Client_prefixUrl;
  var _Client_timeoutMs;
  var _Client_notionVersion;
  var _Client_fetch;
  var _Client_agent;
  var _Client_userAgent;
  Object.defineProperty(exports, "__esModule", { value: true });
  var logging_1 = require_logging();
  var errors_1 = require_errors2();
  var utils_1 = require_utils3();
  var api_endpoints_1 = require_api_endpoints();
  var node_fetch_1 = __require("node-fetch");
  var package_json_1 = require_package2();

  class Client {
    constructor(options3) {
      var _a16, _b, _c, _d, _e, _f;
      _Client_auth.set(this, undefined);
      _Client_logLevel.set(this, undefined);
      _Client_logger.set(this, undefined);
      _Client_prefixUrl.set(this, undefined);
      _Client_timeoutMs.set(this, undefined);
      _Client_notionVersion.set(this, undefined);
      _Client_fetch.set(this, undefined);
      _Client_agent.set(this, undefined);
      _Client_userAgent.set(this, undefined);
      this.blocks = {
        retrieve: (args2) => {
          return this.request({
            path: api_endpoints_1.getBlock.path(args2),
            method: api_endpoints_1.getBlock.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.getBlock.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.getBlock.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        update: (args2) => {
          return this.request({
            path: api_endpoints_1.updateBlock.path(args2),
            method: api_endpoints_1.updateBlock.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.updateBlock.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.updateBlock.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        delete: (args2) => {
          return this.request({
            path: api_endpoints_1.deleteBlock.path(args2),
            method: api_endpoints_1.deleteBlock.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.deleteBlock.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.deleteBlock.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        children: {
          append: (args2) => {
            return this.request({
              path: api_endpoints_1.appendBlockChildren.path(args2),
              method: api_endpoints_1.appendBlockChildren.method,
              query: (0, utils_1.pick)(args2, api_endpoints_1.appendBlockChildren.queryParams),
              body: (0, utils_1.pick)(args2, api_endpoints_1.appendBlockChildren.bodyParams),
              auth: args2 === null || args2 === undefined ? undefined : args2.auth
            });
          },
          list: (args2) => {
            return this.request({
              path: api_endpoints_1.listBlockChildren.path(args2),
              method: api_endpoints_1.listBlockChildren.method,
              query: (0, utils_1.pick)(args2, api_endpoints_1.listBlockChildren.queryParams),
              body: (0, utils_1.pick)(args2, api_endpoints_1.listBlockChildren.bodyParams),
              auth: args2 === null || args2 === undefined ? undefined : args2.auth
            });
          }
        }
      };
      this.databases = {
        list: (args2) => {
          return this.request({
            path: api_endpoints_1.listDatabases.path(),
            method: api_endpoints_1.listDatabases.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.listDatabases.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.listDatabases.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        retrieve: (args2) => {
          return this.request({
            path: api_endpoints_1.getDatabase.path(args2),
            method: api_endpoints_1.getDatabase.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.getDatabase.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.getDatabase.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        query: (args2) => {
          return this.request({
            path: api_endpoints_1.queryDatabase.path(args2),
            method: api_endpoints_1.queryDatabase.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.queryDatabase.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.queryDatabase.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        create: (args2) => {
          return this.request({
            path: api_endpoints_1.createDatabase.path(),
            method: api_endpoints_1.createDatabase.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.createDatabase.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.createDatabase.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        update: (args2) => {
          return this.request({
            path: api_endpoints_1.updateDatabase.path(args2),
            method: api_endpoints_1.updateDatabase.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.updateDatabase.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.updateDatabase.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        }
      };
      this.pages = {
        create: (args2) => {
          return this.request({
            path: api_endpoints_1.createPage.path(),
            method: api_endpoints_1.createPage.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.createPage.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.createPage.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        retrieve: (args2) => {
          return this.request({
            path: api_endpoints_1.getPage.path(args2),
            method: api_endpoints_1.getPage.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.getPage.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.getPage.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        update: (args2) => {
          return this.request({
            path: api_endpoints_1.updatePage.path(args2),
            method: api_endpoints_1.updatePage.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.updatePage.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.updatePage.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        properties: {
          retrieve: (args2) => {
            return this.request({
              path: api_endpoints_1.getPageProperty.path(args2),
              method: api_endpoints_1.getPageProperty.method,
              query: (0, utils_1.pick)(args2, api_endpoints_1.getPageProperty.queryParams),
              body: (0, utils_1.pick)(args2, api_endpoints_1.getPageProperty.bodyParams),
              auth: args2 === null || args2 === undefined ? undefined : args2.auth
            });
          }
        }
      };
      this.users = {
        retrieve: (args2) => {
          return this.request({
            path: api_endpoints_1.getUser.path(args2),
            method: api_endpoints_1.getUser.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.getUser.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.getUser.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        list: (args2) => {
          return this.request({
            path: api_endpoints_1.listUsers.path(),
            method: api_endpoints_1.listUsers.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.listUsers.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.listUsers.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        me: (args2) => {
          return this.request({
            path: api_endpoints_1.getSelf.path(),
            method: api_endpoints_1.getSelf.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.getSelf.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.getSelf.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        }
      };
      this.comments = {
        create: (args2) => {
          return this.request({
            path: api_endpoints_1.createComment.path(),
            method: api_endpoints_1.createComment.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.createComment.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.createComment.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        },
        list: (args2) => {
          return this.request({
            path: api_endpoints_1.listComments.path(),
            method: api_endpoints_1.listComments.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.listComments.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.listComments.bodyParams),
            auth: args2 === null || args2 === undefined ? undefined : args2.auth
          });
        }
      };
      this.search = (args2) => {
        return this.request({
          path: api_endpoints_1.search.path(),
          method: api_endpoints_1.search.method,
          query: (0, utils_1.pick)(args2, api_endpoints_1.search.queryParams),
          body: (0, utils_1.pick)(args2, api_endpoints_1.search.bodyParams),
          auth: args2 === null || args2 === undefined ? undefined : args2.auth
        });
      };
      this.oauth = {
        token: (args2) => {
          return this.request({
            path: api_endpoints_1.oauthToken.path(),
            method: api_endpoints_1.oauthToken.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.oauthToken.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.oauthToken.bodyParams),
            auth: {
              client_id: args2.client_id,
              client_secret: args2.client_secret
            }
          });
        },
        introspect: (args2) => {
          return this.request({
            path: api_endpoints_1.oauthIntrospect.path(),
            method: api_endpoints_1.oauthIntrospect.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.oauthIntrospect.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.oauthIntrospect.bodyParams),
            auth: {
              client_id: args2.client_id,
              client_secret: args2.client_secret
            }
          });
        },
        revoke: (args2) => {
          return this.request({
            path: api_endpoints_1.oauthRevoke.path(),
            method: api_endpoints_1.oauthRevoke.method,
            query: (0, utils_1.pick)(args2, api_endpoints_1.oauthRevoke.queryParams),
            body: (0, utils_1.pick)(args2, api_endpoints_1.oauthRevoke.bodyParams),
            auth: {
              client_id: args2.client_id,
              client_secret: args2.client_secret
            }
          });
        }
      };
      __classPrivateFieldSet(this, _Client_auth, options3 === null || options3 === undefined ? undefined : options3.auth, "f");
      __classPrivateFieldSet(this, _Client_logLevel, (_a16 = options3 === null || options3 === undefined ? undefined : options3.logLevel) !== null && _a16 !== undefined ? _a16 : logging_1.LogLevel.WARN, "f");
      __classPrivateFieldSet(this, _Client_logger, (_b = options3 === null || options3 === undefined ? undefined : options3.logger) !== null && _b !== undefined ? _b : (0, logging_1.makeConsoleLogger)(package_json_1.name), "f");
      __classPrivateFieldSet(this, _Client_prefixUrl, `${(_c = options3 === null || options3 === undefined ? undefined : options3.baseUrl) !== null && _c !== undefined ? _c : "https://api.notion.com"}/v1/`, "f");
      __classPrivateFieldSet(this, _Client_timeoutMs, (_d = options3 === null || options3 === undefined ? undefined : options3.timeoutMs) !== null && _d !== undefined ? _d : 60000, "f");
      __classPrivateFieldSet(this, _Client_notionVersion, (_e = options3 === null || options3 === undefined ? undefined : options3.notionVersion) !== null && _e !== undefined ? _e : Client.defaultNotionVersion, "f");
      __classPrivateFieldSet(this, _Client_fetch, (_f = options3 === null || options3 === undefined ? undefined : options3.fetch) !== null && _f !== undefined ? _f : node_fetch_1.default, "f");
      __classPrivateFieldSet(this, _Client_agent, options3 === null || options3 === undefined ? undefined : options3.agent, "f");
      __classPrivateFieldSet(this, _Client_userAgent, `notionhq-client/${package_json_1.version}`, "f");
    }
    async request({ path: path3, method, query, body, auth }) {
      this.log(logging_1.LogLevel.INFO, "request start", { method, path: path3 });
      const bodyAsJsonString = !body || Object.entries(body).length === 0 ? undefined : JSON.stringify(body);
      const url2 = new URL(`${__classPrivateFieldGet(this, _Client_prefixUrl, "f")}${path3}`);
      if (query) {
        for (const [key, value6] of Object.entries(query)) {
          if (value6 !== undefined) {
            if (Array.isArray(value6)) {
              value6.forEach((val) => url2.searchParams.append(key, decodeURIComponent(val)));
            } else {
              url2.searchParams.append(key, String(value6));
            }
          }
        }
      }
      let authorizationHeader;
      if (typeof auth === "object") {
        const unencodedCredential = `${auth.client_id}:${auth.client_secret}`;
        const encodedCredential = Buffer.from(unencodedCredential).toString("base64");
        authorizationHeader = { authorization: `Basic ${encodedCredential}` };
      } else {
        authorizationHeader = this.authAsHeaders(auth);
      }
      const headers = {
        ...authorizationHeader,
        "Notion-Version": __classPrivateFieldGet(this, _Client_notionVersion, "f"),
        "user-agent": __classPrivateFieldGet(this, _Client_userAgent, "f")
      };
      if (bodyAsJsonString !== undefined) {
        headers["content-type"] = "application/json";
      }
      try {
        const response = await errors_1.RequestTimeoutError.rejectAfterTimeout(__classPrivateFieldGet(this, _Client_fetch, "f").call(this, url2.toString(), {
          method: method.toUpperCase(),
          headers,
          body: bodyAsJsonString,
          agent: __classPrivateFieldGet(this, _Client_agent, "f")
        }), __classPrivateFieldGet(this, _Client_timeoutMs, "f"));
        const responseText = await response.text();
        if (!response.ok) {
          throw (0, errors_1.buildRequestError)(response, responseText);
        }
        const responseJson = JSON.parse(responseText);
        this.log(logging_1.LogLevel.INFO, "request success", { method, path: path3 });
        return responseJson;
      } catch (error4) {
        if (!(0, errors_1.isNotionClientError)(error4)) {
          throw error4;
        }
        this.log(logging_1.LogLevel.WARN, "request fail", {
          code: error4.code,
          message: error4.message
        });
        if ((0, errors_1.isHTTPResponseError)(error4)) {
          this.log(logging_1.LogLevel.DEBUG, "failed response body", {
            body: error4.body
          });
        }
        throw error4;
      }
    }
    log(level, message, extraInfo) {
      if ((0, logging_1.logLevelSeverity)(level) >= (0, logging_1.logLevelSeverity)(__classPrivateFieldGet(this, _Client_logLevel, "f"))) {
        __classPrivateFieldGet(this, _Client_logger, "f").call(this, level, message, extraInfo);
      }
    }
    authAsHeaders(auth) {
      const headers = {};
      const authHeaderValue = auth !== null && auth !== undefined ? auth : __classPrivateFieldGet(this, _Client_auth, "f");
      if (authHeaderValue !== undefined) {
        headers["authorization"] = `Bearer ${authHeaderValue}`;
      }
      return headers;
    }
  }
  exports.default = Client;
  _Client_auth = new WeakMap, _Client_logLevel = new WeakMap, _Client_logger = new WeakMap, _Client_prefixUrl = new WeakMap, _Client_timeoutMs = new WeakMap, _Client_notionVersion = new WeakMap, _Client_fetch = new WeakMap, _Client_agent = new WeakMap, _Client_userAgent = new WeakMap;
  Client.defaultNotionVersion = "2022-06-28";
});

// node_modules/@notionhq/client/build/src/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isMentionRichTextItemResponse = exports.isEquationRichTextItemResponse = exports.isTextRichTextItemResponse = exports.isFullComment = exports.isFullUser = exports.isFullPageOrDatabase = exports.isFullDatabase = exports.isFullPage = exports.isFullBlock = exports.collectPaginatedAPI = exports.iteratePaginatedAPI = undefined;
  async function* iteratePaginatedAPI(listFn, firstPageArgs) {
    let nextCursor = firstPageArgs.start_cursor;
    do {
      const response = await listFn({
        ...firstPageArgs,
        start_cursor: nextCursor
      });
      yield* response.results;
      nextCursor = response.next_cursor;
    } while (nextCursor);
  }
  exports.iteratePaginatedAPI = iteratePaginatedAPI;
  async function collectPaginatedAPI(listFn, firstPageArgs) {
    const results = [];
    for await (const item of iteratePaginatedAPI(listFn, firstPageArgs)) {
      results.push(item);
    }
    return results;
  }
  exports.collectPaginatedAPI = collectPaginatedAPI;
  function isFullBlock(response) {
    return response.object === "block" && "type" in response;
  }
  exports.isFullBlock = isFullBlock;
  function isFullPage(response) {
    return response.object === "page" && "url" in response;
  }
  exports.isFullPage = isFullPage;
  function isFullDatabase(response) {
    return response.object === "database" && "title" in response;
  }
  exports.isFullDatabase = isFullDatabase;
  function isFullPageOrDatabase(response) {
    if (response.object === "database") {
      return isFullDatabase(response);
    } else {
      return isFullPage(response);
    }
  }
  exports.isFullPageOrDatabase = isFullPageOrDatabase;
  function isFullUser(response) {
    return "type" in response;
  }
  exports.isFullUser = isFullUser;
  function isFullComment(response) {
    return "created_by" in response;
  }
  exports.isFullComment = isFullComment;
  function isTextRichTextItemResponse(richText) {
    return richText.type === "text";
  }
  exports.isTextRichTextItemResponse = isTextRichTextItemResponse;
  function isEquationRichTextItemResponse(richText) {
    return richText.type === "equation";
  }
  exports.isEquationRichTextItemResponse = isEquationRichTextItemResponse;
  function isMentionRichTextItemResponse(richText) {
    return richText.type === "mention";
  }
  exports.isMentionRichTextItemResponse = isMentionRichTextItemResponse;
});

// node_modules/@notionhq/client/build/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFullPageOrDatabase = exports.isFullComment = exports.isFullUser = exports.isFullPage = exports.isFullDatabase = exports.isFullBlock = exports.iteratePaginatedAPI = exports.collectPaginatedAPI = exports.isNotionClientError = exports.RequestTimeoutError = exports.UnknownHTTPResponseError = exports.APIResponseError = exports.ClientErrorCode = exports.APIErrorCode = exports.LogLevel = exports.Client = undefined;
  var Client_1 = require_Client();
  Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
    return Client_1.default;
  } });
  var logging_1 = require_logging();
  Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function() {
    return logging_1.LogLevel;
  } });
  var errors_1 = require_errors2();
  Object.defineProperty(exports, "APIErrorCode", { enumerable: true, get: function() {
    return errors_1.APIErrorCode;
  } });
  Object.defineProperty(exports, "ClientErrorCode", { enumerable: true, get: function() {
    return errors_1.ClientErrorCode;
  } });
  Object.defineProperty(exports, "APIResponseError", { enumerable: true, get: function() {
    return errors_1.APIResponseError;
  } });
  Object.defineProperty(exports, "UnknownHTTPResponseError", { enumerable: true, get: function() {
    return errors_1.UnknownHTTPResponseError;
  } });
  Object.defineProperty(exports, "RequestTimeoutError", { enumerable: true, get: function() {
    return errors_1.RequestTimeoutError;
  } });
  Object.defineProperty(exports, "isNotionClientError", { enumerable: true, get: function() {
    return errors_1.isNotionClientError;
  } });
  var helpers_1 = require_helpers();
  Object.defineProperty(exports, "collectPaginatedAPI", { enumerable: true, get: function() {
    return helpers_1.collectPaginatedAPI;
  } });
  Object.defineProperty(exports, "iteratePaginatedAPI", { enumerable: true, get: function() {
    return helpers_1.iteratePaginatedAPI;
  } });
  Object.defineProperty(exports, "isFullBlock", { enumerable: true, get: function() {
    return helpers_1.isFullBlock;
  } });
  Object.defineProperty(exports, "isFullDatabase", { enumerable: true, get: function() {
    return helpers_1.isFullDatabase;
  } });
  Object.defineProperty(exports, "isFullPage", { enumerable: true, get: function() {
    return helpers_1.isFullPage;
  } });
  Object.defineProperty(exports, "isFullUser", { enumerable: true, get: function() {
    return helpers_1.isFullUser;
  } });
  Object.defineProperty(exports, "isFullComment", { enumerable: true, get: function() {
    return helpers_1.isFullComment;
  } });
  Object.defineProperty(exports, "isFullPageOrDatabase", { enumerable: true, get: function() {
    return helpers_1.isFullPageOrDatabase;
  } });
});

// node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self) {
          return body(self, ...args);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(undefined);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0;i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/effect/dist/esm/internal/doNotation.js
var bindTo = (map) => dual(2, (self, name) => map(self, (a) => ({
  [name]: a
})));
var bind = (map, flatMap) => dual(3, (self, name, f) => flatMap(self, (a) => map(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === undefined;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && (property in self));
var isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
var isNullable = (input) => input === null || input === undefined;
var isNotNullable = (input) => input !== null && input !== undefined;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/effect/dist/esm/Utils.js
class SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;

class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

class YieldWrap {
  #value;
  constructor(value) {
    this.#value = value;
  }
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {}
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {}.constructor;

// node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0;i < keys.length; i++) {
    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0;i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
var withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args) => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args.length;i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.17.7";
var getCurrentVersion = () => moduleVersion;

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};
var channelVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!((key in that) && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base2() {}
  Base2.prototype = CommitPrototype;
  return Base2;
}();

// node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};
var fromOption = /* @__PURE__ */ dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var number3 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var boolean = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);

// node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var getOrElse = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
var empty = () => constEmpty;

// node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max2 = Math.max(1, Math.floor(n));
  const out = new Array(max2);
  for (let i = 0;i < max2; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var match3 = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self, head) => [head, ...self]);
var prependAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));
var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tailNonEmpty = (self) => self.slice(1);
var initNonEmpty = (self) => self.slice(0, -1);
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
var findFirstIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self, f) => {
  const input = fromIterable(self);
  for (let i = input.length - 1;i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var reverse = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => {
  const as = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1;i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var copy = (self) => self.slice();
var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
var empty2 = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0;i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0;j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    const o = f(as[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var filter2 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var some3 = /* @__PURE__ */ dual(2, (self, predicate) => self.some(predicate));
var unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make5(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {}
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId3]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
var serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split(`
`);
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split(`
`);
    lines.splice(1, 3);
    error.stack = lines.join(`
`);
  }
  return error;
};
var isContext = (u) => hasProperty(u, TypeId3);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
var empty3 = () => _empty;
var make5 = (tag, service) => makeContext(new Map([[tag.key, service]]));
var add = /* @__PURE__ */ dual(3, (self, tag, service) => {
  const map4 = new Map(self.unsafeMap);
  map4.set(tag.key, service);
  return makeContext(map4);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag)
      return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOption = /* @__PURE__ */ dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self, that) => {
  const map4 = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map4.set(tag, s);
  }
  return makeContext(map4);
});

// node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty4 = empty3;
var make6 = make5;
var add2 = add;
var get3 = get2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/effect/dist/esm/Chunk.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId4);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make7 = (...as) => unsafeFromNonEmptyArray(as);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array4, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array4, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array4, initial);
      copyToArray(self.right, array4, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array4[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array4[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty5() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
var take = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take(self.right, n - self.left.length)
          });
        }
        return take(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filter3 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter2(self, predicate)));
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead2 = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead2;
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
var splitAt2 = /* @__PURE__ */ dual(2, (self, n) => [take(self, n), drop2(self, n)]);
var tailNonEmpty2 = (self) => drop2(self, 1);
var takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
var reduce2 = reduce;

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/effect/dist/esm/internal/stack.js
var make8 = (value, previous) => ({
  value,
  previous
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0;i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// node_modules/effect/dist/esm/internal/hashMap/node.js
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode;
    ++size.value;
    return new LeafNode(edit, hash2, key, v);
  }
}
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size) {
    const len = list.length;
    for (let i = 0;i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists2 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists2) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length;i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0;bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make8(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size) => {
  const map5 = Object.create(HashMapProto);
  map5._editable = editable;
  map5._edit = edit;
  map5._root = root;
  map5._size = size;
  return map5;
};

class HashMapIterator {
  map;
  f;
  v;
  constructor(map5, f) {
    this.map = map5;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
var empty6 = () => _empty3;
var make9 = (...entries) => fromIterable3(entries);
var fromIterable3 = (entries) => {
  const map5 = beginMutation(empty6());
  for (const entry of entries) {
    set(map5, entry[0], entry[1]);
  }
  return endMutation(map5);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
  let node = self._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length;i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  self._editable = false;
  return self;
};
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
  const size2 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size2);
  return pipe(self, setTree(newRoot, size2.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
var map5 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty6(), (map6, value, key) => set(map6, key, f(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, undefined, (_, value, key) => f(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self, zero, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero, root.value.value, root.key) : zero;
  }
  if (root._tag === "EmptyNode") {
    return zero;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length;i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero = f(zero, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero;
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
var empty7 = () => _empty4;
var fromIterable4 = (elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var make10 = (...elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var has2 = /* @__PURE__ */ dual(2, (self, value) => has(self._keyMap, value));
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  self._keyMap._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (remove2(value)(self._keyMap), self) : makeImpl2(remove2(value)(self._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self, that) => mutate(self, (set2) => {
  for (const value of that) {
    remove3(set2, value);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate(empty7(), (set2) => {
  forEach2(self, (value) => add3(set2, value));
  for (const value of that) {
    add3(set2, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self, zero, f) => reduce3(self._keyMap, zero, (z, _, a) => f(z, a)));

// node_modules/effect/dist/esm/HashSet.js
var empty8 = empty7;
var fromIterable5 = fromIterable4;
var make11 = make10;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var forEach3 = forEach2;
var reduce5 = reduce4;

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty9 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isEmpty3 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse2(reduce6(self, empty5(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
var defects = (self) => reverse2(reduce6(self, empty5(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
var interruptors = (self) => reduce6(self, empty8(), (set2, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set2, add4(cause.fiberId))) : none2());
var failureOption = (self) => find(self, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
var failureOrCause = (self) => {
  const option = failureOption(self);
  switch (option._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option.value);
    }
  }
};
var flipCauseOption = (self) => match4(self, {
  onEmpty: some2(empty9),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId) => some2(interrupt(fiberId)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
var keepDefectsAndElectFailures = (self) => match4(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: () => empty9,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map8 = /* @__PURE__ */ dual(2, (self, f) => flatMap5(self, (e) => fail(f(e))));
var flatMap5 = /* @__PURE__ */ dual(2, (self, f) => match4(self, {
  onEmpty: empty9,
  onFail: (error) => f(error),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId) => interrupt(fiberId),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par)), pipe(sequential2, appendAll2(seq))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty5());
};
var flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty8(), empty5()], ([parallel3, sequential3], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [pipe(parallel3, union3(par)), pipe(sequential3, appendAll2(seq))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option;
      }
    }
  }
  return none2();
});
var evaluateCause = (self) => {
  let cause = self;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self, zero, pf) => {
  let accumulator = zero;
  let cause = self;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome2(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = undefined;
        break;
      }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left": {
        switch (either.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join(`
`);
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split(`
`);
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length;i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};

class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {}
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
var prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
  for (let i = 1;i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match5 = false;
          for (const [, location] of locationMatchAll) {
            match5 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match5) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join(`
`);
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/effect/dist/esm/Duration.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1000);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match5 = DURATION_REGEX.exec(input);
    if (match5) {
      const [_, valueStr, unit] = match5;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
var isDuration = (u) => hasProperty(u, TypeId5);
var isZero = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make12(0);
var infinity = /* @__PURE__ */ make12(Infinity);
var nanos = (nanos2) => make12(nanos2);
var micros = (micros2) => make12(micros2 * bigint1e3);
var millis = (millis2) => make12(millis2);
var seconds = (seconds2) => make12(seconds2 * 1000);
var minutes = (minutes2) => make12(minutes2 * 60000);
var hours = (hours2) => make12(hours2 * 3600000);
var days = (days2) => make12(days2 * 86400000);
var weeks = (weeks2) => make12(weeks2 * 604800000);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
};
var match5 = /* @__PURE__ */ dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make12(self2 + that2),
  onNanos: (self2, that2) => make12(self2 + that2)
}));
var lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
var parts = (self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min2 = sec / bigint60;
  const hr = min2 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min2 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self) => self.current;
var set2 = /* @__PURE__ */ dual(2, (self, value) => {
  self.current = value;
  return self;
});

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var none3 = /* @__PURE__ */ new None;
var runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll2 = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make11(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union3(ids(self.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id, startTimeSeconds) => {
  return new Runtime(id, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id + 1));
  return new Runtime(id, Date.now());
};

// node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var combine3 = combine2;
var combineAll3 = combineAll2;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var unsafeMake2 = unsafeMake;

// node_modules/effect/dist/esm/HashMap.js
var empty10 = empty6;
var make16 = make9;
var fromIterable6 = fromIterable3;
var isEmpty4 = isEmpty2;
var get7 = get5;
var has4 = has;
var set3 = set;
var keys2 = keys;
var size4 = size;
var modifyAt2 = modifyAt;
var map9 = map5;
var reduce7 = reduce3;

// node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self) => fromIterable(self);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    let self = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self.head;
        self = self.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head3, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail;
  return cons;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId7);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var nil = () => _Nil;
var cons = (head3, tail) => makeCons(head3, tail);
var empty11 = nil;
var of3 = (value) => makeCons(value, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll2(that, self));
var prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
var prependAll2 = /* @__PURE__ */ dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  let acc = zero2;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self) => {
  let result = empty11();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

// node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
function variance2(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance3(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance3,
    _Patch: variance3
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty12 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty12();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
};
var combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
var patch = /* @__PURE__ */ dual(2, (self, context) => {
  if (self._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head3.key, head3.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head3.second), head3.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head3.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map10 = new Map;
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map10.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map10.set(tag, s);
  }
  return makeContext(map10);
});

// node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
function variance4(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance5(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty13 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen2 = (first, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce5([oldValue, empty13()], ([set4, patch3], value) => {
    if (has3(value)(set4)) {
      return [remove4(value)(set4), patch3];
    }
    return [set4, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set4 = oldValue;
  let patches = of2(self);
  while (isNonEmpty(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head3.first)(prepend2(head3.second)(tail));
        break;
      }
      case "Add": {
        set4 = add4(head3.value)(set4);
        patches = tail;
        break;
      }
      case "Remove": {
        set4 = remove4(head3.value)(set4);
        patches = tail;
      }
    }
  }
  return set4;
});

// node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
function variance6(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance6,
    _Key: variance6,
    _Patch: variance6
  }
};

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance7(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance7,
    _Patch: variance7
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty14 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen3 = (first, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o = Object.create(AppendProto);
  o.values = values3;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate = (index, patch3) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch3;
  return o;
};
var diff3 = (options) => {
  let i = 0;
  let patch3 = empty14();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
  }
  return patch3;
};
var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head3.first, head3.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head3.values) {
          readonlyArray.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray = readonlyArray.slice(head3.from, head3.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make17 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
var environment = () => make17({
  empty: empty12(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch7, oldValue) => patch(oldValue)(patch7)
});
var hashSet = () => make17({
  empty: empty13(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch7, oldValue) => patch2(oldValue)(patch7)
});
var readonlyArray = (differ) => make17({
  empty: empty14(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch7, oldValue) => patch3(patch7, oldValue, differ)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make17({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch7, oldValue) => f(oldValue, patch7(oldValue))
});

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch7) => patch7 & BIT_MASK;
var enabled = (patch7) => patch7 >> BIT_SHIFT & BIT_MASK;
var make18 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty18 = /* @__PURE__ */ make18(0, 0);
var enable = (flag) => make18(flag, flag);
var disable = (flag) => make18(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self, flag) => make18(active(self) & ~flag, enabled(self)));
var andThen = /* @__PURE__ */ dual(2, (self, that) => self | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self) => isEnabled(self, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled(self, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
var make19 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make19(None2);
var runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics);
var windDown = (self) => isEnabled(self, WindDown);
var diff7 = /* @__PURE__ */ dual(2, (self, that) => make18(self ^ that, that));
var patch7 = /* @__PURE__ */ dual(2, (self, patch8) => self & (invert(active(patch8)) | enabled(patch8)) | active(patch8) & enabled(patch8));
var differ = /* @__PURE__ */ make17({
  empty: empty18,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var flatten2 = (self) => {
  let current = of3(self);
  let updated = empty11();
  while (true) {
    const [parallel2, sequential2] = reduce8(current, [parallelCollectionEmpty(), empty11()], ([parallel3, sequential3], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel3, par2), appendAll3(sequential3, seq2)];
    });
    updated = merge4(updated, parallel2);
    if (isNil(sequential2)) {
      return reverse3(updated);
    }
    current = sequential2;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel2 = parallelCollectionEmpty();
  let stack = empty11();
  let sequential2 = empty11();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel2, sequential2];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential2 = cons(right3, sequential2);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel2 = parallelCollectionAdd(parallel2, current);
        if (isNil(stack)) {
          return [parallel2, sequential2];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential2, parallel2) => {
  if (isNil(sequential2)) {
    return of3(parallelCollectionToSequentialCollection(parallel2));
  }
  if (parallelCollectionIsEmpty(parallel2)) {
    return sequential2;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential2.head);
  const parKeys = parallelCollectionKeys(parallel2);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential2.head, parallelCollectionToSequentialCollection(parallel2)), sequential2.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel2), sequential2);
};
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  _R: (_) => _
};

class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map10) {
    this.map = map10;
  }
}
var parallelCollectionEmpty = () => new ParallelImpl(empty10());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce7(self.map, that.map, (map10, value, key) => set3(map10, key, match2(get7(map10, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty4(self.map);
var parallelCollectionKeys = (self) => Array.from(keys2(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map9(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  _R: (_) => _
};

class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map10) {
    this.map = map10;
  }
}
var sequentialCollectionMake = (map10) => new SequentialImpl(map10);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce7(that.map, self.map, (map10, value, key) => set3(map10, key, match2(get7(map10, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys2(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

// node_modules/effect/dist/esm/internal/singleShotGen.js
class SingleShotGen2 {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
}

// node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
var runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch8, op) {
    this.patch = patch8;
    this.op = op;
  }
}

class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit) => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: (cause) => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self, value) => flatMap7(self, () => succeed(value)));
var asVoid = (self) => as(self, undefined);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume, blockingOn = none4) => {
  return custom(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return predicate(either2.left) ? f(either2.left) : failCause(cause);
    case "Right":
      return failCause(either2.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either2.right);
  }
}));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failSync = (evaluate) => flatMap7(sync(evaluate), fail2);
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var failCauseSync = (evaluate) => flatMap7(sync(evaluate), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
};
var flatten3 = (self) => flatMap7(self, identity);
var matchCause = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause) => succeed(options.onFailure(cause)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures2 = failures(cause);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self)), (exit2) => deferredDone(deferred, exit2))));
var map10 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => sync(() => f(a))));
var mapBoth = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause) => {
    const either3 = failureOrCause(cause);
    switch (either3._tag) {
      case "Left": {
        return failSync(() => f(either3.left));
      }
      case "Right": {
        return failCause(either3.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
var sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var void_ = /* @__PURE__ */ succeed(undefined);
var updateRuntimeFlags = (patch8) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch8;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => {
  if (b) {
    return pipe(self, map10(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
var fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update2;
  effect.effect_instruction_i1 = () => self;
  return effect;
});
var yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
var zip2 = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => map10(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap7(self, (a) => map10(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {}, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap7(fiberId, (fiberId2) => pipe(self, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId2) => flatMap7(self.interruptAsFork(fiberId2), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap7(fiberRefGet(self), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, () => [undefined, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch8) => (oldValue) => options.differ.patch(patch8, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty9, {
  fork: () => empty9,
  join: (parent, _) => parent
}));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));
var scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
var scopeClose = (self, exit2) => self.close(exit2);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
  const option = pipe(self, failureOption, map2(f));
  switch (option._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id) => `#${id}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {

  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto2, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto2);
  Base2.prototype.name = tag;
  return Base2;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {

  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self, value) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, undefined);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error) => exitFailCause(fail(error));
var exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map8(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
var exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap7(fiberId, (id) => deferredMakeAs(id));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self) => asyncInterrupt((resume) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self, resume);
    }
  }
}, self.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self, effect) => intoDeferred(effect, self));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self, exit2) => deferredCompleteWith(self, exit2));
var deferredFail = /* @__PURE__ */ dual(2, (self, error) => deferredCompleteWith(self, fail2(error)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));
var deferredInterrupt = (self) => flatMap7(fiberId, (fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE);
var deferredSucceed = /* @__PURE__ */ dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));
var deferredUnsafeDone = (self, effect) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect));
    for (let i = 0, len = state.joiners.length;i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap7(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocally(currentContext, context2)(self));
var provideSomeContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self));
var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context2) => provideContext(self, f(context2))));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
};

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis2 = toMillis(duration);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === undefined) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();

class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
      return asVoid(sync(canceler));
    });
  }
}
var make20 = () => new ClockImpl;

// node_modules/effect/dist/esm/Number.js
var Order = number3;
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};
var round = /* @__PURE__ */ dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// node_modules/effect/dist/esm/RegExp.js
var escape = (string3) => string3.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var Or = (self, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self, context2, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error = input.pop();
    switch (error._op) {
      case OP_AND: {
        input.push(error.right);
        input.push(error.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error.right);
        input.push(error.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context2, error.path, error.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context2, error.path, error.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context2, error.path, error.message, error.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context2, error.path, error.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either3 = output.pop();
    switch (either3._op) {
      case "Left": {
        switch (either3.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.andCase(context2, left3, right3);
            accumulator.push(value);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.orCase(context2, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either3.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, undefined, IsMissingDataOnlyReducer);

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty20 = {
  _tag: "Empty"
};
var patch8 = /* @__PURE__ */ dual(2, (path, patch9) => {
  let input = of3(patch9);
  let output = path;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make21({
  load: (config) => flatMap7(fromFlatLoop(flat, empty2(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap7((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys3 = Object.keys(current);
    const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0;i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty20
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split), flatMap7((values3) => {
        if (values3.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices) => {
        if (indices.length === 0) {
          return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys3) => {
        return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map10((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap7((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap7((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail3 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail3, fail3, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var splitPathString = (text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
};
var parsePrimitive = (text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
};
var transpose = (array4) => {
  return Object.keys(array4[0]).map((column) => array4.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map10(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match6 = str.match(QUOTED_INDEX_REGEX);
  if (match6 !== null) {
    const matchedIndex = match6[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId8]: TypeId8,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map10(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min2, max2) {
    return map10(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => this.PRNG.integer(max2 - min2) + min2);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer) => {
    const numbers = [];
    for (let i = buffer.length;i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
  })));
};
var swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
var make22 = (seed) => new RandomImpl(hash(seed));

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length) {
    let result = "";
    for (let i = 0;i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();

class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context2, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var nativeTracer = /* @__PURE__ */ make23({
  span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
  context: (f) => f()
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));

// node_modules/effect/dist/esm/Boolean.js
var not = (self) => !self;

// node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make24 = deferredMake;
var _await = deferredAwait;
var complete = deferredComplete;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var succeed2 = deferredSucceed;
var unsafeDone = deferredUnsafeDone;

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
class Class extends Base2 {
}

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake3(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty21() {
  return unsafeMake3(new Map);
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self, fiberId2, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
  const map11 = new Map;
  unsafeForkAs(self, map11, childId);
  return new FiberRefsImpl(map11);
});
var unsafeForkAs = (self, map11, fiberId2) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map11.set(fiberRef, stack);
    } else {
      map11.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get8(self, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self, {
  fiberId: fiberId2,
  fiberRef,
  value
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self.locals);
  if (forkAs2 !== undefined) {
    unsafeForkAs(self, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var getOrDefault2 = getOrDefault;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty22 = empty21;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty23 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty23;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine10 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch9 = /* @__PURE__ */ dual(3, (self, fiberId2, oldValue) => {
  let fiberRefs2 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs2, head3.fiberRef);
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.fiberRef.patch(head3.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head3.first)(prepend(head3.second)(tail));
        break;
      }
    }
  }
  return fiberRefs2;
});

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9 = diff8;
var patch10 = patch9;

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}

class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags) {
    this.runtimeFlags = runtimeFlags;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}

class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags, blockingOn) {
    this.runtimeFlags = runtimeFlags;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
var done2 = /* @__PURE__ */ new Done;
var running = (runtimeFlags) => new Running(runtimeFlags);
var suspended = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;

// node_modules/effect/dist/esm/FiberStatus.js
var done3 = done2;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;

// node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/effect/dist/esm/Micro.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};

class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split(`
`).length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join(`
    `)}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
var causeDie = (defect, traces = []) => new Die(defect, traces);

class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};

class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context2, interruptible3 = true) {
    this.context = context2;
    this.interruptible = interruptible3;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit2 = this.runLoop(effect);
    if (exit2 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap8(interruptChildren, () => exit2));
    }
    this._exit = exit2;
    for (let i = 0;i < this._observers.length; i++) {
      this._observers[i](exit2);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol3]: cont
        };
      if (op[symbol3])
        return op;
    }
  }
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set;
  }
}
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId9]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : undefined
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options) => {
  const Proto = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self = Object.create(Proto);
    self[args] = value;
    self[successCont] = undefined;
    self[failureCont] = undefined;
    self[ensureCont] = undefined;
    return self;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(undefined);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap8 = /* @__PURE__ */ dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length;i < len; i++) {
      tasks[i]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
}
class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault
})) {
}
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause) => flatMap8(f(exitFailCause2(cause)), () => failCause3(cause)),
  onSuccess: (a) => flatMap8(f(exitSucceed2(a)), () => succeed3(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// node_modules/effect/dist/esm/Readable.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId10]: TypeId10,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  _A: (_) => _
};

class RefImpl extends Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
}
var unsafeMake4 = (value) => new RefImpl(make13(value));
var make25 = (value) => sync(() => unsafeMake4(value));
var get9 = (self) => self.get;
var set4 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [undefined, value]));
var modify3 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [undefined, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));

// node_modules/effect/dist/esm/Ref.js
var make26 = make25;
var get10 = get9;
var modify4 = modify3;
var set5 = set4;
var update3 = update2;
var updateAndGet2 = updateAndGet;

// node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (;index < length; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0;i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

// node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential4, unbounded, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded() : concurrency2 > 1 ? bounded(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;

// node_modules/effect/dist/esm/internal/logSpan.js
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
};

// node_modules/effect/dist/esm/Tracer.js
var ParentSpan = spanTag;

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make28 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var asSome = (self) => map10(self, some2);
var try_ = (arg) => {
  let evaluate2;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate2));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
};
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
      if (!tag)
        return false;
      for (let i = 0;i < args2.length - 1; i++) {
        if (args2[i] === tag)
          return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
  let keys3;
  return catchIf(self, (e) => {
    keys3 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff8);
var bind2 = /* @__PURE__ */ bind(map10, flatMap7);
var bindTo2 = /* @__PURE__ */ bindTo(map10);
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse3) => flatMap7(self, (a) => predicate(a) ? succeed(a) : orElse3(a)));
var match8 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause = undefined;
  for (let i = 0, len = message.length;i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause !== undefined) {
        cause = sequential(cause, msg);
      } else {
        cause = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause === undefined) {
    cause = empty9;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause, levelOption);
    return void_;
  });
};
var logError = /* @__PURE__ */ logWithLevel(Error2);
var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var negate = (self) => map10(self, (b) => !b);
var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate2) => orElse2(self, () => failSync(evaluate2)));
var patchFiberRefs = (patch11) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch11, patch9(fiberId2, fiberRefs3)));
var provideService = /* @__PURE__ */ dual(3, (self, tag, service) => contextWithEffect((env) => provideContext(self, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag, effect) => contextWithEffect((env) => flatMap7(effect, (service) => provideContext(self, pipe(env, add2(tag, service))))));
var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap7(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var summarized = /* @__PURE__ */ dual(3, (self, summary, f) => flatMap7(summary, (start) => flatMap7(self, (value) => map10(summary, (end) => [f(start, end), value]))));
var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause) => zipRight(f(cause), failCause(cause)),
  onSuccess: succeed
}));
var tryPromise = (arg) => {
  let evaluate2;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    catcher = arg.catch;
  }
  const fail4 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate2.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate2(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
      } catch (e) {
        resolve(fail4(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate2().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
    } catch (e) {
      resolve(fail4(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self, options) => flatMap7(self, (a) => try_({
  try: () => options.try(a),
  catch: options.catch
})));
var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => b ? succeedNone : asSome(self)));
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map10(self, some2) : succeed(none2())));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap7(getService, (s) => s[prop](...args2));
  }
});
var serviceOption = (tag) => map10(context(), getOption2(tag));

// node_modules/effect/dist/esm/Exit.js
var isFailure = exitIsFailure;
var isSuccess = exitIsSuccess;
var all2 = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause4 = exitFailCause;
var interrupt4 = exitInterrupt;
var map11 = exitMap;
var mapBoth2 = exitMapBoth;
var match9 = exitMatch;
var succeed4 = exitSucceed;
var void_3 = exitVoid;
var zip3 = exitZip;
var zipRight2 = exitZipRight;

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect) => ({
  _tag: OP_RESUME,
  effect
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set;
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}

class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
var unsafeMake5 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  _E: (_) => _,
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var _await2 = (self) => self.await;
var inheritAll = (self) => self.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, (fibers, fiberId2) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId2)), zipRight(pipe(fibers, forEachSequentialDiscard(_await2)))));
var interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId2) => self.interruptAsFork(fiberId2));
var join2 = (self) => zipLeft(flatten3(self.await), self.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var currentFiberURI = "effect/FiberCurrent";

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  _Message: (_) => _,
  _Output: (_) => _
};
var makeLogger = (log) => ({
  [LoggerTypeId]: loggerVariance,
  log,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none6 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations,
  cause,
  date,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format4 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append3 = (label, value) => " " + format4(label, value);
  let out = format4("timestamp", date.toISOString());
  out += append3("level", logLevel.label);
  out += append3("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0;i < messages.length; i++) {
    out += append3("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause)) {
    out += append3("cause", pretty(cause, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out += " " + render(date.getTime())(span2);
  }
  for (const [label, value] of annotations) {
    out += append3(label, toStringUnknown(value, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var withColor = (text, ...colors) => {
  let out = "";
  for (let i = 0;i < colors.length; i++) {
    out += `\x1B[${colors[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date) => `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}.${date.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode_ = options?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options?.colors === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
  const formatDate = options?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate,
    stderr: options?.stderr === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations,
    cause,
    context: context2,
    date,
    fiberId: fiberId2,
    logLevel,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context2, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const log = options.stderr === true ? console2.error : console2.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}` + ` (${threadName(fiberId2)})`;
    if (isCons(spans)) {
      const now = date.getTime();
      const render2 = render(now);
      for (const span2 of spans) {
        firstLine += " " + render2(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log(firstLine);
    if (!processIsBun)
      console2.group();
    if (!isEmpty3(cause)) {
      log(pretty(cause, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (;messageIndex < message.length; messageIndex++) {
        log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        log(color(`${key}:`, colors.bold, colors.white), redact(value));
      }
    }
    if (!processIsBun)
      console2.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations,
    cause,
    context: context2,
    date,
    fiberId: fiberId2,
    logLevel,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context2, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel.label}${color} (${threadName(fiberId2)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel._tag], "");
    }
    if (isCons(spans)) {
      const now = date.getTime();
      const render2 = render(now);
      for (const span2 of spans) {
        firstLine += " " + render2(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console2.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty3(cause)) {
      console2.error(pretty(cause, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (;messageIndex < message.length; messageIndex++) {
        console2.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        const redacted = redact(value);
        if (options.colors) {
          console2.log(`%c${key}:`, "color:gray", redacted);
        } else {
          console2.log(`${key}:`, redacted);
        }
      }
    }
    console2.groupEnd();
  });
};
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  _In: (_) => _,
  _Out: (_) => _
};

class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);

class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}

class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var empty24 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = new Map;
  self.buckets = new Map;
  self.bucketsSize = 0;
  return self;
};
var get12 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === undefined) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove6 = false) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove6) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has5 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get12(self, key)));
var set6 = /* @__PURE__ */ dual(3, (self, key, value) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === undefined) {
    self.buckets.set(hash2, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  _A: (_) => _
};

class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);

class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min2, max2, sum2) {
    this.buckets = buckets;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min2, max2, sum2) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter3 = (count) => new CounterState(count);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count) => new GaugeState(count);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  _In: (_) => _,
  _Out: (_) => _
};
var make30 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint02 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum2 = key.keyType.bigint ? bigint02 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint02 : (value) => value >= 0 : (_value) => true;
  const update4 = (value) => {
    if (canUpdate(value)) {
      sum2 = sum2 + value;
    }
  };
  return make30({
    get: () => counter3(sum2),
    update: update4,
    modify: update4
  });
};
var frequency3 = (key) => {
  const values3 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update4 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update4,
    modify: update4
  });
};
var gauge3 = (_key, startAt) => {
  let value = startAt;
  return make30({
    get: () => gauge2(value),
    update: (v) => {
      value = v;
    },
    modify: (v) => {
      value = value + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size5 = bounds.length;
  const values3 = new Uint32Array(size5 + 1);
  const boundaries = new Float32Array(size5);
  let count = 0;
  let sum2 = 0;
  let min2 = Number.MAX_VALUE;
  let max2 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update4 = (value) => {
    let from = 0;
    let to = size5;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count = count + 1;
    sum2 = sum2 + value;
    if (value < min2) {
      min2 = value;
    }
    if (value > max2) {
      max2 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size5);
    let cumulated = 0;
    for (let i = 0;i < size5; i++) {
      const boundary = boundaries[i];
      const value = values3[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: update4,
    modify: update4
  });
};
var summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head3 = 0;
  let count = 0;
  let sum2 = 0;
  let min2 = 0;
  let max2 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head3 = head3 + 1;
      const target = head3 % maxSize;
      values3[target] = [timestamp, value];
    }
    min2 = count === 0 ? value : Math.min(min2, value);
    max2 = count === 0 ? value : Math.max(max2, value);
    count = count + 1;
    sum2 = sum2 + value;
  };
  return make30({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head3 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head3, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  _Type: (_) => _
};
var unsafeMake6 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty24();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake6(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const counter5 = counter4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, counter5));
      }
      value = counter5;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const frequency4 = frequency3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, frequency4));
      }
      value = frequency4;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, gauge4));
      }
      value = gauge4;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const histogram5 = histogram4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, histogram5));
      }
      value = histogram5;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const summary4 = summary3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, summary4));
      }
      value = summary4;
    }
    return value;
  }
}
var make31 = () => {
  return new MetricRegistryImpl;
};

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  _Type: (_) => _,
  _In: (_) => _,
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self, key, value) => taggedWithLabels2(self, [make28(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
  return make32(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self.unsafeUpdate(input, tags))));

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var complete2 = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map12) => sync(() => {
  if (map12.has(self)) {
    const entry = map12.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};

class RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2;s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
}

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  _Key: (_) => _,
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash2 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries2[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var keysForward = (self) => keys3(self, Direction.Forward);
var keys3 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys3(self, direction),
    next: () => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};

// node_modules/effect/dist/esm/RedBlackTree.js
var keys4 = keysForward;

// node_modules/effect/dist/esm/SortedSet.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId12]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId12)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys4(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSortedSet = (u) => hasProperty(u, TypeId12);

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  _T: (_) => _
};

class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context2, effect, parent, fiber) {
    this.underlying.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}

class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context2, effect, parent, fiber) {
    this.left.onStart(context2, effect, parent, fiber);
    this.right.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {}
  onEnd(_value, _fiber) {}
  onEffect(_fiber, _effect) {}
  onSuspend(_fiber) {}
  onResume(_fiber) {}
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
var fromEffect = (effect) => {
  return new Const(effect);
};
var none7 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/effect/dist/esm/Differ.js
var make34 = make17;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty27 = {
  _tag: OP_EMPTY3
};
var combine11 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch11 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head3 = headNonEmpty2(patches);
    switch (head3._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head3.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head3.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head3.first)(prepend2(head3.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none7;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet2 = (self) => {
  if (equals(self, none7)) {
    return empty8();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union3(toSet2(self.right)));
    } else {
      return make11(self);
    }
  }
};
var diff10 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty27;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty27, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty27, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine11(added, removed);
};
var differ2 = /* @__PURE__ */ make34({
  empty: empty27,
  patch: patch11,
  combine: combine11,
  diff: diff10
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self, cont, value) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done)
      return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten2(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map12 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map12.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map12);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();

class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array;
  _children = null;
  _observers = /* @__PURE__ */ new Array;
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  id() {
    return this._fiberId;
  }
  resume(effect) {
    this.tell(resume(effect));
  }
  get status() {
    return this.ask((_, status) => status);
  }
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone3(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  scope() {
    return unsafeMake5(this);
  }
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  getChildren() {
    if (this._children === null) {
      this._children = new Set;
    }
    return this._children;
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit2) => resume2(succeed(exit2));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(diff7(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
      return updateRuntimeFlags(patch12);
    });
  }
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  unsafePoll() {
    return this._exitValue;
  }
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  addChild(child) {
    this.getChildren().add(child);
  }
  removeChild(child) {
    this.getChildren().delete(child);
  }
  transferChildren(scope) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  addInterruptedCause(cause) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause));
  }
  processNewInterruptSignal(cause) {
    this.addInterruptedCause(cause);
    this.sendInterruptSignalToAllChildren();
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone4 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone4 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone4,
        body,
        step: () => {}
      });
    }
    return null;
  }
  reportExitValue(exit2) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit2._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit2._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit2.cause, level);
      }
    }
  }
  setExitValue(exit2) {
    this._exitValue = exit2;
    this.reportExitValue(exit2);
    for (let i = this._observers.length - 1;i >= 0; i--) {
      this._observers[i](exit2);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan2(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done3 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit2 = this.runLoop(eff);
        if (exit2 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect = flatMap7(interruption2, () => exit2);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit2);
            } else {
              this.tell(resume(exit2));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  startFork(effect) {
    this.tell(resume(effect));
  }
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException);
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit2) => {
        if (exit2._tag === "Success") {
          return resume2(exitSucceed(exit2.value));
        }
        switch (exit2.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit2.cause.error));
          }
          case "Die": {
            return resume2(die2(exit2.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause));
          } else {
            return exitFailCause(stripFailures(cause));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause));
          } else {
            return exitFailCause(stripFailures(cause));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty9, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause,
  context: context2,
  fiberId: fiberId2,
  logLevel,
  message
}) => {
  const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause !== null && cause._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make11(defaultLogger, tracerLogger)));
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
var addFinalizer = (finalizer) => withFiberRuntime((runtime3) => {
  const acquireRefs = runtime3.getFiberRefs();
  const acquireFlags = disable2(runtime3.currentRuntimeFlags, Interruption);
  return flatMap7(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var filter6 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith2(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map10(forEach7(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys5 = Object.keys(input);
  const size7 = keys5.length;
  return [keys5.map((k) => input[k]), some2((values3) => {
    const res = {};
    for (let i = 0;i < size7; i++) {
      res[keys5[i]] = values3[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none8 = none2();
    const size7 = eithers.length;
    const errors = new Array(size7);
    const successes = new Array(size7);
    let errored = false;
    for (let i = 0;i < size7; i++) {
      const either3 = eithers[i];
      if (either3._tag === "Left") {
        errors[i] = some2(either3.left);
        errored = true;
      } else {
        successes[i] = either3.right;
        errors[i] = none8;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map10(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all3 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach7(effects, identity, options), reconcile.value) : forEach7(effects, identity, options);
};
var replicate = /* @__PURE__ */ dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, n, options) => all3(replicate(self, n), options));
var forEach7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match7(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as2 = fromIterable(self);
  const array4 = new Array(as2.length);
  const fn = (a, i) => flatMap7(f(a, i), (b) => sync(() => array4[i] = b));
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array4));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap7(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0;i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten3(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index2, hitNext) => (exit2) => {
          exits[index2] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0;i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as2 = fromIterable(self);
  const array4 = new Array(as2.length);
  const fn = (a, i) => map10(f(a, i), (b) => array4[i] = b);
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array4));
});
var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var parallelFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap7(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch12(self(parallelFinalizers));
        case "Sequential":
          return patch12(self(sequentialFinalizers));
        case "ParallelN":
          return patch12(self(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f) => flatMap7(scopeTag, f);
var scopedWith = (f) => flatMap7(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
var scopedEffect = (effect) => flatMap7(scopeMake(), (scope) => scopeUse(effect, scope));
var sequentialFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => map10(all3([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit2) => newScope.close(exit2);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit2) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit2
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap7((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make6(scopeTag, scope2))));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty27
});
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none7);
var raceWith = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onSelfDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit2, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onOtherDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit2, loser);
      }
    }
  })
}));
var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
    onFailure: (cause) => pipe(join2(right3), mapErrorCause((cause2) => parallel(cause, cause2))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
    onFailure: (cause) => pipe(join2(left3), mapErrorCause((cause2) => parallel(cause2, cause))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer, a)
})));
var invokeWithInterrupt = (self, entries2, onInterrupt2) => fiberIdWith((id) => flatMap7(flatMap7(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries2.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries2.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count) => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id)));
})));

// node_modules/effect/dist/esm/Cause.js
var empty29 = empty9;
var fail5 = fail;
var die4 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map12 = map8;
var squash = causeSquash;
var reduceWithContext3 = reduceWithContext;
var NoSuchElementException2 = NoSuchElementException;
var pretty2 = pretty;

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty30 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make35 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty30;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
var min2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis)
    return self;
  if (that.endMillis <= self.startMillis)
    return that;
  if (self.startMillis < that.startMillis)
    return self;
  if (that.startMillis < self.startMillis)
    return that;
  if (self.endMillis <= that.endMillis)
    return self;
  return that;
});
var isEmpty6 = (self) => {
  return self.startMillis >= self.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self, that) => {
  const start = Math.max(self.startMillis, that.startMillis);
  const end = Math.min(self.endMillis, that.endMillis);
  return make35(start, end);
});
var size8 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var after = (startMilliseconds) => {
  return make35(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/effect/dist/esm/ScheduleInterval.js
var make36 = make35;
var empty31 = empty30;
var lessThan3 = lessThan2;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size9 = size8;
var after2 = after;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make37 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make37(reverse2(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty31)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty31)).endMillis;
};
var lessThan4 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
var isNonEmpty3 = (self) => {
  return isNonEmpty(self.intervals);
};

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make38 = make37;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty4 = isNonEmpty3;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make38(of2(interval))
  };
};
var done4 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done5 = done4;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/effect/dist/esm/Scope.js
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork = scopeFork;
var make39 = scopeMake;

// node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

class Latch extends Class {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0;i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self) => {
    return zipRight(this.await, self);
  };
}
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var forkIn = /* @__PURE__ */ dual(2, (self, scope2) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope2;
  const fiber = unsafeFork(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self) => scopeWith((scope2) => forkIn(self, scope2));
var timeout = /* @__PURE__ */ dual(2, (self, duration) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self, {
  duration,
  onTimeout
}) => flatten3(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutTo = /* @__PURE__ */ dual(2, (self, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration)), {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  _A: (_) => _
};

class SynchronizedImpl extends Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get9(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get9(this.ref), f), flatMap7(([b, a]) => as(set4(this.ref, a), b))));
  }
}
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake4(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interruptAs = interruptAsFiber;
var interruptAllAs2 = interruptAllAs;
var join3 = join2;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime3 = arguments[0];
    return (effect, ...args2) => f(runtime3, effect, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork2 = /* @__PURE__ */ makeDual((runtime3, self, options) => {
  const fiberId2 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime3.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime3.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime3.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = flatMap7(fork(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self, (exit2) => close(closeableScope, exit2))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none7) {
    supervisor.onStart(runtime3.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
  }
  globalScope.add(runtime3.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const result = unsafeRunSyncExit(runtime3)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});

class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause) {
    const head3 = prettyErrors(cause)[0];
    super(head3?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause;
    this.name = head3 ? `(FiberFailure) ${head3.name}` : "FiberFailure";
    if (head3?.stack) {
      this.stack = head3.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
var fiberFailure = (cause) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause);
  Error.stackTraceLimit = limit;
  return error;
};
var fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler;
  const fiberRuntime = unsafeFork2(runtime3)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime3, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime3)(effect);
  fiber.addObserver((exit2) => {
    resolve(exit2);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));

class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make40 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make19(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty22()
});
var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));
var updateEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect((value) => map10(f(value), (result) => [undefined, result])));

// node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  _RIn: (_) => _,
  _E: (_) => _,
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};

class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  getOrElseMemoize(layer, scope2) {
    return pipe(modifyEffect(this.ref, (map14) => {
      const inMap = map14.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached2 = pipe(acquire, flatMap7(([patch12, b]) => pipe(patchFiberRefs(patch12), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope2, release)
        })));
        return succeed([cached2, map14]);
      }
      return pipe(make25(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make25(() => void_), map10((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit2) => {
          switch (exit2._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map14.delete(layer)), zipRight(get9(finalizerRef)), flatMap7((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit2) => pipe(get9(finalizerRef), flatMap7((finalizer) => finalizer(exit2)))];
        return [resource, isFresh(layer) ? map14 : map14.set(layer, memoized)];
      }))))));
    }), flatten3);
  }
}
var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
var buildWithScope = /* @__PURE__ */ dual(2, (self, scope2) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope2)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope2) => flatMap7(makeBuilder(self, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope2, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause) => memoMap.getOrElseMemoize(op.failureK(cause), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap7((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith2(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var context2 = () => fromEffectContext(context());
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(map10(effect, (service) => make6(tag, service)));
});
function fromEffectContext(effect) {
  const fromEffect4 = Object.create(proto3);
  fromEffect4._op_layer = OP_FROM_EFFECT;
  fromEffect4.effect = effect;
  return fromEffect4;
}
var merge5 = /* @__PURE__ */ dual(2, (self, that) => zipWith5(self, that, (a, b) => merge3(a, b)));
var mergeAll2 = (...layers) => {
  let final = layers[0];
  for (let i = 1;i < layers.length; i++) {
    final = merge5(final, layers[i]);
  }
  return final;
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(map10(effect, (service) => make6(tag, service)));
});
var scopedContext = (effect) => {
  const scoped2 = Object.create(proto3);
  scoped2._op_layer = OP_SCOPED;
  scoped2.effect = effect;
  return scoped2;
};
var succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make6(tag, resource)));
});
var suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
};
var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const evaluate2 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make6(tag, evaluate2())));
});
var provide = /* @__PURE__ */ dual(2, (self, that) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll2(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
  const zipWith5 = Object.create(proto3);
  zipWith5._op_layer = OP_PROVIDE_MERGE;
  zipWith5.first = self;
  zipWith5.second = provide(that, self);
  zipWith5.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith5;
});
var zipWith5 = /* @__PURE__ */ dual(3, (self, that, f) => suspend2(() => {
  const zipWith6 = Object.create(proto3);
  zipWith6._op_layer = OP_ZIP_WITH2;
  zipWith6.first = self;
  zipWith6.second = that;
  zipWith6.zipK = f;
  return zipWith6;
}));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith((scope2) => flatMap7(buildWithScope(layer, scope2), (context3) => provideSomeContext(self, context3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll2(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId13 in source) {
    return flatMap7(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var error = (...args2) => consoleWith((_) => _.error(...args2));
var log = (...args2) => consoleWith((_) => _.log(...args2));

// node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var tagged2 = (tag) => (args2) => {
  const value = args2 === undefined ? Object.create(StructuralPrototype) : struct2(args2);
  value._tag = tag;
  return value;
};
var taggedEnum = () => new Proxy({}, {
  get(_target, tag, _receiver) {
    if (tag === "$is") {
      return isTagged;
    } else if (tag === "$match") {
      return taggedMatch;
    }
    return tagged2(tag);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value2) {
      return cases2[value2._tag](value2);
    };
  }
  const value = arguments[0];
  const cases = arguments[1];
  return cases[value._tag](value);
}
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : undefined);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// node_modules/effect/dist/esm/internal/dateTime.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId14]: TypeId14,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var isDateTime = (u) => hasProperty(u, TypeId14);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var minEpochMillis = -8640000000000000 + 12 * 60 * 60 * 1000;
var maxEpochMillis = 8640000000000000 - 14 * 60 * 60 * 1000;
var toDateUtc = (self) => new Date(self.epochMillis);
var toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== undefined) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== "literal");
  const date = new Date(0);
  date.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date.getTime();
  return date;
};
var zonedOffset = (self) => {
  const date = toDate(self);
  return date.getTime() - toEpochMillis(self);
};
var offsetToString = (offset) => {
  const abs = Math.abs(offset);
  let hours2 = Math.floor(abs / (60 * 60 * 1000));
  let minutes2 = Math.round(abs % (60 * 60 * 1000) / (60 * 1000));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self) => offsetToString(zonedOffset(self));
var toEpochMillis = (self) => self.epochMillis;
var constDayMillis = 24 * 60 * 60 * 1000;
var formatIsoOffset = (self) => {
  const date = toDate(self);
  return self._tag === "Utc" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
var formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

// node_modules/effect/dist/esm/Cron.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId15]: TypeId15,
  [symbol2](that) {
    return isCron(that) && equals3(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array2(fromIterable(this.seconds))), combine(array2(fromIterable(this.minutes))), combine(array2(fromIterable(this.hours))), combine(array2(fromIterable(this.days))), combine(array2(fromIterable(this.months))), combine(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable(this.seconds),
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId15);
var Equivalence2 = /* @__PURE__ */ make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array(number);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable(self), fromIterable(that));
var equals3 = /* @__PURE__ */ dual(2, (self, that) => Equivalence2(self, that));

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  output: undefined,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};
var scheduleDriverVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};

class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});

class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return map10(get9(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap7(get9(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException);
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake4(defaultIterationMetadata);
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set4(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map10(get9(this.ref), (tuple3) => tuple3[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out, decision]) => {
      const setState = set4(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
      }
      const duration = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
    }))))));
  }
}
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => map10(f(out), (delay) => sum(duration, decode(delay)))));
var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done5]);
  }
  return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done5]);
})));
var driver = (self) => pipe(make25([none2(), self.initial]), map10((ref) => new ScheduleDriverImpl(self, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith2(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap7(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done5]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap7(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done5]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done5]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var map14 = /* @__PURE__ */ dual(2, (self, f) => mapEffect2(self, (out) => sync(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay = size9(make36(now, start2(intervals)));
  return map10(f(out, delay), (durationInput) => {
    const duration = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make36(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var spaced = (duration) => addDelay(forever2, () => duration);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error2) {
    this.error = error2;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause) => match2(find(cause, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause,
  onSome: (error2) => fail(error2.error)
});
var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause) => failCause(scheduleDefectRefailCause(cause)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map14((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule, orElse4) => flatMap7(driver(schedule), (driver2) => matchEffect(self, {
  onFailure: (error2) => orElse4(error2, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get9(driver2.iterationMeta)), driver2, (error2, option) => provideServiceEffect(orElse4(error2, option), CurrentIterationMetadata, get9(driver2.iterationMeta)), value)
})));
var repeatOrElseEffectLoop = (self, driver2, orElse4, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error2) => orElse4(error2, some2(b)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self, driver2, orElse4, value2)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse4) => flatMap7(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get9(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse4(e, out), CurrentIterationMetadata, get9(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver2, orElse4) => {
  return catchAll(self, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap7((out) => orElse4(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver2, orElse4)
  }));
};
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);

// node_modules/effect/dist/esm/MutableList.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId16]: TypeId16,
  [Symbol.iterator]() {
    let done7 = false;
    let head3 = this.head;
    return {
      next() {
        if (done7) {
          return this.return();
        }
        if (head3 == null) {
          done7 = true;
          return this.return();
        }
        const value = head3.value;
        head3 = head3.next;
        return {
          done: done7,
          value
        };
      },
      return(value) {
        if (!done7) {
          done7 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
var empty33 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
var isEmpty8 = (self) => length(self) === 0;
var length = (self) => self._length;
var append3 = /* @__PURE__ */ dual(2, (self, value) => {
  const node = makeNode(value);
  if (self.head === undefined) {
    self.head = node;
  }
  if (self.tail === undefined) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head3 = self.head;
  if (head3 !== undefined) {
    remove7(self, head3);
    return head3.value;
  }
  return;
};
var remove7 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self.head = node.next;
    node.next.prev = undefined;
  } else {
    self.tail = undefined;
    self.head = undefined;
  }
  if (self._length > 0) {
    self._length -= 1;
  }
};

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId17]: TypeId17,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make41 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty33();
  queue.capacity = capacity;
  return queue;
};
var bounded = (capacity) => make41(capacity);
var unbounded = () => make41(undefined);
var length2 = (self) => length(self.queue);
var isEmpty9 = (self) => isEmpty8(self.queue);
var capacity = (self) => self.capacity === undefined ? Infinity : self.capacity;
var offer = /* @__PURE__ */ dual(2, (self, value) => {
  const queueLength = length(self.queue);
  if (self.capacity !== undefined && queueLength === self.capacity) {
    return false;
  }
  append3(value)(self.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self, values3) => {
  const iterator = values3[Symbol.iterator]();
  let next4;
  let remainder = empty5();
  let offering = true;
  while (offering && (next4 = iterator.next()) && !next4.done) {
    offering = offer(next4.value)(self);
  }
  while (next4 != null && !next4.done) {
    remainder = prepend2(next4.value)(remainder);
    next4 = iterator.next();
  }
  return reverse2(remainder);
});
var poll2 = /* @__PURE__ */ dual(2, (self, def) => {
  if (isEmpty8(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
  let result = empty5();
  let count = 0;
  while (count < n) {
    const element = poll2(EmptyMutableQueue)(self);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count += 1;
  }
  return reverse2(result);
});

// node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var all5 = all3;
var filter8 = filter6;
var forEach8 = forEach7;
var async = async_;
var withFiberRuntime2 = withFiberRuntime;
var fail8 = fail2;
var failSync2 = failSync;
var failCause7 = failCause;
var die5 = die2;
var dieMessage2 = dieMessage;
var gen2 = gen;
var succeed8 = succeed;
var suspend3 = suspend;
var sync3 = sync;
var _void = void_;
var catchAll2 = catchAll;
var catchAllCause2 = catchAllCause;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var ignore2 = ignore;
var retry = retry_combined;
var try_2 = try_;
var tryMap2 = tryMap;
var tryPromise2 = tryPromise;
var interrupt7 = interrupt2;
var interruptible4 = interruptible2;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var as3 = as;
var asVoid2 = asVoid;
var map15 = map10;
var mapBoth3 = mapBoth;
var mapError2 = mapError;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var scope2 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var fiberIdWith2 = fiberIdWith;
var forkDaemon2 = forkDaemon;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var timeout2 = timeout;
var contextWithEffect2 = contextWithEffect;
var provide2 = effect_provide;
var provideService2 = provideService;
var serviceFunctions2 = serviceFunctions;
var serviceOption2 = serviceOption;
var bind3 = bind2;
var bindTo3 = bindTo2;
var either3 = either2;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var filterOrDieMessage2 = filterOrDieMessage;
var unlessEffect2 = unlessEffect;
var when2 = when;
var flatMap9 = flatMap7;
var flatten6 = flatten3;
var race2 = race;
var raceWith2 = raceWith;
var tap2 = tap;
var tapErrorCause2 = tapErrorCause;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var match12 = match8;
var matchCause2 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var logError2 = logError;
var annotateLogs2 = annotateLogs;
var orDie2 = orDie;
var orElse4 = orElse2;
var orElseFail2 = orElseFail;
var runtime4 = runtime3;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var runFork2 = unsafeForkEffect;
var runSync = unsafeRunSyncEffect;
var zip5 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith6 = zipWithOptions;
var makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args2) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn, cn);
      const apply = fn.apply;
      const bind4 = fn.bind;
      const call = fn.call;
      const proto4 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto4.apply = apply;
      proto4.bind = bind4;
      proto4.call = call;
      Object.setPrototypeOf(fn, proto4);
      cache.set(prop, fn);
      return fn;
    }
  });
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service, Object.getPrototypeOf(this));
        return service;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service) => new this(service);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect3(TagClass, map15(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect3(TagClass, map15(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped(TagClass, map15(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map15(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed6(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};

// node_modules/@effect/printer-ansi/dist/esm/internal/color.js
var black = {
  _tag: "Black"
};
var red = {
  _tag: "Red"
};
var green = {
  _tag: "Green"
};
var magenta = {
  _tag: "Magenta"
};
var cyan = {
  _tag: "Cyan"
};
var white = {
  _tag: "White"
};
var toCode = (color) => {
  switch (color._tag) {
    case "Black": {
      return 0;
    }
    case "Red": {
      return 1;
    }
    case "Green": {
      return 2;
    }
    case "Yellow": {
      return 3;
    }
    case "Blue": {
      return 4;
    }
    case "Magenta": {
      return 5;
    }
    case "Cyan": {
      return 6;
    }
    case "White": {
      return 7;
    }
  }
};

// node_modules/@effect/printer-ansi/dist/esm/Color.js
var red2 = red;
var magenta2 = magenta;
var cyan2 = cyan;
var white2 = white;

// node_modules/effect/dist/esm/Console.js
var error2 = error;
var log3 = log;

// node_modules/effect/dist/esm/SynchronizedRef.js
var make43 = makeSynchronized;
var get13 = get9;
var updateEffect2 = updateEffect;

// node_modules/@effect/typeclass/dist/esm/internal/Iterable.js
function reduce13(b, f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.reduce(f, b);
    }
    let result = b;
    for (const n of iterable) {
      result = f(result, n);
    }
    return result;
  };
}
function map16(f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.map(f);
    }
    return function* () {
      for (const n of iterable) {
        yield f(n);
      }
    }();
  };
}

// node_modules/@effect/typeclass/dist/esm/Product.js
var struct3 = (F) => (fields) => {
  const keys5 = Object.keys(fields);
  return F.imap(F.productAll(keys5.map((k) => fields[k])), (values3) => {
    const out = {};
    for (let i = 0;i < values3.length; i++) {
      out[keys5[i]] = values3[i];
    }
    return out;
  }, (r) => keys5.map((k) => r[k]));
};

// node_modules/@effect/typeclass/dist/esm/Semigroup.js
var make44 = (combine12, combineMany = (self, collection) => reduce13(self, combine12)(collection)) => ({
  combine: combine12,
  combineMany
});
var constant2 = (a) => make44(() => a, () => a);
var first2 = () => make44((a) => a, (a) => a);
var imap = /* @__PURE__ */ dual(3, (S, to, from) => make44((self, that) => to(S.combine(from(self), from(that))), (self, collection) => to(S.combineMany(from(self), map16(from)(collection)))));
var product = (self, that) => make44(([xa, xb], [ya, yb]) => [self.combine(xa, ya), that.combine(xb, yb)]);
var productAll = (collection) => {
  return make44((x, y) => {
    const len = Math.min(x.length, y.length);
    const out = [];
    let collectionLength = 0;
    for (const s of collection) {
      if (collectionLength >= len) {
        break;
      }
      out.push(s.combine(x[collectionLength], y[collectionLength]));
      collectionLength++;
    }
    return out;
  });
};
var productMany = (self, collection) => {
  const semigroup = productAll(collection);
  return make44((x, y) => [self.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);
};
var of5 = constant2;
var Product = {
  of: of5,
  imap,
  product,
  productMany,
  productAll
};
var array4 = () => make44((self, that) => self.concat(that));
var struct4 = /* @__PURE__ */ struct3(Product);

// node_modules/@effect/typeclass/dist/esm/Monoid.js
var fromSemigroup = (S, empty34) => ({
  combine: S.combine,
  combineMany: S.combineMany,
  empty: empty34,
  combineAll: (collection) => S.combineMany(empty34, collection)
});
var array5 = () => fromSemigroup(array4(), []);
var struct5 = (fields) => {
  const empty34 = {};
  for (const k in fields) {
    if (Object.prototype.hasOwnProperty.call(fields, k)) {
      empty34[k] = fields[k].empty;
    }
  }
  return fromSemigroup(struct4(fields), empty34);
};

// node_modules/@effect/printer-ansi/dist/esm/internal/sgr.js
var reset = {
  _tag: "Reset"
};
var setBold = (bold) => ({
  _tag: "SetBold",
  bold
});
var setColor = (color, vivid, layer) => ({
  _tag: "SetColor",
  color,
  vivid,
  layer
});
var setItalicized = (italicized) => ({
  _tag: "SetItalicized",
  italicized
});
var setStrikethrough = (strikethrough) => ({
  _tag: "SetStrikethrough",
  strikethrough
});
var setUnderlined = (underlined) => ({
  _tag: "SetUnderlined",
  underlined
});
var toCode2 = (self) => {
  switch (self._tag) {
    case "Reset": {
      return 0;
    }
    case "SetBold": {
      return self.bold ? 1 : 22;
    }
    case "SetColor": {
      switch (self.layer) {
        case "foreground": {
          return self.vivid ? 90 + toCode(self.color) : 30 + toCode(self.color);
        }
        case "background": {
          return self.vivid ? 100 + toCode(self.color) : 40 + toCode(self.color);
        }
      }
    }
    case "SetItalicized": {
      return self.italicized ? 3 : 23;
    }
    case "SetStrikethrough": {
      return self.strikethrough ? 9 : 29;
    }
    case "SetUnderlined": {
      return self.underlined ? 4 : 24;
    }
  }
};
var toEscapeSequence = (sgrs) => csi("m", sgrs);
var csi = (controlFunction, sgrs) => {
  const params = Array.from(sgrs).map((sgr) => `${toCode2(sgr)}`).join(";");
  return `\x1B[${params}${controlFunction}`;
};

// node_modules/@effect/printer-ansi/dist/esm/internal/ansi.js
var AnsiSymbolKey = "@effect/printer-ansi/Ansi";
var AnsiTypeId = /* @__PURE__ */ Symbol.for(AnsiSymbolKey);
var make45 = (params) => ({
  ...AnsiMonoid.empty,
  ...params
});
var typeIdSemigroup = /* @__PURE__ */ first2();
var getFirstSomeSemigroup = /* @__PURE__ */ make44((self, that) => isSome2(self) ? self : that);
var AnsiSemigroup = /* @__PURE__ */ struct4({
  [AnsiTypeId]: typeIdSemigroup,
  commands: /* @__PURE__ */ array4(),
  foreground: getFirstSomeSemigroup,
  background: getFirstSomeSemigroup,
  bold: getFirstSomeSemigroup,
  italicized: getFirstSomeSemigroup,
  strikethrough: getFirstSomeSemigroup,
  underlined: getFirstSomeSemigroup
});
var typeIdMonoid = /* @__PURE__ */ fromSemigroup(typeIdSemigroup, AnsiTypeId);
var monoidOrElse = /* @__PURE__ */ fromSemigroup(getFirstSomeSemigroup, /* @__PURE__ */ none2());
var AnsiMonoid = /* @__PURE__ */ struct5({
  [AnsiTypeId]: typeIdMonoid,
  commands: /* @__PURE__ */ array5(),
  foreground: monoidOrElse,
  background: monoidOrElse,
  bold: monoidOrElse,
  italicized: monoidOrElse,
  strikethrough: monoidOrElse,
  underlined: monoidOrElse
});
var none9 = AnsiMonoid.empty;
var ESC = "\x1B[";
var BEL = "\x07";
var SEP = ";";
var bold = /* @__PURE__ */ make45({
  bold: /* @__PURE__ */ some2(/* @__PURE__ */ setBold(true))
});
var italicized = /* @__PURE__ */ make45({
  italicized: /* @__PURE__ */ some2(/* @__PURE__ */ setItalicized(true))
});
var strikethrough = /* @__PURE__ */ make45({
  strikethrough: /* @__PURE__ */ some2(/* @__PURE__ */ setStrikethrough(true))
});
var underlined = /* @__PURE__ */ make45({
  underlined: /* @__PURE__ */ some2(/* @__PURE__ */ setUnderlined(true))
});
var brightColor = (color) => make45({
  foreground: some2(setColor(color, true, "foreground"))
});
var color = (color2) => make45({
  foreground: some2(setColor(color2, false, "foreground"))
});
var black2 = /* @__PURE__ */ color(black);
var red3 = /* @__PURE__ */ color(red);
var green2 = /* @__PURE__ */ color(green);
var white3 = /* @__PURE__ */ color(white);
var blackBright = /* @__PURE__ */ brightColor(black);
var cyanBright = /* @__PURE__ */ brightColor(cyan);
var beep = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(BEL)
});
var cursorTo = (column, row) => {
  if (row === undefined) {
    const command2 = `${ESC}${Math.max(column + 1, 0)}G`;
    return make45({
      commands: of(command2)
    });
  }
  const command = `${ESC}${row + 1}${SEP}${Math.max(column + 1, 0)}H`;
  return make45({
    commands: of(command)
  });
};
var cursorMove = (column, row = 0) => {
  let command = "";
  if (row < 0) {
    command += `${ESC}${-row}A`;
  }
  if (row > 0) {
    command += `${ESC}${row}B`;
  }
  if (column > 0) {
    command += `${ESC}${column}C`;
  }
  if (column < 0) {
    command += `${ESC}${-column}D`;
  }
  return make45({
    commands: of(command)
  });
};
var cursorDown = (lines = 1) => {
  const command = `${ESC}${lines}B`;
  return make45({
    commands: of(command)
  });
};
var cursorLeft = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}G`)
});
var cursorSavePosition = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}s`)
});
var cursorRestorePosition = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}u`)
});
var cursorHide = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}?25l`)
});
var cursorShow = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}?25h`)
});
var eraseLines = (rows) => {
  let command = "";
  for (let i = 0;i < rows; i++) {
    command += `${ESC}2K` + (i < rows - 1 ? `${ESC}1A` : "");
  }
  if (rows > 0) {
    command += `${ESC}G`;
  }
  return make45({
    commands: of(command)
  });
};
var eraseEndLine = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}K`)
});
var eraseStartLine = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}1K`)
});
var eraseLine = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}2K`)
});
var eraseDown = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}J`)
});
var eraseUp = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}1J`)
});
var eraseScreen = /* @__PURE__ */ make45({
  commands: /* @__PURE__ */ of(`${ESC}2J`)
});
var stringify = (self) => stringifyInternal(self);
var combine12 = /* @__PURE__ */ dual(2, (self, that) => combineInternal(self, that));
var combineInternal = (self, that) => AnsiSemigroup.combine(self, that);
var stringifyInternal = (self) => {
  const displaySequence = toEscapeSequence(getSomes([some2(reset), self.foreground, self.background, self.bold, self.italicized, self.strikethrough, self.underlined]));
  const commandSequence = join(self.commands, "");
  return `${displaySequence}${commandSequence}`;
};

// node_modules/@effect/printer-ansi/dist/esm/Ansi.js
var bold2 = bold;
var italicized2 = italicized;
var strikethrough2 = strikethrough;
var underlined2 = underlined;
var color2 = color;
var black3 = black2;
var red4 = red3;
var green3 = green2;
var white4 = white3;
var blackBright2 = blackBright;
var cyanBright2 = cyanBright;
var combine13 = combine12;

// node_modules/@effect/printer/dist/esm/internal/flatten.js
var FlattenSymbolKey = "@effect/printer/Flatten";
var FlattenTypeId = /* @__PURE__ */ Symbol.for(FlattenSymbolKey);
var protoHash = {
  Flattened: (self) => combine(hash(self.value))(string(FlattenSymbolKey)),
  AlreadyFlat: (_) => combine(string("@effect/printer/Flattened/AlreadyFlat"))(string(FlattenSymbolKey)),
  NeverFlat: (_) => combine(string("@effect/printer/Flattened/NeverFlat"))(string(FlattenSymbolKey))
};
var protoEqual = {
  Flattened: (self, that) => isFlatten(that) && that._tag === "Flattened" && equals(self.value, that.value),
  AlreadyFlat: (_, that) => isFlatten(that) && that._tag === "AlreadyFlat",
  NeverFlat: (_, that) => isFlatten(that) && that._tag === "NeverFlat"
};
var proto4 = {
  [FlattenTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual[this._tag](this, that);
  }
};
var isFlatten = (u) => typeof u === "object" && u != null && (FlattenTypeId in u);
var isFlattened = (self) => self._tag === "Flattened";
var isAlreadyFlat = (self) => self._tag === "AlreadyFlat";
var isNeverFlat = (self) => self._tag === "NeverFlat";
var flattened = (value) => (() => {
  const op = Object.create(proto4);
  op._tag = "Flattened";
  op.value = value;
  return op;
})();
var alreadyFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto4);
  op._tag = "AlreadyFlat";
  return op;
})();
var neverFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto4);
  op._tag = "NeverFlat";
  return op;
})();
var map17 = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case "Flattened": {
      return flattened(f(self.value));
    }
    case "AlreadyFlat": {
      return alreadyFlat;
    }
    case "NeverFlat": {
      return neverFlat;
    }
  }
});

// node_modules/@effect/printer/dist/esm/internal/doc.js
var DocSymbolKey = "@effect/printer/Doc";
var DocTypeId = /* @__PURE__ */ Symbol.for(DocSymbolKey);
var protoHash2 = {
  Fail: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Fail")),
  Empty: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Empty")),
  Char: (self) => combine(hash(DocSymbolKey))(string(self.char)),
  Text: (self) => combine(hash(DocSymbolKey))(string(self.text)),
  Line: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Line")),
  FlatAlt: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Cat: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Nest: (self) => combine(hash(DocSymbolKey))(combine(hash(self.indent))(hash(self.doc))),
  Union: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Column: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  WithPageWidth: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Nesting: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Annotated: (self) => combine(hash(DocSymbolKey))(combine(hash(self.annotation))(hash(self.doc)))
};
var protoEqual2 = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self, that) => isDoc(that) && that._tag === "Char" && self.char === that.char,
  Text: (self, that) => isDoc(that) && that._tag === "Text" && self.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self, that) => isDoc(that) && that._tag === "FlatAlt" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Cat: (self, that) => isDoc(that) && that._tag === "Cat" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Nest: (self, that) => isDoc(that) && that._tag === "Nest" && self.indent === that.indent && equals(that.doc)(self.doc),
  Union: (self, that) => isDoc(that) && that._tag === "Union" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Column: (self, that) => isDoc(that) && that._tag === "Column" && equals(that.react)(self.react),
  WithPageWidth: (self, that) => isDoc(that) && that._tag === "WithPageWidth" && equals(that.react)(self.react),
  Nesting: (self, that) => isDoc(that) && that._tag === "Nesting" && equals(that.react)(self.react),
  Annotated: (self, that) => isDoc(that) && that._tag === "Annotated" && equals(that.annotation)(self.annotation) && equals(that.doc)(self.doc)
};
var proto5 = {
  [DocTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash2[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual2[this._tag](this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isDoc = (u) => typeof u === "object" && u != null && (DocTypeId in u);
var isEmpty10 = (self) => self._tag === "Empty";
var isChar = (self) => self._tag === "Char";
var isText = (self) => self._tag === "Text";
var isCat = (self) => self._tag === "Cat";
var isNest = (self) => self._tag === "Nest";
var char = (char2) => {
  const op = Object.create(proto5);
  op._tag = "Char";
  op.char = char2;
  return op;
};
var text = (text2) => {
  const op = Object.create(proto5);
  op._tag = "Text";
  op.text = text2;
  return op;
};
var flatAlt = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "FlatAlt";
  op.left = self;
  op.right = that;
  return op;
});
var union8 = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "Union";
  op.left = self;
  op.right = that;
  return op;
});
var cat = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto5);
  op._tag = "Cat";
  op.left = self;
  op.right = that;
  return op;
});
var empty34 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Empty";
  return op;
})();
var fail9 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Fail";
  return op;
})();
var hardLine = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto5);
  op._tag = "Line";
  return op;
})();
var line = /* @__PURE__ */ flatAlt(hardLine, /* @__PURE__ */ char(" "));
var lineBreak = /* @__PURE__ */ flatAlt(hardLine, empty34);
var space = /* @__PURE__ */ char(" ");
var cats = (docs) => group2(vcat(docs));
var catWithLine = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(line, that)));
var catWithLineBreak = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(lineBreak, that)));
var catWithSpace = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(space, that)));
var concatWith = /* @__PURE__ */ dual(2, (docs, f) => matchRight(fromIterable(docs), {
  onEmpty: () => empty34,
  onNonEmpty: (init, last3) => reduceRight(init, last3, (curr, acc) => f(acc, curr))
}));
var vcat = (docs) => concatWith(docs, (left3, right3) => catWithLineBreak(left3, right3));
var hsep = (docs) => concatWith(docs, (left3, right3) => catWithSpace(left3, right3));
var vsep = (docs) => concatWith(docs, (left3, right3) => catWithLine(left3, right3));
var group2 = (self) => {
  switch (self._tag) {
    case "FlatAlt": {
      const flattened2 = changesUponFlattening(self.right);
      switch (flattened2._tag) {
        case "Flattened": {
          return union8(flattened2.value, self.left);
        }
        case "AlreadyFlat": {
          return union8(self.right, self.left);
        }
        case "NeverFlat": {
          return self.left;
        }
      }
    }
    case "Union": {
      return self;
    }
    default: {
      const flattened2 = changesUponFlattening(self);
      return isFlattened(flattened2) ? union8(flattened2.value, self) : self;
    }
  }
};
var column = (react) => {
  const op = Object.create(proto5);
  op._tag = "Column";
  op.react = react;
  return op;
};
var nesting = (react) => {
  const op = Object.create(proto5);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
var pageWidth = (react) => {
  const op = Object.create(proto5);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
var nest = /* @__PURE__ */ dual(2, (self, indent) => indent === 0 ? self : (() => {
  const op = Object.create(proto5);
  op._tag = "Nest";
  op.indent = indent;
  op.doc = self;
  return op;
})());
var align = (self) => column((position) => nesting((level) => nest(self, position - level)));
var hang = /* @__PURE__ */ dual(2, (self, indent) => align(nest(self, indent)));
var indent = /* @__PURE__ */ dual(2, (self, indent2) => hang(cat(spaces(indent2), self), indent2));
var flatten7 = (self) => runSync(flattenSafe(self));
var flattenSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail": {
      return self;
    }
    case "Empty": {
      return self;
    }
    case "Char": {
      return self;
    }
    case "Text": {
      return self;
    }
    case "Line": {
      return fail9;
    }
    case "FlatAlt": {
      return yield* flattenSafe(self.right);
    }
    case "Cat": {
      const left3 = yield* flattenSafe(self.left);
      const right3 = yield* flattenSafe(self.right);
      return cat(left3, right3);
    }
    case "Nest": {
      const doc = yield* flattenSafe(self.doc);
      return nest(doc, self.indent);
    }
    case "Union": {
      return yield* flattenSafe(self.left);
    }
    case "Column": {
      return column((position) => flatten7(self.react(position)));
    }
    case "WithPageWidth": {
      return pageWidth((pageWidth2) => flatten7(self.react(pageWidth2)));
    }
    case "Nesting": {
      return nesting((level) => flatten7(self.react(level)));
    }
    case "Annotated": {
      const doc = yield* flattenSafe(self.doc);
      return annotate(doc, self.annotation);
    }
  }
});
var changesUponFlattening = (self) => runSync(changesUponFlatteningSafe(self));
var changesUponFlatteningSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail":
    case "Line": {
      return neverFlat;
    }
    case "Empty":
    case "Char":
    case "Text": {
      return alreadyFlat;
    }
    case "FlatAlt": {
      const doc = yield* flattenSafe(self.right);
      return flattened(doc);
    }
    case "Cat": {
      const left3 = yield* changesUponFlatteningSafe(self.left);
      const right3 = yield* changesUponFlatteningSafe(self.right);
      if (isNeverFlat(left3) || isNeverFlat(right3)) {
        return neverFlat;
      }
      if (isFlattened(left3) && isFlattened(right3)) {
        return flattened(cat(left3.value, right3.value));
      }
      if (isFlattened(left3) && isAlreadyFlat(right3)) {
        return flattened(cat(left3.value, self.right));
      }
      if (isAlreadyFlat(left3) && isFlattened(right3)) {
        return flattened(cat(self.left, right3.value));
      }
      if (isAlreadyFlat(left3) && isAlreadyFlat(right3)) {
        return alreadyFlat;
      }
      throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document " + "- please open an issue at https://github.com/IMax153/contentlayer/issues/new");
    }
    case "Nest": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map15(map17((doc) => nest(doc, self.indent))));
    }
    case "Union": {
      return flattened(self.left);
    }
    case "Column": {
      const doc = column((position) => runSync(flattenSafe(self.react(position))));
      return flattened(doc);
    }
    case "WithPageWidth": {
      const doc = pageWidth((pageWidth2) => runSync(flattenSafe(self.react(pageWidth2))));
      return flattened(doc);
    }
    case "Nesting": {
      const doc = nesting((level) => runSync(flattenSafe(self.react(level))));
      return flattened(doc);
    }
    case "Annotated": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map15(map17((doc) => annotate(doc, self.annotation))));
    }
  }
});
var annotate = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto5);
  op._tag = "Annotated";
  op.doc = self;
  op.annotation = annotation;
  return op;
});
var spaces = (n) => {
  if (n <= 0) {
    return empty34;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
var textSpaces = (n) => {
  let s = "";
  for (let i = 0;i < n; i++) {
    s = s += " ";
  }
  return s;
};

// node_modules/@effect/printer/dist/esm/internal/docStream.js
var DocStreamSymbolKey = "@effect/printer/DocStream";
var DocStreamTypeId = /* @__PURE__ */ Symbol.for(DocStreamSymbolKey);
var protoHash3 = {
  FailedStream: (_) => pipe(string("@effect/printer/DocStream/FailedStream"), combine(string(DocStreamSymbolKey))),
  EmptyStream: (_) => pipe(string("@effect/printer/DocStream/EmptyStream"), combine(string(DocStreamSymbolKey))),
  CharStream: (self) => pipe(hash("@effect/printer/DocStream/CharStream"), combine(string(DocStreamSymbolKey)), combine(string(self.char)), combine(hash(self.stream))),
  TextStream: (self) => pipe(string("@effect/printer/DocStream/TextStream"), combine(string(DocStreamSymbolKey)), combine(string(self.text)), combine(hash(self.stream))),
  LineStream: (self) => pipe(string("@effect/printer/DocStream/LineStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream))),
  PushAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.annotation)), combine(hash(self.stream))),
  PopAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream)))
};
var protoEqual3 = {
  FailedStream: (self, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self, that) => isDocStream(that) && that._tag === "CharStream" && self.char === that.char && equals(self.stream, that.stream),
  TextStream: (self, that) => isDocStream(that) && that._tag === "TextStream" && self.text === that.text && equals(self.stream, that.stream),
  LineStream: (self, that) => isDocStream(that) && that._tag === "LineStream" && equals(self.stream, that.stream),
  PushAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && equals(self.annotation, that.annotation) && equals(self.stream, that.stream),
  PopAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && equals(self.stream, that.stream)
};
var proto6 = {
  [DocStreamTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash3[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual3[this._tag](this, that);
  }
};
var isDocStream = (u) => typeof u === "object" && u != null && (DocStreamTypeId in u);
var isEmptyStream = (self) => self._tag === "EmptyStream";
var isLineStream = (self) => self._tag === "LineStream";
var failed = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto6);
  op._tag = "FailedStream";
  return op;
})();
var empty35 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto6);
  op._tag = "EmptyStream";
  return op;
})();
var char2 = /* @__PURE__ */ dual(2, (self, char3) => {
  const op = Object.create(proto6);
  op._tag = "CharStream";
  op.char = char3;
  op.stream = self;
  return op;
});
var text2 = /* @__PURE__ */ dual(2, (self, text3) => {
  const op = Object.create(proto6);
  op._tag = "TextStream";
  op.text = text3;
  op.stream = self;
  return op;
});
var line2 = /* @__PURE__ */ dual(2, (self, indentation) => {
  const op = Object.create(proto6);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self;
  return op;
});
var pushAnnotation = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto6);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self;
  return op;
});
var popAnnotation = (stream) => {
  const op = Object.create(proto6);
  op._tag = "PopAnnotationStream";
  op.stream = stream;
  return op;
};

// node_modules/@effect/printer/dist/esm/internal/layoutPipeline.js
var nil2 = {
  _tag: "Nil"
};
var cons2 = (indent2, document, pipeline) => ({
  _tag: "Cons",
  indent: indent2,
  document,
  pipeline
});
var undoAnnotation = (pipeline) => ({
  _tag: "UndoAnnotation",
  pipeline
});

// node_modules/@effect/printer/dist/esm/internal/pageWidth.js
var PageWidthSymbolKey = "@effect/printer/PageWidth";
var PageWidthTypeId = /* @__PURE__ */ Symbol.for(PageWidthSymbolKey);
var protoHash4 = {
  AvailablePerLine: (self) => pipe(hash("@effect/printer/PageWidth/AvailablePerLine"), combine(hash(PageWidthSymbolKey)), combine(hash(self.lineWidth)), combine(hash(self.ribbonFraction))),
  Unbounded: (_) => pipe(hash("@effect/printer/PageWidth/Unbounded"), combine(hash(PageWidthSymbolKey)))
};
var protoEqual4 = {
  AvailablePerLine: (self, that) => isPageWidth(that) && that._tag === "AvailablePerLine" && self.lineWidth === that.lineWidth && self.ribbonFraction === that.ribbonFraction,
  Unbounded: (self, that) => isPageWidth(that) && that._tag === "Unbounded"
};
var proto7 = {
  [PageWidthTypeId]: PageWidthTypeId,
  [symbol]() {
    return cached(this, protoHash4[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual4[this._tag](this, that);
  }
};
var isPageWidth = (u) => typeof u === "object" && u != null && (PageWidthTypeId in u);
var availablePerLine = (lineWidth, ribbonFraction) => {
  const op = Object.create(proto7);
  op._tag = "AvailablePerLine";
  op.lineWidth = lineWidth;
  op.ribbonFraction = ribbonFraction;
  return op;
};
var unbounded2 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto7);
  op._tag = "Unbounded";
  return op;
})();
var defaultPageWidth = /* @__PURE__ */ availablePerLine(80, 1);
var remainingWidth = (pageWidth2, ribbonFraction, indentation, currentColumn) => {
  const columnsLeftInLine = pageWidth2 - currentColumn;
  const ribbonWidth = Math.max(0, Math.min(pageWidth2, Math.floor(pageWidth2 * ribbonFraction)));
  const columnsLeftInRibbon = indentation + ribbonWidth - currentColumn;
  return Math.min(columnsLeftInLine, columnsLeftInRibbon);
};

// node_modules/@effect/printer/dist/esm/internal/layout.js
var options = (pageWidth2) => ({
  pageWidth: pageWidth2
});
var wadlerLeijen = /* @__PURE__ */ dual(3, (self, fits, options2) => runSync(wadlerLeijenSafe(cons2(0, self, nil2), 0, 0, fits, options2)));
var wadlerLeijenSafe = (self, nestingLevel, currentColumn, fits, options2) => {
  const best = (self2, nl, cc) => gen2(function* () {
    switch (self2._tag) {
      case "Nil": {
        return empty35;
      }
      case "Cons": {
        switch (self2.document._tag) {
          case "Fail": {
            return failed;
          }
          case "Empty": {
            return yield* best(self2.pipeline, nl, cc);
          }
          case "Char": {
            const stream = yield* best(self2.pipeline, nl, cc + 1);
            return char2(stream, self2.document.char);
          }
          case "Text": {
            const length3 = self2.document.text.length;
            const stream = yield* best(self2.pipeline, nl, cc + length3);
            return text2(stream, self2.document.text);
          }
          case "Line": {
            const stream = yield* best(self2.pipeline, self2.indent, self2.indent);
            const nextIndent = isEmptyStream(stream) || isLineStream(stream) ? 0 : self2.indent;
            return line2(stream, nextIndent);
          }
          case "FlatAlt": {
            const next4 = cons2(self2.indent, self2.document.left, self2.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Cat": {
            const inner = cons2(self2.indent, self2.document.right, self2.pipeline);
            const outer = cons2(self2.indent, self2.document.left, inner);
            return yield* best(outer, nl, cc);
          }
          case "Nest": {
            const indent2 = self2.indent + self2.document.indent;
            const next4 = cons2(indent2, self2.document.doc, self2.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Union": {
            const leftPipeline = cons2(self2.indent, self2.document.left, self2.pipeline);
            const rightPipeline = cons2(self2.indent, self2.document.right, self2.pipeline);
            const left3 = best(leftPipeline, nl, cc);
            const right3 = best(rightPipeline, nl, cc);
            return selectNicer(fits, nl, cc, left3, right3);
          }
          case "Column": {
            const doc = self2.document.react(cc);
            const next4 = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "WithPageWidth": {
            const doc = self2.document.react(options2.pageWidth);
            const next4 = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Nesting": {
            const doc = self2.document.react(self2.indent);
            const next4 = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Annotated": {
            const undo = undoAnnotation(self2.pipeline);
            const next4 = cons2(self2.indent, self2.document.doc, undo);
            const stream = yield* best(next4, nl, cc);
            return pushAnnotation(stream, self2.document.annotation);
          }
        }
      }
      case "UndoAnnotation": {
        const stream = yield* best(self2.pipeline, nestingLevel, currentColumn);
        return popAnnotation(stream);
      }
    }
  });
  return best(self, nestingLevel, currentColumn);
};
var selectNicer = (fits, lineIndent, currentColumn, left3, right3) => {
  const leftStream = runSync(left3);
  let rightStream = undefined;
  return fits(leftStream, lineIndent, currentColumn, () => rightStream ?? (rightStream = runSync(right3), rightStream)) ? leftStream : rightStream ?? runSync(right3);
};
var compact2 = (self) => runSync(compactSafe(of3(self), 0));
var compactSafe = (docs, i) => gen2(function* () {
  if (isNil(docs)) {
    return empty35;
  }
  const head4 = docs.head;
  const tail = docs.tail;
  switch (head4._tag) {
    case "Fail": {
      return failed;
    }
    case "Empty": {
      return yield* compactSafe(tail, i);
    }
    case "Char": {
      const stream = yield* compactSafe(tail, i + 1);
      return char2(stream, head4.char);
    }
    case "Text": {
      const stream = yield* compactSafe(tail, i + head4.text.length);
      return text2(stream, head4.text);
    }
    case "Line": {
      const stream = yield* compactSafe(tail, 0);
      return line2(stream, 0);
    }
    case "FlatAlt": {
      return yield* compactSafe(cons(head4.left, tail), i);
    }
    case "Cat": {
      const list = cons(head4.left, cons(head4.right, tail));
      return yield* compactSafe(list, i);
    }
    case "Nest": {
      return yield* compactSafe(cons(head4.doc, tail), i);
    }
    case "Union": {
      return yield* compactSafe(cons(head4.right, tail), i);
    }
    case "Column": {
      return yield* compactSafe(cons(head4.react(i), tail), i);
    }
    case "WithPageWidth": {
      return yield* compactSafe(cons(head4.react(unbounded2), tail), i);
    }
    case "Nesting": {
      return yield* compactSafe(cons(head4.react(0), tail), i);
    }
    case "Annotated": {
      return yield* compactSafe(cons(head4.doc, tail), i);
    }
  }
});
var pretty4 = /* @__PURE__ */ dual(2, (self, options2) => {
  const width = options2.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self, (stream, indentation, currentColumn) => {
      const remainingWidth2 = remainingWidth(width.lineWidth, width.ribbonFraction, indentation, currentColumn);
      return fitsPretty(stream, remainingWidth2);
    }, options2);
  }
  return unbounded3(self);
});
var fitsPretty = (self, width) => {
  let w = width;
  let stream = self;
  while (w >= 0) {
    switch (stream._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream = stream.stream;
        break;
      }
      case "TextStream": {
        w = w - stream.text.length;
        stream = stream.stream;
        break;
      }
      case "LineStream": {
        return true;
      }
      case "PushAnnotationStream": {
        stream = stream.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream = stream.stream;
        break;
      }
    }
  }
  return false;
};
var smart = /* @__PURE__ */ dual(2, (self, options2) => {
  const width = options2.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self, fitsSmart(width.lineWidth, width.ribbonFraction), options2);
  }
  return unbounded3(self);
});
var fitsSmart = (pageWidth2, ribbonFraction) => {
  return (stream, indentation, currentColumn, comparator) => {
    const availableWidth = remainingWidth(pageWidth2, ribbonFraction, indentation, currentColumn);
    return fitsSmartLoop(stream, comparator, pageWidth2, currentColumn, availableWidth);
  };
};
var fitsSmartLoop = (self, comparator, pageWidth2, currentColumn, availableWidth) => {
  let minNestingLevel;
  let stream = self;
  let w = availableWidth;
  while (w >= 0) {
    switch (stream._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream = stream.stream;
        break;
      }
      case "TextStream": {
        w = w - stream.text.length;
        stream = stream.stream;
        break;
      }
      case "LineStream": {
        if (!minNestingLevel) {
          minNestingLevel = match2(getInitialIndentation(comparator()), {
            onNone: () => currentColumn,
            onSome: (value) => Math.min(value, currentColumn)
          });
        }
        if (minNestingLevel < stream.indentation) {
          return false;
        }
        w = pageWidth2 - stream.indentation;
        stream = stream.stream;
        break;
      }
      case "PushAnnotationStream": {
        stream = stream.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream = stream.stream;
        break;
      }
    }
  }
  return false;
};
var getInitialIndentation = (self) => {
  let stream = self;
  while (stream._tag === "LineStream" || stream._tag === "PushAnnotationStream" || stream._tag === "PopAnnotationStream") {
    if (stream._tag === "LineStream") {
      return some2(stream.indentation);
    }
    stream = stream.stream;
  }
  return none2();
};
var unbounded3 = (self) => wadlerLeijen(self, (stream) => !failsOnFirstLine(stream), {
  pageWidth: unbounded2
});
var failsOnFirstLine = (self) => {
  let stream = self;
  while (true) {
    switch (stream._tag) {
      case "FailedStream": {
        return true;
      }
      case "EmptyStream": {
        return false;
      }
      case "CharStream": {
        stream = stream.stream;
        break;
      }
      case "TextStream": {
        stream = stream.stream;
        break;
      }
      case "LineStream": {
        return false;
      }
      case "PushAnnotationStream": {
        stream = stream.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream = stream.stream;
        break;
      }
    }
  }
  throw new Error("bug");
};

// node_modules/@effect/printer/dist/esm/Doc.js
var char3 = char;
var text3 = text;
var empty36 = empty34;
var hardLine2 = hardLine;
var space2 = space;
var cat2 = cat;
var cats2 = cats;
var hsep2 = hsep;
var vsep2 = vsep;
var nest2 = nest;
var align2 = align;
var indent2 = indent;
var annotate2 = annotate;

// node_modules/@effect/printer-ansi/dist/esm/internal/ansiDoc.js
var beep2 = /* @__PURE__ */ annotate2(empty36, beep);
var cursorTo2 = (column2, row) => annotate2(empty36, cursorTo(column2, row));
var cursorMove2 = (column2, row) => annotate2(empty36, cursorMove(column2, row));
var cursorDown2 = (lines = 1) => annotate2(empty36, cursorDown(lines));
var cursorLeft2 = /* @__PURE__ */ annotate2(empty36, cursorLeft);
var cursorSavePosition2 = /* @__PURE__ */ annotate2(empty36, cursorSavePosition);
var cursorRestorePosition2 = /* @__PURE__ */ annotate2(empty36, cursorRestorePosition);
var cursorHide2 = /* @__PURE__ */ annotate2(empty36, cursorHide);
var cursorShow2 = /* @__PURE__ */ annotate2(empty36, cursorShow);
var eraseLines2 = (rows) => annotate2(empty36, eraseLines(rows));
var eraseLine2 = /* @__PURE__ */ annotate2(empty36, eraseLine);

// node_modules/@effect/printer/dist/esm/PageWidth.js
var defaultPageWidth2 = defaultPageWidth;

// node_modules/@effect/printer/dist/esm/Layout.js
var options2 = options;
var compact3 = compact2;
var pretty5 = pretty4;
var smart2 = smart;

// node_modules/@effect/printer-ansi/dist/esm/internal/ansiRender.js
var render3 = /* @__PURE__ */ dual(2, (self, config2) => {
  switch (config2.style) {
    case "compact": {
      return renderStream2(compact3(self));
    }
    case "pretty": {
      const width2 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream2(pretty5(self, options2(width2)));
    }
    case "smart": {
      const width2 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream2(smart2(self, options2(width2)));
    }
  }
});
var renderStream2 = (self) => runSync(renderSafe(self, of3(none9)));
var unsafePeek = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePeek - peeked at an empty stack" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return stack.head;
};
var unsafePop = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePop - popped from an empty stack" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return [stack.head, stack.tail];
};
var renderSafe = (self, stack) => {
  switch (self._tag) {
    case "FailedStream": {
      return dieMessage2("BUG: AnsiRender.renderSafe - attempted to render a failed doc stream" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
    }
    case "EmptyStream": {
      return succeed8("");
    }
    case "CharStream": {
      return map15(suspend3(() => renderSafe(self.stream, stack)), (rest) => self.char + rest);
    }
    case "TextStream": {
      return map15(suspend3(() => renderSafe(self.stream, stack)), (rest) => self.text + rest);
    }
    case "LineStream": {
      let indent3 = `
`;
      for (let i = 0;i < self.indentation; i++) {
        indent3 = indent3 += " ";
      }
      return map15(suspend3(() => renderSafe(self.stream, stack)), (rest) => indent3 + rest);
    }
    case "PushAnnotationStream": {
      const currentStyle = unsafePeek(stack);
      const nextStyle = combine12(self.annotation, currentStyle);
      return map15(suspend3(() => renderSafe(self.stream, cons(self.annotation, stack))), (rest) => stringify(nextStyle) + rest);
    }
    case "PopAnnotationStream": {
      const [, styles] = unsafePop(stack);
      const nextStyle = unsafePeek(styles);
      return map15(suspend3(() => renderSafe(self.stream, styles)), (rest) => stringify(nextStyle) + rest);
    }
  }
};

// node_modules/@effect/printer-ansi/dist/esm/AnsiDoc.js
var beep3 = beep2;
var cursorTo3 = cursorTo2;
var cursorMove3 = cursorMove2;
var cursorDown3 = cursorDown2;
var cursorLeft3 = cursorLeft2;
var cursorSavePosition3 = cursorSavePosition2;
var cursorRestorePosition3 = cursorRestorePosition2;
var cursorHide3 = cursorHide2;
var cursorShow3 = cursorShow2;
var eraseLines3 = eraseLines2;
var eraseLine3 = eraseLine2;
var render4 = render3;

// node_modules/@effect/printer/dist/esm/internal/optimize.js
var optimize2 = /* @__PURE__ */ dual(2, (self, depth) => runSync(optimizeSafe(self, depth)));
var optimizeSafe = (self, depth) => {
  const optimize3 = (self2) => gen2(function* () {
    switch (self2._tag) {
      case "Fail":
      case "Empty":
      case "Char":
      case "Text":
      case "Line": {
        return self2;
      }
      case "FlatAlt": {
        const left3 = yield* optimize3(self2.left);
        const right3 = yield* optimize3(self2.right);
        return flatAlt(left3, right3);
      }
      case "Cat": {
        if (isEmpty10(self2.left)) {
          return yield* optimize3(self2.right);
        }
        if (isEmpty10(self2.right)) {
          return yield* optimize3(self2.left);
        }
        if (isChar(self2.left) && isChar(self2.right)) {
          return text(self2.left.char + self2.right.char);
        }
        if (isText(self2.left) && isChar(self2.right)) {
          return text(self2.left.text + self2.right.char);
        }
        if (isChar(self2.left) && isText(self2.right)) {
          return text(self2.left.char + self2.right.text);
        }
        if (isText(self2.left) && isText(self2.right)) {
          return text(self2.left.text + self2.right.text);
        }
        if (isChar(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isChar(self2.left) && isCat(self2.right) && isText(self2.right.left) || isText(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isText(self2.left) && isCat(self2.right) && isText(self2.right.left)) {
          const inner = yield* optimize3(cat(self2.left, self2.right.left));
          return yield* optimize3(cat(inner, self2.right.right));
        }
        if (isCat(self2.left) && isChar(self2.left.right) || isCat(self2.left) && isText(self2.left.right)) {
          const inner = yield* optimize3(cat(self2.left.right, self2.right));
          return yield* optimize3(cat(self2.left.left, inner));
        }
        const left3 = yield* optimize3(self2.left);
        const right3 = yield* optimize3(self2.right);
        return cat(left3, right3);
      }
      case "Nest": {
        if (self2.indent === 0) {
          return yield* optimize3(self2.doc);
        }
        if (isEmpty10(self2.doc) || isChar(self2.doc) || isText(self2.doc)) {
          return self2.doc;
        }
        if (isNest(self2.doc)) {
          const indent3 = self2.indent + self2.doc.indent;
          return yield* optimize3(nest(self2.doc.doc, indent3));
        }
        return nest(yield* optimize3(self2.doc), self2.indent);
      }
      case "Union": {
        const left3 = yield* optimize3(self2.left);
        const right3 = yield* optimize3(self2.right);
        return union8(left3, right3);
      }
      case "Column": {
        return depth._tag === "Shallow" ? self2 : column((position) => runSync(optimizeSafe(self2.react(position), depth)));
      }
      case "WithPageWidth": {
        return depth._tag === "Shallow" ? self2 : pageWidth((pageWidth3) => runSync(optimizeSafe(self2.react(pageWidth3), depth)));
      }
      case "Nesting": {
        return depth._tag === "Shallow" ? self2 : nesting((level) => runSync(optimizeSafe(self2.react(level), depth)));
      }
      case "Annotated": {
        return annotate(yield* optimize3(self2.doc), self2.annotation);
      }
    }
  });
  return optimize3(self);
};

// node_modules/@effect/printer/dist/esm/Optimize.js
var Deep = {
  _tag: "Deep"
};
var optimize3 = optimize2;

// node_modules/@effect/cli/dist/esm/internal/helpDoc/span.js
var text4 = (value) => ({
  _tag: "Text",
  value
});
var empty37 = /* @__PURE__ */ text4("");
var space3 = /* @__PURE__ */ text4(" ");
var code = (value) => highlight(value, white2);
var error3 = (value) => highlight(value, red2);
var highlight = (value, color3) => ({
  _tag: "Highlight",
  value: typeof value === "string" ? text4(value) : value,
  color: color3
});
var strong = (value) => ({
  _tag: "Strong",
  value: typeof value === "string" ? text4(value) : value
});
var weak = (value) => ({
  _tag: "Weak",
  value: typeof value === "string" ? text4(value) : value
});
var isText3 = (self) => self._tag === "Text";
var concat2 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Sequence",
  left: self,
  right: that
}));
var getText = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value;
    }
    case "Highlight":
    case "Weak":
    case "Strong": {
      return getText(self.value);
    }
    case "Sequence": {
      return getText(self.left) + getText(self.right);
    }
  }
};
var spans = (spans2) => {
  const elements = fromIterable(spans2);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(concat2, elements[0]);
  }
  return empty37;
};
var isEmpty12 = (self) => size11(self) === 0;
var size11 = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value.length;
    }
    case "Highlight":
    case "Strong":
    case "Weak": {
      return size11(self.value);
    }
    case "Sequence": {
      return size11(self.left) + size11(self.right);
    }
  }
};
var toAnsiDoc = (self) => {
  switch (self._tag) {
    case "Highlight": {
      return annotate2(toAnsiDoc(self.value), color2(self.color));
    }
    case "Sequence": {
      return cat2(toAnsiDoc(self.left), toAnsiDoc(self.right));
    }
    case "Strong": {
      return annotate2(toAnsiDoc(self.value), bold2);
    }
    case "Text": {
      return text3(self.value);
    }
    case "URI": {
      return annotate2(text3(self.value), underlined2);
    }
    case "Weak": {
      return annotate2(toAnsiDoc(self.value), black3);
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/helpDoc.js
var isEmpty13 = (helpDoc) => helpDoc._tag === "Empty";
var isHeader = (helpDoc) => helpDoc._tag === "Header";
var isParagraph = (helpDoc) => helpDoc._tag === "Paragraph";
var isDescriptionList = (helpDoc) => helpDoc._tag === "DescriptionList";
var empty38 = {
  _tag: "Empty"
};
var sequence = /* @__PURE__ */ dual(2, (self, that) => {
  if (isEmpty13(self)) {
    return that;
  }
  if (isEmpty13(that)) {
    return self;
  }
  return {
    _tag: "Sequence",
    left: self,
    right: that
  };
});
var blocks = (helpDocs) => {
  const elements = fromIterable(helpDocs);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty38;
};
var getSpan = (self) => isHeader(self) || isParagraph(self) ? self.value : empty37;
var descriptionList = (definitions) => ({
  _tag: "DescriptionList",
  definitions
});
var enumeration = (elements) => ({
  _tag: "Enumeration",
  elements
});
var h1 = (value) => ({
  _tag: "Header",
  value: typeof value === "string" ? text4(value) : value,
  level: 1
});
var p = (value) => ({
  _tag: "Paragraph",
  value: typeof value === "string" ? text4(value) : value
});
var mapDescriptionList = /* @__PURE__ */ dual(2, (self, f) => isDescriptionList(self) ? descriptionList(map3(self.definitions, ([span2, helpDoc]) => f(span2, helpDoc))) : self);
var toAnsiDoc2 = (self) => optimize3(toAnsiDocInternal(self), Deep);
var toAnsiText = (self) => render4(toAnsiDoc2(self), {
  style: "pretty"
});
var toAnsiDocInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty36;
    }
    case "Header": {
      return pipe(annotate2(toAnsiDoc(self.value), bold2), cat2(hardLine2));
    }
    case "Paragraph": {
      return pipe(toAnsiDoc(self.value), cat2(hardLine2));
    }
    case "DescriptionList": {
      const definitions = self.definitions.map(([span2, doc]) => cats2([annotate2(toAnsiDoc(span2), bold2), empty36, indent2(toAnsiDocInternal(doc), 2)]));
      return vsep2(definitions);
    }
    case "Enumeration": {
      const elements = self.elements.map((doc) => cat2(text3("- "), toAnsiDocInternal(doc)));
      return indent2(vsep2(elements), 2);
    }
    case "Sequence": {
      return vsep2([toAnsiDocInternal(self.left), toAnsiDocInternal(self.right)]);
    }
  }
};

// node_modules/@effect/cli/dist/esm/HelpDoc.js
var p2 = p;

// node_modules/effect/dist/esm/ConfigError.js
var isConfigError2 = isConfigError;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => new WeakMap);
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto8 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make46 = (value) => {
  const redacted = Object.create(proto8);
  redactedRegistry.set(redacted, value);
  return redacted;
};

// node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto8,
  [SecretTypeId]: SecretTypeId
};
var make47 = (bytes) => {
  const secret = Object.create(SecretProto);
  Object.defineProperty(secret, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret;
};
var fromString = (text5) => {
  return make47(text5.split("").map((char4) => char4.charCodeAt(0)));
};

// node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  _A: (_) => _
};
var proto9 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);

// node_modules/effect/dist/esm/Config.js
var isConfig2 = isConfig;

// node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f) => {
  let done8 = false;
  let a;
  return () => {
    if (done8) {
      return a;
    }
    a = f();
    done8 = true;
    return a;
  };
};
var formatDate = (date2) => {
  try {
    return date2.toISOString();
  } catch {
    return String(date2);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty6 = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty6(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown2, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown2;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var createASTGuard = (tag) => (ast) => ast._tag === tag;
class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal2, annotations = {}) {
    this.literal = literal2;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {}) {
    super(type, annotations);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head4, tail) => {
      const formattedHead = String(head4);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys5 = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys5, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys5[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten9 = (candidates) => flatMap2(candidates, (ast) => isUnion3(ast) ? flatten9(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union {
  types;
  annotations;
  static make = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten9(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var mapMembers = (members, f) => members.map(f);
var isMembers = (as4) => as4.length > 1;
var isUnion3 = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter9, annotations = {}) {
    this.from = from;
    this.filter = filter9;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};

class Transformation {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
class FinalTransformation {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode2, encode) {
    this.decode = decode2;
    this.encode = encode;
  }
}
class ComposeTransformation {
  _tag = "ComposeTransformation";
}
var composeTransformation = /* @__PURE__ */ new ComposeTransformation;
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture2) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture2, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture2, top) => {
  if (isUnion3(type)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head4 = escape(ast.head);
    pattern += capture2 && top ? `(${head4})` : head4;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture2);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture2, top);
    if (span2.literal !== "") {
      const literal2 = escape(span2.literal);
      pattern += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out === undefined) {
        out = {};
      }
      out[id2] = annotated.annotations[id2];
    }
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p3) => {
        const type = typeAST(p3.type);
        return type === p3.type ? p3 : new PropertySignature(p3.name, type, p3.isOptional, p3.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = typeAST(is.type);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId]: identifier2
  })
});
function changeMap(as4, f) {
  let changed = false;
  const out = allocate(as4.length);
  for (let i = 0;i < as4.length; i++) {
    const a = as4[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as4;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = encodedAST_(is.type, isBound);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return identifier2 ? annotations(from, identifier2) : from;
    }
    case "Transformation": {
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier2 ? annotations(ast.from, identifier2) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));

// node_modules/effect/dist/esm/ParseResult.js
class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError = (issue) => new ParseError({
  issue
});
var succeed10 = right2;
var fail12 = left2;
var fromOption3 = fromOption2;
var isEither3 = isEither2;
var flatMap10 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: left2,
    onRight: f
  }) : flatMap9(self, f);
});
var map21 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? map(self, f) : map15(self, f);
});
var mapError3 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? mapLeft(self, f) : mapError2(self, f);
});
var orElse7 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: f,
    onRight: right2
  }) : catchAll2(self, f);
});
var mergeInternalOptions = (options3, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options3;
  }
  if (options3 === undefined) {
    return overrideOptions;
  }
  return {
    ...options3,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options3, overrideOptions));
};
var getSync = (ast, isDecoding, options3) => {
  const parser = getEither(ast, isDecoding, options3);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options3, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknown2 = (schema, options3) => getEffect(schema.ast, true, options3);
var validateSync = (schema, options3) => getSync(typeAST(schema.ast), true, options3);
var is = (schema, options3) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options3, overrideOptions)
  }));
};
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options3) => raw(i, mergeInternalOptions(options3, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options3) => handleForbidden(orElse7(parserWithOptions(i, options3), decodingFallbackAnnotation.value), ast, i, options3) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options3) => {
          options3 = options3 ?? defaultParseOption;
          const allErrors = options3?.errors === "all";
          const result = flatMap10(orElse7(from(i, options3), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options3, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options3, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options3);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options3) => handleForbidden(flatMap10(from(i, options3), (a) => to(a, options3)), ast, i, options3);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options3) => handleForbidden(flatMap10(mapError3(from(i, options3), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap10(mapError3(transform2(a, options3 ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError3(to(i2, options3), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options3);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options3) => handleForbidden(parse3(i, options3 ?? defaultParseOption, ast), ast, i, options3);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head4, ...tail] = rest;
          for (;i < len - tail.length; i++) {
            const te = head4(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options3);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is2) => [goMemo(is2.parameter, isDecoding), goMemo(is2.type, isDecoding), is2.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is2) => is2.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options3?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options3?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options3);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options3?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options3);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap9(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = parameter(key, options3);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type(input[key], options3);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options3?.propertyOrder === "original") {
            const keys5 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys5.indexOf(name) === -1) {
                keys5.push(name);
              }
            }
            const out = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map22 = new Map;
      for (let i = 0;i < astTypesLen; i++) {
        map22.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options3) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0;i < ownKeysLen; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map22.get(candidate)(input, options3);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap9(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get14 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options3) => get14()(a, options3);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0;j < tags.length; j++) {
        const [key, literal2] = tags[j];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect, ast, actual, options3) => {
  if (options3?.isEffectAllowed === true) {
    return effect;
  }
  if (isEither3(effect)) {
    return effect;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess(exit3)) {
      return right2(exit3.value);
    }
    const cause2 = exit3.cause;
    if (isFailType2(cause2)) {
      return left2(cause2.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause2)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map21(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value, forest = []) => ({
  value,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map21(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error4) => TreeFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => TreeFormatter.formatIssueSync(error4.issue)
};
var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(undefined);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union10 = messageAnnotation(issue);
    if (isString(union10)) {
      return right2({
        message: union10,
        override: false
      });
    }
    if (isEffect2(union10)) {
      return map15(union10, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union10.message)) {
      return right2({
        message: union10.message,
        override: union10.override
      });
    }
    return map15(union10.message, (message) => ({
      message,
      override: union10.override
    }));
  }
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap10(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map21(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map21(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map21(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map21(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map21(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map21(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map21(forEach8(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map21(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};

// node_modules/effect/dist/esm/internal/layer/circular.js
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));

// node_modules/effect/dist/esm/Layer.js
var effect = fromEffect3;
var mergeAll4 = mergeAll2;
var scoped3 = scoped;
var succeed11 = succeed6;
var provide3 = provide;
var provideMerge2 = provideMerge;

// node_modules/@effect/cli/dist/esm/internal/cliConfig.js
var Tag3 = /* @__PURE__ */ GenericTag("@effect/cli/CliConfig");
var defaultConfig = {
  isCaseSensitive: false,
  autoCorrectLimit: 2,
  finalCheckBuiltIn: false,
  showAllNames: true,
  showBuiltIns: true,
  showTypes: true
};
var normalizeCase = /* @__PURE__ */ dual(2, (self, text5) => self.isCaseSensitive ? text5 : text5.toLowerCase());

// node_modules/@effect/cli/dist/esm/internal/autoCorrect.js
var levensteinDistance = (first3, second, config2) => {
  if (first3.length === 0 && second.length === 0) {
    return 0;
  }
  if (first3.length === 0) {
    return second.length;
  }
  if (second.length === 0) {
    return first3.length;
  }
  const rowCount = first3.length;
  const columnCount = second.length;
  const matrix = new Array(rowCount);
  const normalFirst = normalizeCase(config2, first3);
  const normalSecond = normalizeCase(config2, second);
  for (let x = 0;x <= rowCount; x++) {
    matrix[x] = new Array(columnCount);
    matrix[x][0] = x;
  }
  for (let y = 0;y <= columnCount; y++) {
    matrix[0][y] = y;
  }
  for (let row = 1;row <= rowCount; row++) {
    for (let col = 1;col <= columnCount; col++) {
      const cost = normalFirst.charAt(row - 1) === normalSecond.charAt(col - 1) ? 0 : 1;
      matrix[row][col] = Math.min(matrix[row][col - 1] + 1, Math.min(matrix[row - 1][col] + 1, matrix[row - 1][col - 1] + cost));
    }
  }
  return matrix[rowCount][columnCount];
};

// node_modules/effect/dist/esm/Brand.js
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some2(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};

// node_modules/effect/dist/esm/FiberRef.js
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentLoggers2 = currentLoggers;
var currentScheduler2 = currentScheduler;

// node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  _A: (_) => _
};
var backingQueueVariance = {
  _A: (_) => _
};
var enqueueVariance = {
  _In: (_) => _
};
var dequeueVariance = {
  _Out: (_) => _
};

class QueueImpl extends Class {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map10(this.size, (size12) => size12 <= 0);
  }
  get isFull() {
    return map10(this.size, (size12) => size12 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values3 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty2;
      const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
      for (let i = 0;i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      });
    });
  }
  takeUpTo(max6) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values3 = this.queue.pollUpTo(max6);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values3);
    }));
  }
  takeBetween(min4, max6) {
    return suspend(() => takeRemainderLoop(this, min4, max6, empty5()));
  }
}
var takeRemainderLoop = (self, min4, max6, acc) => {
  if (max6 < min4) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max6), flatMap7((bs) => {
    const remaining = min4 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self), flatMap7((b) => takeRemainderLoop(self, remaining - 1, max6 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make48(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make48(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make48(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded4 = () => pipe(sync(() => unbounded()), flatMap7((queue) => make48(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake8 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make48 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake8(queue, unbounded(), deferred, make13(false), strategy)));

class BackingQueueFromMutableQueue {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable) {
    this.mutable = mutable;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
}
var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
var size12 = (self) => self.size;
var shutdown = (self) => self.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self, value) => self.offer(value));
var take2 = (self) => self.take;
var takeUpTo = /* @__PURE__ */ dual(2, (self, max6) => self.takeUpTo(max6));
var backPressureStrategy = () => new BackPressureStrategy;
var droppingStrategy = () => new DroppingStrategy;
var slidingStrategy = () => new SlidingStrategy;

class BackPressureStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll2(takers, undefined);
      const putter = poll2(this.putters, undefined);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap7((fiberId2) => pipe(sync(() => unsafePollAll(this.putters)), flatMap7((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId2), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0;i < stuff.length; i++) {
      const value = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value, deferred, true]));
      } else {
        pipe(this.putters, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
}

class DroppingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
}

class SlidingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next4;
    let offering = true;
    while (!(next4 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next4.value);
    }
  }
}
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as4) => {
  return pipe(queue, offerAll(as4));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max6) => {
  return pipe(queue, pollUpTo(max6));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty40 = true;
    let loop2 = true;
    while (loop2) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop2 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty40 = false;
          loop2 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty40;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop2 = true;
    let polled = default_;
    while (loop2) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop2 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop2 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}
class ReplayBuffer {
  capacity;
  constructor(capacity2) {
    this.capacity = capacity2;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as4) {
    for (const a of as4) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty5();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0;i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var emptyReplayWindow = {
  remaining: 0,
  take: () => {
    return;
  },
  takeN: () => empty5(),
  takeAll: () => empty5()
};

// node_modules/effect/dist/esm/Queue.js
var bounded4 = bounded2;
var dropping3 = dropping;
var sliding3 = sliding;
var unbounded6 = unbounded4;
var size14 = size12;
var shutdown3 = shutdown;
var offer3 = offer2;
var take3 = take2;

// node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto10 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto10);
  op._tag = OP_CONTINUE2;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutDone: (_) => _,
  _OutErr2: (_) => _,
  _OutElem: (_) => _,
  _OutDone2: (_) => _
};

class ContinuationKImpl {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit3) {
    return isFailure(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
  }
}

class ContinuationFinalizerImpl {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer) {
    this.finalizer = finalizer;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  _A: (_) => _
};
var proto11 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto11);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var proto12 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
  const op = Object.create(proto12);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release;
  return op;
});
var collectElements = (self) => {
  return suspend5(() => {
    const builder = [];
    return flatMap12(pipeTo(self, collectElementsReader(builder)), (value) => sync5(() => [fromIterable2(builder), value]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap12(sync5(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail14,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto12);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h) => {
  const op = Object.create(proto12);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self, input) => {
  const op = Object.create(proto12);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer) => {
  const op = Object.create(proto12);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer;
  return op;
});
var fail14 = (error4) => failCause9(fail5(error4));
var failCause9 = (cause2) => failCauseSync3(() => cause2);
var failCauseSync3 = (evaluate2) => {
  const op = Object.create(proto12);
  op._tag = OP_FAIL3;
  op.error = evaluate2;
  return op;
};
var flatMap12 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto12);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause9);
  return op;
});
var fromEffect4 = (effect2) => {
  const op = Object.create(proto12);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect2;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto12);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var readWith = (options3) => readWithCause({
  onInput: options3.onInput,
  onFailure: (cause2) => match(failureOrCause2(cause2), {
    onLeft: options3.onFailure,
    onRight: failCause9
  }),
  onDone: options3.onDone
});
var readWithCause = (options3) => {
  const op = Object.create(proto12);
  op._tag = OP_READ;
  op.more = options3.onInput;
  op.done = new ContinuationKImpl(options3.onDone, options3.onFailure);
  return op;
};
var succeed12 = (value) => sync5(() => value);
var succeedNow = (result) => {
  const op = Object.create(proto12);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend5 = (evaluate2) => {
  const op = Object.create(proto12);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate2;
  return op;
};
var sync5 = (evaluate2) => {
  const op = Object.create(proto12);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate2;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(undefined);
var write = (out) => {
  const op = Object.create(proto12);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  _E: (_) => _,
  _R: (_) => _
};
var proto13 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto13);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto13);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect2) => {
  const op = Object.create(proto13);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect2;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone) => {
  const op = Object.create(proto13);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : undefined;

// node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";

class PullFromChild {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.childExecutor.close(exit3);
    const fin2 = this.parentSubexecutor.close(exit3);
    if (fin1 !== undefined && fin2 !== undefined) {
      return zipWith6(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== undefined) {
      return fin1;
    } else if (fin2 !== undefined) {
      return fin2;
    } else {
      return;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

class PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith6(acc, exit2(next4), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}

class DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith6(acc, exit2(next4), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}

class Emit2 {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value, next4) {
    this.value = value;
    this.next = next4;
  }
  close(exit3) {
    const result = this.next.close(exit3);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  _A: (_) => _
};
var proto14 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value) => {
  const op = Object.create(proto14);
  op._tag = OP_PULLED;
  op.value = value;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto14);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// node_modules/effect/dist/esm/internal/channel/channelExecutor.js
class ChannelExecutor {
  _activeSubexecutor = undefined;
  _cancelled = undefined;
  _closeLastSubstream = undefined;
  _currentChannel;
  _done = undefined;
  _doneStack = [];
  _emitted = undefined;
  _executeCloseLastSubstream;
  _input = undefined;
  _inProgressFinalizer = undefined;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== undefined) {
                  const inputExecutor = this._input;
                  this._input = undefined;
                  const drainer = () => flatMap9(bridgeInput.awaitRead(), () => suspend3(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: (value) => bridgeInput.done(value)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap9(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause2) => bridgeInput.error(cause2));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap9(forkDaemon2(interruptible4(drainer())), (fiber) => sync3(() => this.addFinalizer((exit3) => flatMap9(interrupt6(fiber), () => suspend3(() => {
                    const effect3 = this.restorePipe(exit3, inputExecutor);
                    return effect3 !== undefined ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync3(() => {
                  const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request) => channel.onPull(request), (value) => channel.onEmit(value));
                this._closeLastSubstream = undefined;
                this._currentChannel = undefined;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect3, {
                  onFailure: (cause2) => {
                    const state = this.doneHalt(cause2);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value) => {
                    const state = this.doneSucceed(value);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit3) => {
                  const effect3 = this.restorePipe(exit3, previousInput);
                  return effect3 !== undefined ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync3(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read.done.onExit(die3(error4));
                  }
                  return;
                }, (exit3) => {
                  const onExit3 = (exit4) => {
                    return read.done.onExit(exit4);
                  };
                  this._currentChannel = onExit3(exit3);
                  return;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause9(die4(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit3) {
    this._cancelled = exit3;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit3) {
    const finalizers = [];
    let next4 = this._doneStack.pop();
    while (next4) {
      if (next4._tag === "ContinuationFinalizer") {
        finalizers.push(next4.finalizer);
      }
      next4 = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit3, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== undefined) {
      const effect3 = currInput.close(exit3);
      return effect3;
    }
    return _void;
  }
  close(exit3) {
    let runInProgressFinalizers = undefined;
    const finalizer = this._inProgressFinalizer;
    if (finalizer !== undefined) {
      runInProgressFinalizers = pipe(finalizer, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = undefined;
    const selfFinalizers = this.popAllFinalizers(exit3);
    if (selfFinalizers !== undefined) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
      return;
    }
    return pipe(exit2(ifNotNull(closeSubexecutors)), zip5(exit2(ifNotNull(runInProgressFinalizers))), zip5(exit2(ifNotNull(closeSelf))), map15(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))), uninterruptible2, flatMap9((exit4) => suspend3(() => exit4)));
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = succeed4(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const head4 = this._doneStack[this._doneStack.length - 1];
    if (head4._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head4.onSuccess(value);
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed4(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed4(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync3(() => this.doneSucceed(value))));
    return fromEffect5(effect3);
  }
  doneHalt(cause2) {
    if (this._doneStack.length === 0) {
      this._done = failCause4(cause2);
      this._currentChannel = undefined;
      return Done2();
    }
    const head4 = this._doneStack[this._doneStack.length - 1];
    if (head4._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head4.onHalt(cause2);
      } catch (error4) {
        this._currentChannel = failCause9(die4(error4));
      }
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause4(cause2);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause4(cause2));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync3(() => this.doneHalt(cause2))));
    return fromEffect5(effect3);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause2) => sync3(() => {
        this._currentChannel = failCause9(cause2);
      }),
      onSuccess: (out) => sync3(() => {
        this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === undefined) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring3) {
    this.addFinalizer(ensuring3.finalizer);
    this._currentChannel = ensuring3.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit3) {
    const state = match9(exit3, {
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value) => this.doneSucceed(value)
    });
    this._activeSubexecutor = undefined;
    return state === undefined ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach8((closeFunc) => pipe(sync3(() => closeFunc(subexecutorDone)), flatMap9((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value) => this.doneSucceed(value)
    }));
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return;
    }, match9({
      onFailure: (cause2) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2);
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2) {
    return this.finishSubexecutorWithCloseEffect(failCause4(cause2), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map15(() => {
          const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return;
    }, (exit3) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
        const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map15(() => this.replaceSubexecutor(drain)));
        }
        this.replaceSubexecutor(drain);
        return;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map11((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
      return state === undefined ? undefined : effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
}
var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void;
var runFinalizers = (finalizers, exit3) => {
  return pipe(forEach8(finalizers, (fin) => exit2(fin(exit3))), map15((exits) => pipe(all2(exits), getOrElse(() => void_3))), flatMap9((exit4) => suspend3(() => exit4)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause2((cause2) => suspend3(() => {
          const doneEffect = current.onDone(failCause4(cause2));
          return doneEffect === undefined ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend3(() => read());
      }
    }
  };
  return read();
};
var runIn = /* @__PURE__ */ dual(2, (self, scope4) => {
  const run = (channelDeferred, scopeDeferred, scope5) => acquireUseRelease2(sync3(() => new ChannelExecutor(self, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit3) => {
    const finalize = exec.close(exit3);
    if (finalize === undefined) {
      return _void;
    }
    return tapErrorCause2(finalize, (cause2) => addFinalizer2(scope5, failCause7(cause2)));
  });
  return uninterruptibleMask3((restore) => all5([fork(scope4, sequential3), make24(), make24()]).pipe(flatMap9(([child, channelDeferred, scopeDeferred]) => restore(run(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope4), flatMap9((fiber) => scope4.addFinalizer((exit3) => {
    const interruptors3 = isFailure(exit3) ? interruptors2(exit3.cause) : undefined;
    return isDone(channelDeferred).pipe(flatMap9((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll3(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap9(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend3(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause7);
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto15 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Await = (f) => {
  const op = Object.create(proto15);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto16 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto16);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto16);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto16);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto17 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto17);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto17);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match16 = /* @__PURE__ */ dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause2) => ({
  _tag: OP_STATE_ERROR,
  cause: cause2
});
var stateDone = (done8) => ({
  _tag: OP_STATE_DONE2,
  done: done8
});

class SingleProducerAsyncInputImpl {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten6(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId2) => this.error(interrupt5(fiberId2)));
  }
  done(value) {
    return flatten6(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
            discard: true
          }), stateDone(value)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap9(make24(), (deferred) => flatten6(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== undefined) {
            return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause2) {
    return flatten6(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => failCause2(deferred, cause2), {
            discard: true
          }), stateError(cause2)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause2) => failCause4(map12(cause2, left2)), (elem) => succeed4(elem), (done8) => fail4(right2(done8)));
  }
  takeWith(onError3, onElement, onDone) {
    return flatMap9(make24(), (deferred) => flatten6(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed2(state.notifyProducer, undefined), matchCause2(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause2(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError3(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone(state.done)), state];
        }
      }
    })));
  }
}
var make49 = () => pipe(make24(), flatMap9((deferred) => make26(stateEmpty(deferred))), map15((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap12(fromEffect4(make26(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap2(acquire, (a) => set5(ref, (exit3) => release(a, exit3))))), flatMap12(use), ensuringWith((exit3) => flatMap9(get10(ref), (f) => f(exit3)))));
var concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => {
  return;
}, () => {
  return;
}));
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause9,
    onDone: succeed12
  });
  return pipeTo(self, drainer);
};
var ensuring3 = /* @__PURE__ */ dual(2, (self, finalizer) => ensuringWith(self, () => finalizer));
var flatten11 = (self) => flatMap12(self, identity);
var fromInput = (input) => unwrap2(input.takeWith(failCause9, (elem) => flatMap12(write(elem), () => fromInput(input)), succeed12));
var identityChannel = () => readWith({
  onInput: (input) => flatMap12(write(input), () => identityChannel()),
  onFailure: fail14,
  onDone: succeedNow
});
var map23 = /* @__PURE__ */ dual(2, (self, f) => flatMap12(self, (a) => sync5(() => f(a))));
var mapOut = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(f(outElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap12(write), flatMap12(() => reader)),
    onFailure: failCause9,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mergeAll5 = (options3) => {
  return (channels) => mergeAllWith(options3)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope4) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make49();
  const queueReader = fromInput(input);
  const queue = yield* bounded4(bufferSize);
  yield* addFinalizer2(scope4, shutdown3(queue));
  const cancelers = yield* unbounded6();
  yield* addFinalizer2(scope4, shutdown3(cancelers));
  const lastDone = yield* make26(none2());
  const errorSignal = yield* make24();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope4);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap9(match({
      onLeft: (done8) => succeed8(some2(done8)),
      onRight: (outElem) => as3(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap9((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause2((cause2) => isInterrupted2(cause2) ? failCause7(cause2) : offer3(queue, failCause7(cause2)).pipe(zipRight3(succeed2(errorSignal, undefined)), asVoid2)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause2) => offer3(queue, failCause7(cause2)).pipe(zipRight3(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as3(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight3(interrupt6(failureAwait), get10(lastDone).pipe(flatMap9(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
        })), as3(false)))
      }),
      onRight: (channel) => match16(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make24();
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap9(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make24();
          const latch = yield* make24();
          const size15 = yield* size14(cancelers);
          yield* take3(cancelers).pipe(flatMap9((canceler2) => succeed2(canceler2, undefined)), when2(() => size15 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap9(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope4));
  const consumer = pipe(take3(queue), flatten6, matchCause2({
    onFailure: failCause9,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap12(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self, f, options3) => mergeAll5(options3)(mapOut(self, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self, options3) => {
  function merge8(scope4) {
    return gen2(function* () {
      const input = yield* make49();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope4);
      const pullR = yield* toPullIn(pipeTo(queueReader, options3.other), scope4);
      function handleSide(exit3, fiber, pull) {
        return (done8, both2, single2) => {
          function onDecision(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
            }
            return map15(_await3(fiber), match9({
              onFailure: (cause2) => fromEffect4(op.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done9) => fromEffect4(op.f(succeed4(done9))),
                onRight: (elem) => zipRight4(write(elem), go2(single2(op.f)))
              })
            }));
          }
          return match9(exit3, {
            onFailure: (cause2) => onDecision(done8(failCause4(cause2))),
            onSuccess: match({
              onLeft: (z) => onDecision(done8(succeed4(z))),
              onRight: (elem) => succeed8(flatMap12(write(elem), () => flatMap12(fromEffect4(forkIn2(interruptible4(pull), scope4)), (leftFiber) => go2(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go2(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options3.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options3.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map15(exit2(pullR), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed4(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map15(exit2(pullL), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed4(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope4));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope4));
        return zipWith6(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap12(go2), embedInput(input));
    });
  }
  return unwrapScopedWith(merge8);
});
var pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend5(() => {
  let channelException = undefined;
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause9(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap12(() => writer)),
    onFailure: (cause2) => isDieType2(cause2) && isChannelException(cause2.defect) && equals(cause2.defect, channelException) ? fail14(cause2.defect.error) : failCause9(cause2),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var run = (self) => scopedWith2((scope4) => runIn(self, scope4));
var runDrain = (self) => run(drain(self));
var runScoped = (self) => scopeWith2((scope4) => runIn(self, scope4));
var scoped4 = (effect3) => unwrap2(uninterruptibleMask3((restore) => map15(make39(), (scope4) => acquireReleaseOut(tapErrorCause2(restore(extend2(effect3, scope4)), (cause2) => close(scope4, failCause4(cause2))), (_, exit3) => close(scope4, exit3)))));
var scopedWith3 = (f) => unwrapScoped2(map15(scope2, (scope4) => flatMap12(fromEffect4(f(scope4)), write)));
var splitLines = () => suspend5(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk3) => {
    const chunkBuilder = [];
    map4(chunk3, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf(`
`);
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf(`
`, from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop2 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop2 : flatMap12(write(out), () => loop2);
    },
    onFailure: (cause2) => stringBuilder.length === 0 ? failCause9(cause2) : flatMap12(write(of2(stringBuilder)), () => failCause9(cause2)),
    onDone: (done8) => stringBuilder.length === 0 ? succeed12(done8) : flatMap12(write(of2(stringBuilder)), () => succeed12(done8))
  });
  return loop2;
});
var toPullIn = /* @__PURE__ */ dual(2, (self, scope4) => zip5(sync3(() => new ChannelExecutor(self, undefined, identity)), runtime4()).pipe(tap2(([executor, runtime5]) => addFinalizerExit(scope4, (exit3) => {
  const finalizer = executor.close(exit3);
  return finalizer !== undefined ? provide2(finalizer, runtime5) : _void;
})), uninterruptible2, map15(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause7,
        onSuccess: (done8) => succeed8(left2(done8))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap9(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause2) => failCause7(cause2));
    }
  }
};
var unwrap2 = (channel) => flatten11(fromEffect4(channel));
var unwrapScoped2 = (self) => concatAllWith(scoped4(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk3) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk3, unsafeGet4(idx))), flatMap12(() => writeChunkWriter(idx + 1, len, chunk3)));
};
var zip7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options3) => options3?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip3(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip3(exit1, exit22)))
}) : flatMap12(self, (a) => map23(that, (b) => [a, b])));
var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options3) => options3?.concurrent ? map23(zip7(self, that, {
  concurrent: true
}), (tuple5) => tuple5[1]) : flatMap12(self, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};

class SinkImpl {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var suspend6 = (evaluate2) => new SinkImpl(suspend5(() => toChannel(evaluate2())));
var collectAll = () => new SinkImpl(collectAllLoop(empty5()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk3) => collectAllLoop(pipe(acc, appendAll2(chunk3))),
  onFailure: failCause9,
  onDone: () => succeed12(acc)
});
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var forEach9 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach8(input, (v) => f(v), {
      discard: true
    })), flatMap12(() => process2)),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect6(self)) : self.channel;
var unwrapScoped3 = (effect3) => new SinkImpl(unwrapScoped2(effect3.pipe(map15((sink) => toChannel(sink)))));

// node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork2;
var runPromiseExit = unsafeRunPromiseExit;

// node_modules/effect/dist/esm/Schedule.js
var spaced2 = spaced;

// node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// node_modules/effect/dist/esm/internal/stm/entry.js
var make51 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet7 = (self) => {
  return self.newValue;
};
var unsafeSet = (self, value) => {
  self.isChanged = true;
  self.newValue = value;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone6 = (self) => {
  return self._tag === OP_DONE6;
};
var done8 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed4(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance8 = {
  _A: (_) => _,
  _E: (_) => _
};
var isExit = (u) => hasProperty(u, TExitTypeId);
var isSuccess3 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail15 = (error4) => ({
  [TExitTypeId]: variance8,
  _tag: OP_FAIL5,
  error: error4,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error4)), cached(this));
  },
  [symbol2](that) {
    return isExit(that) && that._tag === OP_FAIL5 && equals(error4, that.error);
  }
});
var die7 = (defect) => ({
  [TExitTypeId]: variance8,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId2) => ({
  [TExitTypeId]: variance8,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId2,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId2)), cached(this));
  },
  [symbol2](that) {
    return isExit(that) && that._tag === OP_INTERRUPT3 && equals(fiberId2, that.fiberId);
  }
});
var succeed14 = (value) => ({
  [TExitTypeId]: variance8,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry3 = {
  [TExitTypeId]: variance8,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit(that) && isRetry(that);
  }
};

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend7 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make52 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class STMPrimitive {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var unsafeAtomically = (self, onDone, onInterrupt2) => withFiberRuntime((state) => {
  const fiberId2 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId2, self, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make52();
      const state2 = {
        value: running3
      };
      const effect3 = async((k) => tryCommitAsync(fiberId2, self, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause2((cause2) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt2();
        return failCause7(cause2);
      })));
    }
  }
});
var tryCommit = (fiberId2, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId2, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause2 = fail5(tExit.error);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause2 = die4(tExit.defect);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause2 = interrupt5(fiberId2);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitSync = (fiberId2, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId2, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess3(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause2 = fail5(tExit.error);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause2 = die4(tExit.defect);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause2 = interrupt5(fiberId2);
      return completeTodos(failCause4(cause2), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitAsync = (fiberId2, self, txnId, state, context5, scheduler, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId2, self, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId2, self, txnId, state, context5, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit3);
};
var completeTryCommit = (exit3, k) => {
  k(exit3);
};
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self, journal, fiberId2, r0) {
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId2;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail16(current.left);
              break;
            }
            case "None": {
              curr = fail16(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed15(current.right);
              break;
            }
            case "Some": {
              curr = succeed15(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die7(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail15(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry3;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die8(e);
      }
    }
    return exit3;
  }
}
var catchAll5 = /* @__PURE__ */ dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die8 = (defect) => dieSync3(() => defect);
var dieSync3 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed15(f(_.journal, _.fiberId, _.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self, finalizer) => matchSTM(self, {
  onFailure: (e) => zipRight6(finalizer, fail16(e)),
  onSuccess: (a) => zipRight6(finalizer, succeed15(a))
}));
var fail16 = (error4) => failSync5(() => error4);
var failSync5 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map24(right2), catchAll5((e) => pipe(onFailure(e), map24(left2))), flatMap13((either5) => {
  switch (either5._tag) {
    case "Left": {
      return succeed15(either5.left);
    }
    case "Right": {
      return onSuccess(either5.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId2) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId2;
  return stm;
};
var map24 = /* @__PURE__ */ dual(2, (self, f) => pipe(self, flatMap13((a) => sync7(() => f(a)))));
var retry4 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed15 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync7 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var zipRight6 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, flatMap13(() => that)));
var zipWith9 = /* @__PURE__ */ dual(3, (self, that, f) => pipe(self, flatMap13((a) => pipe(that, map24((b) => f(a, b))))));

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/effect/dist/esm/internal/stm/stm.js
var flatten13 = (self) => flatMap13(self, identity);
var forEach10 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options3) => {
  if (options3?.discard) {
    return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap13((iterator) => {
      const loop2 = suspend8(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_6;
        }
        return pipe(f(next4.value), flatMap13(() => loop2));
      });
      return loop2;
    }));
  }
  return suspend8(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array7, elem) => {
    array7.push(elem);
    return array7;
  }), succeed15([])));
});
var suspend8 = (evaluate2) => flatten13(sync7(evaluate2));
var void_6 = /* @__PURE__ */ succeed15(undefined);

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  _A: (_) => _
};

class TRefImpl {
  [TRefTypeId] = tRefVariance;
  todos;
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = new Map;
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make51(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet8 = /* @__PURE__ */ dual(2, (self, journal) => unsafeGet7(getOrMakeEntry(self, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self, value, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet(entry, value);
  return;
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  _Out: (_) => _
};
var tEnqueueVariance = {
  _In: (_) => _
};

class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed15(queue.length);
  });
  isFull = /* @__PURE__ */ map24(this.size, (size15) => size15 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map24(this.size, (size15) => size15 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    unsafeSet2(this.ref, undefined, runtime5.journal);
    return void_6;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry4);
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet8(runtime5.journal));
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed15(true);
          }
          queue.shift();
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as6 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as6.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as6], runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    return succeed15(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed15(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime5.journal);
    return succeed15(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    unsafeSet2(this.ref, [], runtime5.journal);
    return succeed15(queue);
  });
  takeUpTo(max6) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max6);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed15(Array.from(toTake));
    });
  }
}

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head4, subscribers, tail) => ({
  head: head4,
  subscribers,
  tail
});

class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
    if (currentPublisherTail === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed15(unsafeGet8(this.pubsubSize, runtime5.journal));
  });
  isEmpty = /* @__PURE__ */ map24(this.size, (size15) => size15 === 0);
  isFull = /* @__PURE__ */ map24(this.size, (size15) => size15 === this.capacity());
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed15(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(undefined);
        const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime5.journal);
            let loop2 = true;
            while (loop2) {
              const node = unsafeGet8(currentPublisherHead, runtime5.journal);
              if (node === undefined) {
                return retry4;
              }
              const head4 = node.head;
              const tail = node.tail;
              if (head4 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail, runtime5.journal);
                loop2 = false;
              } else {
                currentPublisherHead = tail;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map24(forEach10(iterable, (a) => this.offer(a)), every(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== undefined) {
      unsafeSet2(this.publisherTail, undefined, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach3(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, undefined, journal);
      });
      unsafeSet2(this.subscribers, empty8(), journal);
    }
  });
}

class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let loop2 = true;
    let size15 = 0;
    while (loop2) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        loop2 = false;
      } else {
        const head4 = node.head;
        const tail = node.tail;
        if (head4 !== AbsentValue2) {
          size15 = size15 + 1;
          if (size15 >= Number.MAX_SAFE_INTEGER) {
            loop2 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed15(size15);
  });
  isEmpty = /* @__PURE__ */ map24(this.size, (size15) => size15 === 0);
  isFull = /* @__PURE__ */ map24(this.size, (size15) => size15 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop2 = true;
    while (loop2) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry4;
      }
      const head4 = node.head;
      const tail = node.tail;
      if (head4 !== AbsentValue2) {
        value = head4;
        loop2 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed15(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = none2();
    let loop2 = true;
    while (loop2) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        value = none2();
        loop2 = false;
      } else {
        const head4 = node.head;
        const tail = node.tail;
        if (head4 !== AbsentValue2) {
          value = some2(head4);
          loop2 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed15(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      unsafeSet2(this.subscriberHead, undefined, journal);
      let loop2 = true;
      while (loop2) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === undefined) {
          loop2 = false;
        } else {
          const head4 = node.head;
          const tail = node.tail;
          if (head4 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size15 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size15 - 1, journal);
            } else {
              const updatedNode = makeNode2(head4, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop2 = true;
    while (loop2) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry4;
      }
      const head4 = node.head;
      const tail = node.tail;
      if (head4 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size15 = unsafeGet8(this.pubsubSize, runtime5.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherHead, tail, runtime5.journal);
          unsafeSet2(this.pubsubSize, size15 - 1, runtime5.journal);
        } else {
          const updatedNode = makeNode2(head4, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime5.journal);
        value = head4;
        loop2 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed15(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max6) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max6) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          n = max6;
        } else {
          const head4 = node.head;
          const tail = node.tail;
          if (head4 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size15 = unsafeGet8(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail, runtime5.journal);
              unsafeSet2(this.pubsubSize, size15 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head4, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head4);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed15(builder);
    });
  }
}

// node_modules/effect/dist/esm/internal/stream/emit.js
var make54 = (emit) => {
  const ops = {
    chunk(as6) {
      return this(succeed8(as6));
    },
    die(defect) {
      return this(die5(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit3) {
      return this(suspend3(() => mapBoth2(exit3, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail8(none2()));
    },
    fail(e) {
      return this(fail8(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth3(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError2(some2)));
    },
    halt(cause2) {
      return this(failCause7(pipe(cause2, map12(some2))));
    },
    single(value) {
      return this(succeed8(of2(value)));
    }
  };
  return Object.assign(emit, ops);
};

// node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  _A: (_) => _,
  _E: (_) => _
};

class TakeImpl {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit3) {
    this.exit = exit3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var chunk3 = (chunk4) => new TakeImpl(succeed4(chunk4));
var done10 = (self) => suspend3(() => self.exit);
var end3 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
var failCause10 = (cause2) => new TakeImpl(failCause4(pipe(cause2, map12(some2))));
var fromPull = (pull) => matchCause2(pull, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: () => end3,
    onSome: failCause10
  }),
  onSuccess: chunk3
});
var match19 = /* @__PURE__ */ dual(2, (self, {
  onEnd,
  onFailure,
  onSuccess
}) => match9(self.exit, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: onEnd,
    onSome: onFailure
  }),
  onSuccess
}));

// node_modules/effect/dist/esm/internal/stream/pull.js
var end4 = () => fail8(none2());

// node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class StreamImpl {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded6();
  } else if (typeof bufferSize === "number" || bufferSize === undefined) {
    return bounded4(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping3(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding3(bufferSize.bufferSize ?? 16);
    default:
      return bounded4(bufferSize.bufferSize ?? 16);
  }
};
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown3(queue)), flatMap9((output) => pipe(runtime4(), flatMap9((runtime5) => pipe(register(make54((k) => pipe(fromPull(k), flatMap9((take7) => offer3(output, take7)), asVoid2, runPromiseExit(runtime5)).then((exit3) => {
  if (isFailure(exit3)) {
    if (!isInterrupted2(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), zipRight3(make26(false)), flatMap9((ref) => pipe(get10(ref), map15((isDone7) => isDone7 ? end4() : pipe(take3(output), flatMap9(done10), onError2(() => pipe(set5(ref, true), zipRight3(shutdown3(output)))))))))))), scoped5, flatMap15(repeatEffectChunkOption));
var bufferChunks = /* @__PURE__ */ dual(2, (self, options3) => {
  if (options3.strategy === "dropping") {
    return bufferChunksDropping(self, options3.capacity);
  } else if (options3.strategy === "sliding") {
    return bufferChunksSliding(self, options3.capacity);
  }
  const queue = toQueue(self, options3);
  return new StreamImpl(unwrapScoped2(map15(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap12(match19({
      onEnd: () => void_5,
      onFailure: failCause9,
      onSuccess: (value) => pipe(write(value), flatMap12(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity6) => {
  const queue = acquireRelease2(dropping3(capacity6), (queue2) => shutdown3(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity6) => {
  const queue = acquireRelease2(sliding3(capacity6), (queue2) => shutdown3(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferSignal = (scoped5, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take7) => pipe(get10(ref), tap2(_await), zipRight3(make24()), flatMap9((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight3(set5(ref, deferred)), zipRight3(_await(deferred)))), asVoid2, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make24(), flatMap9((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap9((added) => pipe(set5(ref, deferred), when2(() => added))))), asVoid2, fromEffect4, flatMap12(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause10(error4)),
      onDone: () => terminate(end3)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take3(queue)), flatMap12(([take7, deferred]) => zipRight4(fromEffect4(succeed2(deferred, undefined)), match19(take7, {
      onEnd: () => void_5,
      onFailure: failCause9,
      onSuccess: (value) => pipe(write(value), flatMap12(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped2(pipe(scoped5, flatMap9((queue) => pipe(make24(), tap2((start3) => succeed2(start3, undefined)), flatMap9((start3) => pipe(make26(start3), flatMap9((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as3(consumer(queue))))))));
};
var flatMap15 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options3) => {
  const bufferSize = options3?.bufferSize ?? 16;
  if (options3?.switch) {
    return matchConcurrency(options3?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options3?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as6) => pipe(as6, map4((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options3))));
});
var matchConcurrency = (concurrency, sequential5, bounded8) => {
  switch (concurrency) {
    case undefined:
      return sequential5();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten14 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options3) => flatMap15(self, identity, options3));
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect7(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromEffect7 = (effect4) => pipe(effect4, mapError2(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap2(match12(effect4, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail14
  }),
  onSuccess: (a) => write(of2(a))
})));
var mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map15(effect5, (chunk4) => some2([chunk4, effect5])), catchAll2(match2({
  onNone: () => succeed8(none2()),
  onSome: fail8
}))));
var run3 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self) => run3(self, collectAll());
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap12(write(chunk3(input)), () => writer),
    onFailure: (cause2) => write(failCause10(cause2)),
    onDone: () => write(end3)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid2);
});
var scoped5 = (effect4) => new StreamImpl(ensuring3(scoped4(pipe(effect4, map15(of2))), _void));
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var suspend9 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream())));
var toQueue = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options3) => tap2(acquireRelease2(options3?.strategy === "unbounded" ? unbounded6() : options3?.strategy === "dropping" ? dropping3(options3.capacity ?? 2) : options3?.strategy === "sliding" ? sliding3(options3.capacity ?? 2) : bounded4(options3?.capacity ?? 2), (queue) => shutdown3(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var transduce = /* @__PURE__ */ dual(2, (self, sink) => {
  const newChannel = suspend5(() => {
    const leftovers = {
      ref: empty5()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer = suspend5(() => {
      const leftover = leftovers.ref;
      if (isEmpty(leftover)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap12(() => buffer)),
          onFailure: fail14,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty5();
      return pipe(writeChunk(leftover), flatMap12(() => buffer));
    });
    const concatAndGet = (chunk4) => {
      const leftover = leftovers.ref;
      const concatenated = appendAll2(leftover, filter3(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap12(write(input), () => upstreamMarker),
      onFailure: fail14,
      onDone: (done11) => zipRight4(sync5(() => {
        upstreamDone.ref = true;
      }), succeedNow(done11))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap12(([leftover, z]) => pipe(succeed12([upstreamDone.ref, concatAndGet(leftover)]), flatMap12(([done11, newLeftovers]) => {
      const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap12(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var unfoldChunkEffect = (s, f) => suspend9(() => {
  const loop2 = (s2) => unwrap2(map15(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk4, s3]) => flatMap12(write(chunk4), () => loop2(s3))
  })));
  return new StreamImpl(loop2(s));
});
var unwrap3 = (effect4) => flatten14(fromEffect7(effect4));
var unwrapScoped4 = (effect4) => flatten14(scoped5(effect4));

// node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var flatMap16 = flatMap12;
var suspend10 = suspend5;
var void_7 = void_5;
var write2 = write;
var zipRight8 = zipRight4;

// node_modules/effect/dist/esm/Sink.js
var drain3 = drain2;
var foldLeftChunks2 = foldLeftChunks;
var forEach11 = forEach9;
var fromChannel3 = fromChannel;
var unwrapScoped5 = unwrapScoped3;

// node_modules/effect/dist/esm/Stream.js
var asyncScoped2 = asyncScoped;
var bufferChunks2 = bufferChunks;
var fromChannel4 = fromChannel2;
var mapChunks2 = mapChunks;
var run4 = run3;
var runCollect3 = runCollect;
var splitLines3 = splitLines2;
var transduce2 = transduce;
var unwrap5 = unwrap3;
var unwrapScoped6 = unwrapScoped4;

// node_modules/@effect/platform/dist/esm/internal/error.js
var PlatformErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Error/PlatformErrorTypeId");
var make58 = (tag) => (props) => struct2({
  [PlatformErrorTypeId]: PlatformErrorTypeId,
  _tag: tag,
  ...props
});
var badArgument = /* @__PURE__ */ make58("BadArgument");
var systemError = /* @__PURE__ */ make58("SystemError");

// node_modules/@effect/platform/dist/esm/Error.js
var BadArgument = badArgument;
var SystemError = systemError;

// node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
var make59 = (impl) => {
  return tag.of({
    ...impl,
    exists: (path) => pipe(impl.access(path), as3(true), catchTag2("SystemError", (e) => e.reason === "NotFound" ? succeed8(false) : fail8(e))),
    readFileString: (path, encoding) => tryMap2(impl.readFile(path), {
      try: (_) => new TextDecoder(encoding).decode(_),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "readFileString",
        message: "invalid encoding"
      })
    }),
    stream: (path, options3) => pipe(impl.open(path, {
      flag: "r"
    }), options3?.offset ? tap2((file) => file.seek(options3.offset, "start")) : identity, map15((file) => stream(file, options3)), unwrapScoped6),
    sink: (path, options3) => pipe(impl.open(path, {
      flag: "w",
      ...options3
    }), map15((file) => forEach11((_) => file.writeAll(_))), unwrapScoped5),
    writeFileString: (path, data, options3) => flatMap9(try_2({
      try: () => new TextEncoder().encode(data),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "writeFileString",
        message: "could not encode string"
      })
    }), (_) => impl.writeFile(path, _, options3))
  });
};
var stream = (file, {
  bufferSize = 16,
  bytesToRead: bytesToRead_,
  chunkSize: chunkSize_ = Size(64 * 1024)
} = {}) => {
  const bytesToRead = bytesToRead_ !== undefined ? Size(bytesToRead_) : undefined;
  const chunkSize = Size(chunkSize_);
  function loop2(totalBytesRead) {
    if (bytesToRead !== undefined && bytesToRead <= totalBytesRead) {
      return void_7;
    }
    const toRead = bytesToRead !== undefined && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
    return flatMap16(file.readAlloc(toRead), match2({
      onNone: () => void_7,
      onSome: (buf) => flatMap16(write2(of2(buf)), (_) => loop2(totalBytesRead + BigInt(buf.length)))
    }));
  }
  return bufferChunks2(fromChannel4(loop2(BigInt(0))), {
    capacity: bufferSize
  });
};

// node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag;
var make60 = make59;
var FileTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/FileSystem/File");
var FileDescriptor = /* @__PURE__ */ nominal();
var WatchEventCreate = /* @__PURE__ */ tagged2("Create");
var WatchEventUpdate = /* @__PURE__ */ tagged2("Update");
var WatchEventRemove = /* @__PURE__ */ tagged2("Remove");

class WatchBackend extends (/* @__PURE__ */ Tag2("@effect/platform/FileSystem/WatchBackend")()) {
}

// node_modules/@effect/cli/dist/esm/internal/files.js
var Ini = __toESM(require_ini(), 1);
var Toml = __toESM(require_toml(), 1);

// node_modules/yaml/dist/index.js
var composer = require_composer();
var Document = require_Document();
var Schema = require_Schema();
var errors = require_errors();
var Alias = require_Alias();
var identity3 = require_identity();
var Pair = require_Pair();
var Scalar = require_Scalar();
var YAMLMap = require_YAMLMap();
var YAMLSeq = require_YAMLSeq();
var cst = require_cst();
var lexer = require_lexer();
var lineCounter = require_line_counter();
var parser = require_parser2();
var publicApi = require_public_api();
var visit = require_visit();
var $Composer = composer.Composer;
var $Document = Document.Document;
var $Schema = Schema.Schema;
var $YAMLError = errors.YAMLError;
var $YAMLParseError = errors.YAMLParseError;
var $YAMLWarning = errors.YAMLWarning;
var $Alias = Alias.Alias;
var $isAlias = identity3.isAlias;
var $isCollection = identity3.isCollection;
var $isDocument = identity3.isDocument;
var $isMap = identity3.isMap;
var $isNode = identity3.isNode;
var $isPair = identity3.isPair;
var $isScalar = identity3.isScalar;
var $isSeq = identity3.isSeq;
var $Pair = Pair.Pair;
var $Scalar = Scalar.Scalar;
var $YAMLMap = YAMLMap.YAMLMap;
var $YAMLSeq = YAMLSeq.YAMLSeq;
var $Lexer = lexer.Lexer;
var $LineCounter = lineCounter.LineCounter;
var $Parser = parser.Parser;
var $parse = publicApi.parse;
var $parseAllDocuments = publicApi.parseAllDocuments;
var $parseDocument = publicApi.parseDocument;
var $stringify = publicApi.stringify;
var $visit = visit.visit;
var $visitAsync = visit.visitAsync;

// node_modules/effect/dist/esm/Redacted.js
var make61 = make46;

// node_modules/effect/dist/esm/BigDecimal.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId19]: TypeId19,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals4(this, that);
  },
  toString() {
    return `BigDecimal(${format4(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId19);
var make62 = (value2, scale) => {
  const o = Object.create(BigDecimalProto);
  o.value = value2;
  o.scale = scale;
  return o;
};
var unsafeMakeNormalized = (value2, scale) => {
  if (value2 !== bigint03 && value2 % bigint10 === bigint03) {
    throw new RangeError("Value must be normalized");
  }
  const o = make62(value2, scale);
  o.normalized = o;
  return o;
};
var bigint03 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero2 = /* @__PURE__ */ unsafeMakeNormalized(bigint03, 0);
var normalize = (self) => {
  if (self.normalized === undefined) {
    if (self.value === bigint03) {
      self.normalized = zero2;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1;i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value2 = BigInt(digits.substring(0, digits.length - trail));
      const scale = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value2, scale);
    }
  }
  return self.normalized;
};
var scale = /* @__PURE__ */ dual(2, (self, scale2) => {
  if (scale2 > self.scale) {
    return make62(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make62(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
});
var abs = (n) => n.value < bigint03 ? make62(-n.value, n.scale) : n;
var Equivalence3 = /* @__PURE__ */ make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals4 = /* @__PURE__ */ dual(2, (self, that) => Equivalence3(self, that));
var format4 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint03;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before2 = absolute.slice(0, location);
    }
  }
  const complete3 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative ? `-${complete3}` : complete3;
};
var toExponential = (n) => {
  if (isZero2(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head5 = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head5}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var isZero2 = (n) => n.value === bigint03;
var isNegative = (n) => n.value < bigint03;
// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

// node_modules/effect/dist/esm/Struct.js
var pick2 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
  const out = {};
  for (const k of keys5) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit2 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
  const out = {
    ...s
  };
  for (const k of keys5) {
    delete out[k];
  }
  return out;
});

// node_modules/effect/dist/esm/Schema.js
var TypeId20 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make64(ast) {
  return class SchemaClass {
    [TypeId20] = variance9;
    static ast = ast;
    static annotations(annotations2) {
      return make64(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId20] = variance9;
  };
}
var variance9 = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations2[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
var decodeUnknown3 = (schema, options3) => {
  const decodeUnknown4 = decodeUnknown2(schema, options3);
  return (u, overrideOptions) => mapError3(decodeUnknown4(u, overrideOptions), parseError);
};
var isSchema = (u) => hasProperty(u, TypeId20) && isObject(u[TypeId20]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make64(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options3, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options3.decode(...typeParameters2.map(make64)), (...typeParameters2) => options3.encode(...typeParameters2.map(make64)), toASTAnnotations(annotations2)));
var declarePrimitive = (is2, annotations2) => {
  const decodeUnknown4 = () => (input, _, ast) => is2(input) ? succeed10(input) : fail12(new Type2(ast, input));
  const encodeUnknown2 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown2, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make64(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options3 = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options3, annotations3);
  }
  const is2 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is2, annotations2);
};
class Never extends (/* @__PURE__ */ make64(neverKeyword)) {
}
class String$ extends (/* @__PURE__ */ make64(stringKeyword)) {
}

class Number$ extends (/* @__PURE__ */ make64(numberKeyword)) {
}
var compose3 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose(from.ast, to.ast)));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter10, ast) {
  return class RefineClass extends make64(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter10;
    static make = (a, options3) => {
      return getDisableValidationMakeOption(options3) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter10(predicate, annotations2) {
  return (self) => {
    function filter11(input, options3, ast2) {
      return toFilterParseIssue(predicate(input, options3, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter11, toASTAnnotations(annotations2));
    return makeRefineClass(self, filter11, ast);
  };
}
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make64(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options3.decode, options3.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed10(options3.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed10(options3.encode(toI, toA))
}));
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations2) => (self) => {
  const source = regex.source;
  return self.pipe(filter10((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations2
  }));
};
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var IntSchemaId2 = IntSchemaId;
var int = (annotations2) => (self) => self.pipe(filter10((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations2
}));
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption3(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed10(String(a))
  });
}

class NumberFromString extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
}
class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
}
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations2) => (self) => self.pipe(filter10((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations2
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date2) => `new Date(${JSON.stringify(date2)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}
class DateFromString extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
}

class Date$ extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
}
function getDisableValidationMakeOption(options3) {
  return isBoolean(options3) ? options3 : options3?.disableValidation ?? false;
}

// node_modules/effect/dist/esm/Secret.js
var fromString4 = fromString;

// node_modules/@effect/platform/dist/esm/internal/terminal.js
var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/Terminal");

// node_modules/@effect/platform/dist/esm/Terminal.js
class QuitException extends (/* @__PURE__ */ TaggedError("QuitException")) {
}
var Terminal = tag2;

// node_modules/@effect/cli/dist/esm/internal/prompt/action.js
var Action = /* @__PURE__ */ taggedEnum();

// node_modules/@effect/cli/dist/esm/internal/prompt.js
var PromptSymbolKey = "@effect/cli/Prompt";
var PromptTypeId = /* @__PURE__ */ Symbol.for(PromptSymbolKey);
var proto18 = {
  ...CommitPrototype2,
  [PromptTypeId]: {
    _Output: (_) => _
  },
  commit() {
    return run5(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrompt = (u) => typeof u === "object" && u != null && (PromptTypeId in u);
var custom2 = (initialState, handlers) => {
  const op = Object.create(proto18);
  op._tag = "Loop";
  op.initialState = initialState;
  op.render = handlers.render;
  op.process = handlers.process;
  op.clear = handlers.clear;
  return op;
};
var map27 = /* @__PURE__ */ dual(2, (self, f) => flatMap18(self, (a) => succeed18(f(a))));
var flatMap18 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto18);
  op._tag = "OnSuccess";
  op.prompt = self;
  op.onSuccess = f;
  return op;
});
var run5 = (self) => flatMap9(Terminal, (terminal) => {
  const op = self;
  switch (op._tag) {
    case "Loop": {
      const makeStateRef = isEffect2(op.initialState) ? op.initialState.pipe(flatMap9(make26)) : make26(op.initialState);
      return makeStateRef.pipe(flatMap9((ref) => {
        const loop2 = (action) => get10(ref).pipe(flatMap9((state) => op.render(state, action).pipe(flatMap9((msg) => orDie2(terminal.display(msg))), zipRight3(terminal.readInput), flatMap9((input) => op.process(input, state)), flatMap9((action2) => {
          switch (action2._tag) {
            case "Beep": {
              return loop2(action2);
            }
            case "NextFrame": {
              return op.clear(state, action2).pipe(flatMap9((clear2) => orDie2(terminal.display(clear2))), zipRight3(set5(ref, action2.state)), zipRight3(loop2(action2)));
            }
            case "Submit": {
              return op.clear(state, action2).pipe(flatMap9((clear2) => orDie2(terminal.display(clear2))), zipRight3(op.render(state, action2)), flatMap9((msg) => orDie2(terminal.display(msg))), zipRight3(succeed8(action2.value)));
            }
          }
        }))));
        return get10(ref).pipe(flatMap9((state) => loop2(Action.NextFrame({
          state
        }))));
      }), ensuring2(orDie2(terminal.display(render4(cursorShow3, {
        style: "pretty"
      })))));
    }
    case "OnSuccess": {
      return flatMap9(run5(op.prompt), (a) => run5(op.onSuccess(a)));
    }
    case "Succeed": {
      return succeed8(op.value);
    }
  }
});
var succeed18 = (value4) => {
  const op = Object.create(proto18);
  op._tag = "Succeed";
  op.value = value4;
  return op;
};

// node_modules/effect/dist/esm/internal/matcher.js
var TypeId21 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId21]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId21]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value4) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value4;
  return matcher;
}
var makeWhen = (guard, evaluate2) => ({
  _tag: "When",
  guard,
  evaluate: evaluate2
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0;i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p3]) => [k, makePredicate(p3)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0;i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var value4 = (i) => makeValueMatcher(i, left2(i));
var when4 = (pattern2, f) => (self) => self.add(makeWhen(makePredicate(pattern2), f));
var orElse12 = (f) => (self) => {
  const result = either6(self);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var either6 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0;i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
};

// node_modules/effect/dist/esm/Match.js
var value5 = value4;
var when5 = when4;
var orElse13 = orElse12;

// node_modules/@effect/cli/dist/esm/internal/prompt/ansi-utils.js
var defaultFigures = {
  arrowUp: /* @__PURE__ */ text3("\u2191"),
  arrowDown: /* @__PURE__ */ text3("\u2193"),
  arrowLeft: /* @__PURE__ */ text3("\u2190"),
  arrowRight: /* @__PURE__ */ text3("\u2192"),
  radioOn: /* @__PURE__ */ text3("\u25C9"),
  radioOff: /* @__PURE__ */ text3("\u25EF"),
  checkboxOn: /* @__PURE__ */ text3("\u2612"),
  checkboxOff: /* @__PURE__ */ text3("\u2610"),
  tick: /* @__PURE__ */ text3("\u2714"),
  cross: /* @__PURE__ */ text3("\u2716"),
  ellipsis: /* @__PURE__ */ text3("\u2026"),
  pointerSmall: /* @__PURE__ */ text3("\u203A"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3("\u276F")
};
var windowsFigures = {
  arrowUp: defaultFigures.arrowUp,
  arrowDown: defaultFigures.arrowDown,
  arrowLeft: defaultFigures.arrowLeft,
  arrowRight: defaultFigures.arrowRight,
  radioOn: /* @__PURE__ */ text3("(*)"),
  radioOff: /* @__PURE__ */ text3("( )"),
  checkboxOn: /* @__PURE__ */ text3("[*]"),
  checkboxOff: /* @__PURE__ */ text3("[ ]"),
  tick: /* @__PURE__ */ text3("\u221A"),
  cross: /* @__PURE__ */ text3("\xD7"),
  ellipsis: /* @__PURE__ */ text3("..."),
  pointerSmall: /* @__PURE__ */ text3("\xBB"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3(">")
};
var figures = /* @__PURE__ */ map15(/* @__PURE__ */ sync3(() => process.platform === "win32"), (isWindows) => isWindows ? windowsFigures : defaultFigures);
function eraseText(text5, columns) {
  if (columns === 0) {
    return cat2(eraseLine3, cursorTo3(0));
  }
  let rows = 0;
  const lines = text5.split(/\r?\n/);
  for (const line4 of lines) {
    rows += 1 + Math.floor(Math.max(line4.length - 1, 0) / columns);
  }
  return eraseLines3(rows);
}
function lines(prompt2, columns) {
  const lines2 = prompt2.split(/\r?\n/);
  return columns === 0 ? lines2.length : pipe(map3(lines2, (line4) => Math.ceil(line4.length / columns)), reduce(0, (left3, right3) => left3 + right3));
}

// node_modules/@effect/cli/dist/esm/internal/prompt/date.js
var renderBeep = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty36,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX = /\r?\n/;
function renderError(state, pointer) {
  return match2(state.error, {
    onNone: () => empty36,
    onSome: (error4) => {
      const errorLines = error4.split(NEWLINE_REGEX);
      if (isNonEmptyReadonlyArray(errorLines)) {
        const annotateLine = (line4) => annotate2(text3(line4), combine13(italicized2, red4));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines2 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
      return empty36;
    }
  });
}
function renderParts(state, submitted = false) {
  return reduce(state.dateParts, empty36, (doc, part, currentIndex) => {
    const partDoc = text3(part.toString());
    if (currentIndex === state.cursor && !submitted) {
      const annotation = combine13(underlined2, cyanBright2);
      return cat2(doc, annotate2(partDoc, annotation));
    }
    return cat2(doc, partDoc);
  });
}
function renderOutput(leadingSymbol, trailingSymbol, parts2, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, parts2]),
    onNonEmpty: (promptLines) => {
      const lines2 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(parts2));
    }
  });
}
function renderNextFrame(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const parts2 = renderParts(state);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    const errorMsg = renderError(state, figures2.pointerSmall);
    return cursorHide3.pipe(cat2(promptMsg), cat2(errorMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const parts2 = renderParts(state, true);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processUp(state) {
  state.dateParts[state.cursor].increment();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processDown(state) {
  state.dateParts[state.cursor].decrement();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processCursorLeft(state) {
  const previousPart = state.dateParts[state.cursor].previousPart();
  return match2(previousPart, {
    onNone: () => Action.Beep(),
    onSome: (previous2) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(previous2)
      }
    })
  });
}
function processCursorRight(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  return match2(nextPart, {
    onNone: () => Action.Beep(),
    onSome: (next4) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(next4)
      }
    })
  });
}
function processNext(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  const cursor = match2(nextPart, {
    onNone: () => state.dateParts.findIndex((part) => !part.isToken()),
    onSome: (next4) => state.dateParts.indexOf(next4)
  });
  return Action.NextFrame({
    state: {
      ...state,
      cursor
    }
  });
}
function defaultProcessor(value6, state) {
  if (/\d/.test(value6)) {
    const typed = state.typed + value6;
    state.dateParts[state.cursor].setValue(typed);
    return Action.NextFrame({
      state: {
        ...state,
        typed
      }
    });
  }
  return Action.Beep();
}
var defaultLocales = {
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
};
function handleRender(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep),
      NextFrame: ({
        state: state2
      }) => renderNextFrame(state2, options3),
      Submit: () => renderSubmission(state, options3)
    });
  };
}
function handleProcess(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "left": {
        return succeed8(processCursorLeft(state));
      }
      case "right": {
        return succeed8(processCursorRight(state));
      }
      case "k":
      case "up": {
        return succeed8(processUp(state));
      }
      case "j":
      case "down": {
        return succeed8(processDown(state));
      }
      case "tab": {
        return succeed8(processNext(state));
      }
      case "enter":
      case "return": {
        return match12(options3.validate(state.value), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              error: some2(error4)
            }
          }),
          onSuccess: (value6) => Action.Submit({
            value: value6
          })
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return succeed8(defaultProcessor(value6, state));
      }
    }
  };
}
var date2 = (options3) => {
  const opts = {
    initial: new Date,
    dateMask: "YYYY-MM-DD HH:mm:ss",
    validate: succeed8,
    ...options3,
    locales: {
      ...defaultLocales,
      ...options3.locales
    }
  };
  const dateParts = makeDateParts(opts.dateMask, opts.initial, opts.locales);
  const initialCursorPosition = dateParts.findIndex((part) => !part.isToken());
  const initialState = {
    dateParts,
    typed: "",
    cursor: initialCursorPosition,
    value: opts.initial,
    error: none2()
  };
  return custom2(initialState, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: handleClear(opts)
  });
};
var DATE_PART_REGEX = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
var regexGroups = {
  1: ({
    token,
    ...opts
  }) => new Token({
    token: token.replace(/\\(.)/g, "$1"),
    ...opts
  }),
  2: (opts) => new Day(opts),
  3: (opts) => new Month(opts),
  4: (opts) => new Year(opts),
  5: (opts) => new Meridiem(opts),
  6: (opts) => new Hours(opts),
  7: (opts) => new Minutes(opts),
  8: (opts) => new Seconds(opts),
  9: (opts) => new Milliseconds(opts)
};
var makeDateParts = (dateMask, date3, locales) => {
  const parts2 = [];
  let result = null;
  while (result = DATE_PART_REGEX.exec(dateMask)) {
    const match21 = result.shift();
    const index = result.findIndex((group4) => group4 !== undefined);
    if (index in regexGroups) {
      const token = result[index] || match21;
      parts2.push(regexGroups[index]({
        token,
        date: date3,
        parts: parts2,
        locales
      }));
    } else {
      parts2.push(new Token({
        token: result[index] || match21,
        date: date3,
        parts: parts2,
        locales
      }));
    }
  }
  const orderedParts = parts2.reduce((array9, element) => {
    const lastElement = array9[array9.length - 1];
    if (element.isToken() && lastElement !== undefined && lastElement.isToken()) {
      lastElement.setValue(element.token);
    } else {
      array9.push(element);
    }
    return array9;
  }, empty2());
  parts2.splice(0, parts2.length, ...orderedParts);
  return parts2;
};

class DatePart {
  token;
  date;
  parts;
  locales;
  constructor(params) {
    this.token = params.token;
    this.locales = params.locales;
    this.date = params.date || new Date;
    this.parts = params.parts || [this];
  }
  isToken() {
    return false;
  }
  nextPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findFirst2(this.parts.slice(currentPartIndex + 1), (part) => !part.isToken())));
  }
  previousPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findLast(this.parts.slice(0, currentPartIndex), (part) => !part.isToken())));
  }
  toString() {
    return String(this.date);
  }
}

class Token extends DatePart {
  increment() {}
  decrement() {}
  setValue(value6) {
    this.token = this.token + value6;
  }
  isToken() {
    return true;
  }
  toString() {
    return this.token;
  }
}

class Milliseconds extends DatePart {
  increment() {
    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
  }
  decrement() {
    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
  }
  setValue(value6) {
    this.date.setMilliseconds(Number.parseInt(value6.slice(-this.token.length)));
  }
  toString() {
    const millis2 = `${this.date.getMilliseconds()}`;
    return millis2.padStart(4, "0").substring(0, this.token.length);
  }
}

class Seconds extends DatePart {
  increment() {
    this.date.setSeconds(this.date.getSeconds() + 1);
  }
  decrement() {
    this.date.setSeconds(this.date.getSeconds() - 1);
  }
  setValue(value6) {
    this.date.setSeconds(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const seconds2 = `${this.date.getSeconds()}`;
    return this.token.length > 1 ? seconds2.padStart(2, "0") : seconds2;
  }
}

class Minutes extends DatePart {
  increment() {
    this.date.setMinutes(this.date.getMinutes() + 1);
  }
  decrement() {
    this.date.setMinutes(this.date.getMinutes() - 1);
  }
  setValue(value6) {
    this.date.setMinutes(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const minutes2 = `${this.date.getMinutes()}`;
    return this.token.length > 1 ? minutes2.padStart(2, "0") : minutes2;
  }
}

class Hours extends DatePart {
  increment() {
    this.date.setHours(this.date.getHours() + 1);
  }
  decrement() {
    this.date.setHours(this.date.getHours() - 1);
  }
  setValue(value6) {
    this.date.setHours(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const hours2 = /h/.test(this.token) ? this.date.getHours() % 12 || 12 : this.date.getHours();
    return this.token.length > 1 ? `${hours2}`.padStart(2, "0") : `${hours2}`;
  }
}

class Day extends DatePart {
  increment() {
    this.date.setDate(this.date.getDate() + 1);
  }
  decrement() {
    this.date.setDate(this.date.getDate() - 1);
  }
  setValue(value6) {
    this.date.setDate(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const date3 = this.date.getDate();
    const day = this.date.getDay();
    return value5(this.token).pipe(when5("DD", () => `${date3}`.padStart(2, "0")), when5("Do", () => `${date3}${this.ordinalIndicator(date3)}`), when5("d", () => `${day + 1}`), when5("ddd", () => this.locales.weekdaysShort[day]), when5("dddd", () => this.locales.weekdays[day]), orElse13(() => `${date3}`));
  }
  ordinalIndicator(day) {
    return value5(day % 10).pipe(when5(1, () => "st"), when5(2, () => "nd"), when5(3, () => "rd"), orElse13(() => "th"));
  }
}

class Month extends DatePart {
  increment() {
    this.date.setMonth(this.date.getMonth() + 1);
  }
  decrement() {
    this.date.setMonth(this.date.getMonth() - 1);
  }
  setValue(value6) {
    const month = Number.parseInt(value6.slice(-2)) - 1;
    this.date.setMonth(month < 0 ? 0 : month);
  }
  toString() {
    const month = this.date.getMonth();
    return value5(this.token.length).pipe(when5(2, () => `${month + 1}`.padStart(2, "0")), when5(3, () => this.locales.monthsShort[month]), when5(4, () => this.locales.months[month]), orElse13(() => `${month + 1}`));
  }
}

class Year extends DatePart {
  increment() {
    this.date.setFullYear(this.date.getFullYear() + 1);
  }
  decrement() {
    this.date.setFullYear(this.date.getFullYear() - 1);
  }
  setValue(value6) {
    this.date.setFullYear(Number.parseInt(value6.slice(-4)));
  }
  toString() {
    const year = `${this.date.getFullYear()}`.padStart(4, "0");
    return this.token.length === 2 ? year.substring(-2) : year;
  }
}

class Meridiem extends DatePart {
  increment() {
    this.date.setHours((this.date.getHours() + 12) % 24);
  }
  decrement() {
    this.increment();
  }
  setValue(_value) {}
  toString() {
    const meridiem = this.date.getHours() > 12 ? "pm" : "am";
    return /A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
  }
}

// node_modules/@effect/platform/dist/esm/internal/path.js
var TypeId22 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0;i <= path.length; ++i) {
    if (i < path.length) {
      code2 = path.charCodeAt(i);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  const dir2 = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir2) {
    return base;
  }
  if (dir2 === pathObject.root) {
    return dir2 + base;
  }
  return dir2 + sep + base;
}
function fromFileUrl(url2) {
  if (url2.protocol !== "file:") {
    return fail8(BadArgument({
      module: "Path",
      method: "fromFileUrl",
      message: "URL must be of scheme file"
    }));
  } else if (url2.hostname !== "") {
    return fail8(BadArgument({
      module: "Path",
      method: "fromFileUrl",
      message: "Invalid file URL host"
    }));
  }
  const pathname = url2.pathname;
  for (let n = 0;n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail8(BadArgument({
          module: "Path",
          method: "fromFileUrl",
          message: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed8(decodeURIComponent(pathname));
}
var resolve = function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd = undefined;
  for (let i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = arguments[i];
    } else {
      const process2 = globalThis.process;
      if (cwd === undefined && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
        cwd = process2.cwd();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
};
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed8(outURL);
}
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes(`
`)) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("\t")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId22]: TypeId22,
  resolve,
  normalize(path) {
    if (path.length === 0)
      return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute)
      return "/" + path;
    return path;
  },
  isAbsolute(path) {
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0;i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === undefined) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === undefined) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to)
      return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to)
      return "";
    let fromStart = 1;
    for (;fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (;toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length3 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (;i <= length3; ++i) {
      if (i === length3) {
        if (toLen > length3) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length3) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode3 = to.charCodeAt(toStart + i);
      if (fromCode !== toCode3) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path) {
    if (path.length === 0)
      return ".";
    let code2 = path.charCodeAt(0);
    const hasRoot = code2 === 47;
    let end6 = -1;
    let matchedSlash = true;
    for (let i = path.length - 1;i >= 1; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          end6 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end6 === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1)
      return "//";
    return path.slice(0, end6);
  },
  basename(path, ext) {
    let start3 = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1;i >= 0; --i) {
        const code2 = path.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end6 = i;
              }
            } else {
              extIdx = -1;
              end6 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end6)
        end6 = firstNonSlashEnd;
      else if (end6 === -1)
        end6 = path.length;
      return path.slice(start3, end6);
    } else {
      for (i = path.length - 1;i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
      }
      if (end6 === -1)
        return "";
      return path.slice(start3, end6);
    }
  },
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1;i >= 0; --i) {
      const code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end6);
  },
  format: function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse(path) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0)
      return ret;
    let code2 = path.charCodeAt(0);
    const isAbsolute = code2 === 47;
    let start3;
    if (isAbsolute) {
      ret.root = "/";
      start3 = 1;
    } else {
      start3 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (;i >= start3; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path.slice(1, end6);
        else
          ret.base = ret.name = path.slice(startPart, end6);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end6);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end6);
      }
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});

// node_modules/@effect/platform/dist/esm/Path.js
var TypeId23 = TypeId22;
var Path2 = Path;

// node_modules/@effect/cli/dist/esm/internal/prompt/utils.js
var entriesToDisplay = (cursor, total, maxVisible) => {
  const max7 = maxVisible === undefined ? total : maxVisible;
  let startIndex = Math.min(total - max7, cursor - Math.floor(max7 / 2));
  if (startIndex < 0) {
    startIndex = 0;
  }
  const endIndex = Math.min(startIndex + max7, total);
  return {
    startIndex,
    endIndex
  };
};

// node_modules/@effect/cli/dist/esm/internal/prompt/file.js
var CONFIRM_MESSAGE = "The selected directory contains files. Would you like to traverse the selected directory?";
var Confirm = /* @__PURE__ */ taggedEnum();
var showConfirmation = /* @__PURE__ */ Confirm.$is("Show");
var renderBeep2 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function resolveCurrentPath(path, options3) {
  return match2(path, {
    onNone: () => match2(options3.startingPath, {
      onNone: () => sync3(() => process.cwd()),
      onSome: (path2) => flatMap9(FileSystem, (fs) => orDie2(fs.exists(path2)).pipe(filterOrDieMessage2(identity, `The provided starting path '${path2}' does not exist`), as3(path2)))
    }),
    onSome: (path2) => succeed8(path2)
  });
}
function getFileList(directory, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path = yield* Path2;
    const files = yield* orDie2(fs.readDirectory(directory)).pipe(map15((files2) => ["..", ...files2]));
    return yield* filter8(files, (file) => {
      const result = options3.filter(file);
      const userDefinedFilter = isEffect2(result) ? result : succeed8(result);
      const directoryFilter = options3.type === "directory" ? map15(orDie2(fs.stat(path.join(directory, file))), (info2) => info2.type === "Directory") : succeed8(true);
      return zipWith6(userDefinedFilter, directoryFilter, (a, b) => a && b);
    }, {
      concurrency: files.length
    });
  });
}
function handleClear2(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const currentPath = yield* resolveCurrentPath(state.path, options3);
      const text5 = `
`.repeat(Math.min(state.files.length, options3.maxPerPage));
      const clearPath = eraseText(currentPath, columns);
      const message = showConfirmation(state.confirm) ? CONFIRM_MESSAGE : options3.message;
      const clearPrompt = eraseText(`
${message}`, columns);
      const clearOptions = eraseText(text5, columns);
      return clearOptions.pipe(cat2(clearPath), cat2(clearPrompt), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX2 = /\r?\n/;
function renderPrompt(confirm, message, leadingSymbol, trailingSymbol) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(message.split(NEWLINE_REGEX2), {
    onEmpty: () => hsep2([prefix, trailingSymbol, confirm]),
    onNonEmpty: (promptLines) => {
      const lines2 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(confirm));
    }
  });
}
function renderPrefix(state, toDisplay, currentIndex, length3, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < length3) {
    prefix = figures2.arrowDown;
  }
  return state.cursor === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderFileName(file, isSelected) {
  return isSelected ? annotate2(text3(file), combine13(underlined2, cyanBright2)) : text3(file);
}
function renderFiles(state, files, figures2, options3) {
  const length3 = files.length;
  const toDisplay = entriesToDisplay(state.cursor, length3, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex;index < toDisplay.endIndex; index++) {
    const isSelected = state.cursor === index;
    const prefix = renderPrefix(state, toDisplay, index, length3, figures2);
    const fileName = renderFileName(files[index], isSelected);
    documents.push(cat2(prefix, fileName));
  }
  return vsep2(documents);
}
function renderNextFrame2(state, options3) {
  return gen2(function* () {
    const path = yield* Path2;
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path.resolve(currentPath, selectedPath);
    const resolvedPathMsg = figures2.pointerSmall.pipe(cat2(space2), cat2(text3(resolvedPath)), annotate2(blackBright2));
    if (showConfirmation(state.confirm)) {
      const leadingSymbol2 = annotate2(text3("?"), cyanBright2);
      const trailingSymbol2 = annotate2(figures2.pointerSmall, blackBright2);
      const confirm = annotate2(text3("(Y/n)"), blackBright2);
      const promptMsg2 = renderPrompt(confirm, CONFIRM_MESSAGE, leadingSymbol2, trailingSymbol2);
      return cursorHide3.pipe(cat2(promptMsg2), cat2(hardLine2), cat2(resolvedPathMsg), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    }
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty36, options3.message, leadingSymbol, trailingSymbol);
    const files = renderFiles(state, state.files, figures2, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(resolvedPathMsg), cat2(hardLine2), cat2(files), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission2(value6, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty36, options3.message, leadingSymbol, trailingSymbol);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(text3(value6), white4)), cat2(hardLine2), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleRender2(options3) {
  return (_, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep2),
      NextFrame: ({
        state
      }) => renderNextFrame2(state, options3),
      Submit: ({
        value: value6
      }) => renderSubmission2(value6, options3)
    });
  };
}
function processCursorUp(state) {
  const cursor = state.cursor - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: cursor < 0 ? state.files.length - 1 : cursor
    }
  }));
}
function processCursorDown(state) {
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: (state.cursor + 1) % state.files.length
    }
  }));
}
function processSelection(state, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path = yield* Path2;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path.resolve(currentPath, selectedPath);
    const info2 = yield* orDie2(fs.stat(resolvedPath));
    if (info2.type === "Directory") {
      const files = yield* getFileList(resolvedPath, options3);
      const filesWithoutParent = files.filter((file) => file !== "..");
      if (options3.type === "directory" || options3.type === "either") {
        return filesWithoutParent.length === 0 ? Action.Submit({
          value: resolvedPath
        }) : Action.NextFrame({
          state: {
            ...state,
            confirm: Confirm.Show()
          }
        });
      }
      return Action.NextFrame({
        state: {
          cursor: 0,
          files,
          path: some2(resolvedPath),
          confirm: Confirm.Hide()
        }
      });
    }
    return Action.Submit({
      value: resolvedPath
    });
  });
}
function handleProcess2(options3) {
  return (input, state) => gen2(function* () {
    switch (input.key.name) {
      case "k":
      case "up": {
        return yield* processCursorUp(state);
      }
      case "j":
      case "down":
      case "tab": {
        return yield* processCursorDown(state);
      }
      case "enter":
      case "return": {
        return yield* processSelection(state, options3);
      }
      case "y":
      case "t": {
        if (showConfirmation(state.confirm)) {
          const path = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path.resolve(currentPath, selectedPath);
          const files = yield* getFileList(resolvedPath, options3);
          return Action.NextFrame({
            state: {
              cursor: 0,
              files,
              path: some2(resolvedPath),
              confirm: Confirm.Hide()
            }
          });
        }
        return Action.Beep();
      }
      case "n":
      case "f": {
        if (showConfirmation(state.confirm)) {
          const path = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path.resolve(currentPath, selectedPath);
          return Action.Submit({
            value: resolvedPath
          });
        }
        return Action.Beep();
      }
      default: {
        return Action.Beep();
      }
    }
  });
}
var file = (options3 = {}) => {
  const opts = {
    type: options3.type ?? "file",
    message: options3.message ?? `Choose a file`,
    startingPath: fromNullable(options3.startingPath),
    maxPerPage: options3.maxPerPage ?? 10,
    filter: options3.filter ?? (() => succeed8(true))
  };
  const initialState = gen2(function* () {
    const path = none2();
    const currentPath = yield* resolveCurrentPath(path, opts);
    const files = yield* getFileList(currentPath, opts);
    const confirm = Confirm.Hide();
    return {
      cursor: 0,
      files,
      path,
      confirm
    };
  });
  return custom2(initialState, {
    render: handleRender2(opts),
    process: handleProcess2(opts),
    clear: handleClear2(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/number.js
var parseInt2 = /* @__PURE__ */ NumberFromString.pipe(/* @__PURE__ */ int(), decodeUnknown3);
var parseFloat2 = /* @__PURE__ */ decodeUnknown3(NumberFromString);
var renderBeep3 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear3(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty36,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
function renderInput(state, submitted) {
  const annotation = match2(state.error, {
    onNone: () => combine13(underlined2, cyanBright2),
    onSome: () => red4
  });
  const value6 = state.value === "" ? empty36 : text3(`${state.value}`);
  return submitted ? value6 : annotate2(value6, annotation);
}
var NEWLINE_REGEX3 = /\r?\n/;
function renderError2(state, pointer) {
  return match2(state.error, {
    onNone: () => empty36,
    onSome: (error4) => match3(error4.split(NEWLINE_REGEX3), {
      onEmpty: () => empty36,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => annotate2(text3(line4), combine13(italicized2, red4));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines2 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput2(state, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, renderInput(state, submitted)]),
    onNonEmpty: (promptLines) => {
      const lines2 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput(state, submitted)));
    }
  });
}
function renderNextFrame3(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const errorMsg = renderError2(state, figures2.pointerSmall);
    const promptMsg = renderOutput2(state, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(errorMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission3(nextState, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput2(nextState, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace(state) {
  if (state.value.length <= 0) {
    return succeed8(Action.Beep());
  }
  const value6 = state.value.slice(0, state.value.length - 1);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value6,
      error: none2()
    }
  }));
}
function defaultIntProcessor(state, input) {
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match12(parseInt2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value6) => Action.NextFrame({
      state: {
        ...state,
        value: `${value6}`,
        error: none2()
      }
    })
  });
}
function defaultFloatProcessor(state, input) {
  if (input === "." && state.value.includes(".")) {
    return succeed8(Action.Beep());
  }
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match12(parseFloat2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value6) => Action.NextFrame({
      state: {
        ...state,
        value: input === "." ? `${value6}.` : `${value6}`,
        error: none2()
      }
    })
  });
}
var initialState = {
  cursor: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRenderInteger(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessInteger(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseInt(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseInt(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseInt2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide an integer value")
            }
          })),
          onSuccess: (n) => match12(options3.validate(n), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value6) => Action.Submit({
              value: value6
            })
          })
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultIntProcessor(state, value6);
      }
    }
  };
}
var integer2 = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderInteger(opts),
    process: handleProcessInteger(opts),
    clear: handleClear3(opts)
  });
};
function handleRenderFloat(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessFloat(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseFloat(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseFloat(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseFloat2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide a floating point value")
            }
          })),
          onSuccess: (n) => flatMap9(sync3(() => round(n, options3.precision)), (rounded) => match12(options3.validate(rounded), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value6) => Action.Submit({
              value: value6
            })
          }))
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultFloatProcessor(state, value6);
      }
    }
  };
}
var float = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    precision: 2,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderFloat(opts),
    process: handleProcessFloat(opts),
    clear: handleClear3(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/select.js
var renderBeep4 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
var NEWLINE_REGEX4 = /\r?\n/;
function renderOutput3(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX4), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines2 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2));
    }
  });
}
function renderChoicePrefix(state, choices, toDisplay, currentIndex, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < choices.length) {
    prefix = figures2.arrowDown;
  }
  if (choices[currentIndex].disabled) {
    const annotation = combine13(bold2, blackBright2);
    return state === currentIndex ? figures2.pointer.pipe(annotate2(annotation), cat2(prefix)) : prefix.pipe(cat2(space2));
  }
  return state === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderChoiceTitle(choice2, isSelected) {
  const title = text3(choice2.title);
  if (isSelected) {
    return choice2.disabled ? annotate2(title, combine13(underlined2, blackBright2)) : annotate2(title, combine13(underlined2, cyanBright2));
  }
  return choice2.disabled ? annotate2(title, combine13(strikethrough2, blackBright2)) : title;
}
function renderChoiceDescription(choice2, isSelected) {
  if (!choice2.disabled && choice2.description && isSelected) {
    return char3("-").pipe(cat2(space2), cat2(text3(choice2.description)), annotate2(blackBright2));
  }
  return empty36;
}
function renderChoices(state, options3, figures2) {
  const choices = options3.choices;
  const toDisplay = entriesToDisplay(state, choices.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex;index < toDisplay.endIndex; index++) {
    const choice2 = choices[index];
    const isSelected = state === index;
    const prefix = renderChoicePrefix(state, choices, toDisplay, index, figures2);
    const title = renderChoiceTitle(choice2, isSelected);
    const description = renderChoiceDescription(choice2, isSelected);
    documents.push(prefix.pipe(cat2(title), cat2(space2), cat2(description)));
  }
  return vsep2(documents);
}
function renderNextFrame4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const choices = renderChoices(state, options3, figures2);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(choices), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const selected = text3(options3.choices[state].title);
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(selected, white4)), cat2(hardLine2), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp2(state, choices) {
  if (state === 0) {
    return succeed8(Action.NextFrame({
      state: choices.length - 1
    }));
  }
  return succeed8(Action.NextFrame({
    state: state - 1
  }));
}
function processCursorDown2(state, choices) {
  if (state === choices.length - 1) {
    return succeed8(Action.NextFrame({
      state: 0
    }));
  }
  return succeed8(Action.NextFrame({
    state: state + 1
  }));
}
function processNext2(state, choices) {
  return succeed8(Action.NextFrame({
    state: (state + 1) % choices.length
  }));
}
function handleRender3(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep4),
      NextFrame: ({
        state: state2
      }) => renderNextFrame4(state2, options3),
      Submit: () => renderSubmission4(state, options3)
    });
  };
}
function handleClear4(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const text5 = `
`.repeat(Math.min(options3.choices.length, options3.maxPerPage)) + options3.message;
    const clearOutput = eraseText(text5, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess3(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp2(state, options3.choices);
      }
      case "j":
      case "down": {
        return processCursorDown2(state, options3.choices);
      }
      case "tab": {
        return processNext2(state, options3.choices);
      }
      case "enter":
      case "return": {
        const selected = options3.choices[state];
        if (selected.disabled) {
          return succeed8(Action.Beep());
        }
        return succeed8(Action.Submit({
          value: selected.value
        }));
      }
      default: {
        return succeed8(Action.Beep());
      }
    }
  };
}
var select = (options3) => {
  const opts = {
    maxPerPage: 10,
    ...options3
  };
  return custom2(0, {
    render: handleRender3(opts),
    process: handleProcess3(opts),
    clear: () => handleClear4(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/text.js
function getValue(state, options3) {
  return state.value.length > 0 ? state.value : options3.default;
}
var renderBeep5 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function renderClearScreen(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
    const clearError = match2(state.error, {
      onNone: () => empty36,
      onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
    });
    const clearOutput = eraseText(options3.message, columns);
    return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderInput2(nextState, options3, submitted) {
  const text5 = getValue(nextState, options3);
  const annotation = match2(nextState.error, {
    onNone: () => {
      if (submitted) {
        return white4;
      }
      if (nextState.value.length === 0) {
        return blackBright2;
      }
      return combine13(underlined2, cyanBright2);
    },
    onSome: () => red4
  });
  switch (options3.type) {
    case "hidden": {
      return empty36;
    }
    case "password": {
      return annotate2(text3("*".repeat(text5.length)), annotation);
    }
    case "text": {
      return annotate2(text3(text5), annotation);
    }
  }
}
function renderError3(nextState, pointer) {
  return match2(nextState.error, {
    onNone: () => empty36,
    onSome: (error4) => match3(error4.split(/\r?\n/), {
      onEmpty: () => empty36,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => text3(line4).pipe(annotate2(combine13(italicized2, red4)));
        const prefix = cat2(annotate2(pointer, red4), space2);
        const lines2 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput4(nextState, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines2 = map3(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput2(nextState, options3, submitted)));
  }
  return hsep2([prefix, trailingSymbol, renderInput2(nextState, options3, submitted)]);
}
function renderNextFrame5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3);
    const errorMsg = renderError3(state, figures2.pointerSmall);
    return promptMsg.pipe(cat2(errorMsg), cat2(cursorMove3(state.offset)), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const beforeCursor = state.value.slice(0, state.cursor - 1);
  const afterCursor = state.value.slice(state.cursor);
  const cursor = state.cursor - 1;
  const value6 = `${beforeCursor}${afterCursor}`;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value6,
      error: none2()
    }
  }));
}
function processCursorLeft2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const cursor = state.cursor - 1;
  const offset = state.offset - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processCursorRight2(state) {
  if (state.cursor >= state.value.length) {
    return succeed8(Action.Beep());
  }
  const cursor = Math.min(state.cursor + 1, state.value.length);
  const offset = Math.min(state.offset + 1, state.value.length);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processTab(state, options3) {
  if (state.value === options3.default) {
    return succeed8(Action.Beep());
  }
  const value6 = getValue(state, options3);
  const cursor = value6.length;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value6,
      cursor,
      error: none2()
    }
  }));
}
function defaultProcessor2(input, state) {
  const beforeCursor = state.value.slice(0, state.cursor);
  const afterCursor = state.value.slice(state.cursor);
  const value6 = `${beforeCursor}${input}${afterCursor}`;
  const cursor = beforeCursor.length + 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value6,
      error: none2()
    }
  }));
}
var initialState2 = {
  cursor: 0,
  offset: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRender4(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep5),
      NextFrame: ({
        state: state2
      }) => renderNextFrame5(state2, options3),
      Submit: () => renderSubmission5(state, options3)
    });
  };
}
function handleProcess4(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace2(state);
      }
      case "left": {
        return processCursorLeft2(state);
      }
      case "right": {
        return processCursorRight2(state);
      }
      case "enter":
      case "return": {
        const value6 = getValue(state, options3);
        return match12(options3.validate(value6), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              value: value6,
              error: some2(error4)
            }
          }),
          onSuccess: (value7) => Action.Submit({
            value: value7
          })
        });
      }
      case "tab": {
        return processTab(state, options3);
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultProcessor2(value6, state);
      }
    }
  };
}
function handleClear5(options3) {
  return (state, _) => {
    return renderClearScreen(state, options3);
  };
}
function basePrompt(options3, type2) {
  const opts = {
    default: "",
    type: type2,
    validate: succeed8,
    ...options3
  };
  return custom2(initialState2, {
    render: handleRender4(opts),
    process: handleProcess4(opts),
    clear: handleClear5(opts)
  });
}
var hidden = (options3) => basePrompt(options3, "hidden").pipe(map27(make61));
var text5 = (options3) => basePrompt(options3, "text");

// node_modules/@effect/cli/dist/esm/internal/prompt/toggle.js
var renderBeep6 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear6(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const clearOutput = eraseText(options3.message, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderToggle(value6, options3, submitted = false) {
  const separator = annotate2(char3("/"), blackBright2);
  const selectedAnnotation = combine13(underlined2, submitted ? white4 : cyanBright2);
  const inactive = value6 ? text3(options3.inactive) : annotate2(text3(options3.inactive), selectedAnnotation);
  const active2 = value6 ? annotate2(text3(options3.active), selectedAnnotation) : text3(options3.active);
  return hsep2([active2, separator, inactive]);
}
function renderOutput5(toggle2, leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines2 = map3(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(toggle2));
  }
  return hsep2([prefix, trailingSymbol, toggle2]);
}
function renderNextFrame6(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const toggle2 = renderToggle(state, options3);
    const promptMsg = renderOutput5(toggle2, leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission6(value6, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const toggle2 = renderToggle(value6, options3, true);
    const promptMsg = renderOutput5(toggle2, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
var activate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: true
}));
var deactivate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: false
}));
function handleRender5(options3) {
  return (state, action) => {
    switch (action._tag) {
      case "Beep": {
        return succeed8(renderBeep6);
      }
      case "NextFrame": {
        return renderNextFrame6(state, options3);
      }
      case "Submit": {
        return renderSubmission6(state, options3);
      }
    }
  };
}
function handleProcess5(input, state) {
  switch (input.key.name) {
    case "0":
    case "j":
    case "delete":
    case "right":
    case "down": {
      return deactivate;
    }
    case "1":
    case "k":
    case "left":
    case "up": {
      return activate;
    }
    case " ":
    case "tab": {
      return state ? deactivate : activate;
    }
    case "enter":
    case "return": {
      return succeed8(Action.Submit({
        value: state
      }));
    }
    default: {
      return succeed8(Action.Beep());
    }
  }
}
var toggle2 = (options3) => {
  const opts = {
    initial: false,
    active: "on",
    inactive: "off",
    ...options3
  };
  return custom2(opts.initial, {
    render: handleRender5(opts),
    process: handleProcess5,
    clear: () => handleClear6(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/primitive.js
var PrimitiveSymbolKey = "@effect/cli/Primitive";
var PrimitiveTypeId = /* @__PURE__ */ Symbol.for(PrimitiveSymbolKey);
var proto19 = {
  [PrimitiveTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrimitive = (u) => typeof u === "object" && u != null && (PrimitiveTypeId in u);
var isBool = (self) => isPrimitive(self) && isBoolType(self);
var isBoolType = (self) => self._tag === "Bool";
var trueValues = /* @__PURE__ */ Literal2("true", "1", "y", "yes", "on");
var isTrueValue = /* @__PURE__ */ is(trueValues);
var falseValues = /* @__PURE__ */ Literal2("false", "0", "n", "no", "off");
var isFalseValue = /* @__PURE__ */ is(falseValues);
var boolean4 = (defaultValue) => {
  const op = Object.create(proto19);
  op._tag = "Bool";
  op.defaultValue = defaultValue;
  return op;
};
var choice2 = (alternatives) => {
  const op = Object.create(proto19);
  op._tag = "Choice";
  op.alternatives = alternatives;
  return op;
};
var integer3 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Integer";
  return op;
})();
var text6 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Text";
  return op;
})();
var getChoices = (self) => getChoicesInternal(self);
var getHelp = (self) => getHelpInternal(self);
var getTypeName = (self) => getTypeNameInternal(self);
var validate4 = /* @__PURE__ */ dual(3, (self, value6, config2) => validateInternal(self, value6, config2));
var wizard = /* @__PURE__ */ dual(2, (self, help) => wizardInternal(self, help));
var getChoicesInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return some2("true | false");
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(" | "));
      return some2(choices);
    }
    case "DateTime": {
      return some2("date");
    }
    case "Float":
    case "Integer":
    case "Path":
    case "Redacted":
    case "Secret":
    case "Text": {
      return none2();
    }
  }
};
var getHelpInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return text4("A true or false value.");
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(", "));
      return text4(`One of the following: ${choices}`);
    }
    case "DateTime": {
      return text4("A date without a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30.");
    }
    case "Float": {
      return text4("A floating point number.");
    }
    case "Integer": {
      return text4("An integer.");
    }
    case "Path": {
      if (self.pathType === "either" && self.pathExists === "yes") {
        return text4("An existing file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "yes") {
        return text4("An existing file.");
      }
      if (self.pathType === "directory" && self.pathExists === "yes") {
        return text4("An existing directory.");
      }
      if (self.pathType === "either" && self.pathExists === "no") {
        return text4("A file or directory that must not exist.");
      }
      if (self.pathType === "file" && self.pathExists === "no") {
        return text4("A file that must not exist.");
      }
      if (self.pathType === "directory" && self.pathExists === "no") {
        return text4("A directory that must not exist.");
      }
      if (self.pathType === "either" && self.pathExists === "either") {
        return text4("A file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "either") {
        return text4("A file.");
      }
      if (self.pathType === "directory" && self.pathExists === "either") {
        return text4("A directory.");
      }
      throw new Error("[BUG]: Path.help - encountered invalid combination of path type " + `('${self.pathType}') and path existence ('${self.pathExists}')`);
    }
    case "Secret":
    case "Redacted": {
      return text4("A user-defined piece of text that is confidential.");
    }
    case "Text": {
      return text4("A user-defined piece of text.");
    }
  }
};
var getTypeNameInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "boolean";
    }
    case "Choice": {
      return "choice";
    }
    case "DateTime": {
      return "date";
    }
    case "Float": {
      return "float";
    }
    case "Integer": {
      return "integer";
    }
    case "Path": {
      if (self.pathType === "either") {
        return "path";
      }
      return self.pathType;
    }
    case "Redacted": {
      return "redacted";
    }
    case "Secret": {
      return "secret";
    }
    case "Text": {
      return "text";
    }
  }
};
var validateInternal = (self, value6, config2) => {
  switch (self._tag) {
    case "Bool": {
      return map2(value6, (str) => normalizeCase(config2, str)).pipe(match2({
        onNone: () => orElseFail2(self.defaultValue, () => `Missing default value for boolean parameter`),
        onSome: (value7) => isTrueValue(value7) ? succeed8(true) : isFalseValue(value7) ? succeed8(false) : fail8(`Unable to recognize '${value7}' as a valid boolean`)
      }));
    }
    case "Choice": {
      return orElseFail2(value6, () => `Choice options to not have a default value`).pipe(flatMap9((value7) => findFirst2(self.alternatives, ([choice3]) => choice3 === value7)), mapBoth3({
        onFailure: () => {
          const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(", "));
          return `Expected one of the following cases: ${choices}`;
        },
        onSuccess: ([, value7]) => value7
      }));
    }
    case "DateTime": {
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(Date$));
    }
    case "Float": {
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(NumberFromString));
    }
    case "Integer": {
      const intFromString = compose3(NumberFromString, Int);
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(intFromString));
    }
    case "Path": {
      return flatMap9(FileSystem, (fileSystem) => {
        const errorMsg = "Path options do not have a default value";
        return orElseFail2(value6, () => errorMsg).pipe(tap2((path) => orDie2(fileSystem.exists(path)).pipe(tap2((pathExists) => validatePathExistence(path, self.pathExists, pathExists).pipe(zipRight3(validatePathType(path, self.pathType, fileSystem).pipe(when2(() => self.pathExists !== "no" && pathExists))))))));
      });
    }
    case "Redacted": {
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(String$)).pipe(map15((value7) => make61(value7)));
    }
    case "Secret": {
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(String$)).pipe(map15((value7) => fromString4(value7)));
    }
    case "Text": {
      return attempt(value6, getTypeNameInternal(self), decodeUnknown3(String$));
    }
  }
};
var attempt = (option4, typeName, parse5) => orElseFail2(option4, () => `${typeName} options do not have a default value`).pipe(flatMap9((value6) => orElseFail2(parse5(value6), () => `'${value6}' is not a ${typeName}`)));
var validatePathExistence = (path, shouldPathExist, pathExists) => {
  if (shouldPathExist === "no" && pathExists) {
    return fail8(`Path '${path}' must not exist`);
  }
  if (shouldPathExist === "yes" && !pathExists) {
    return fail8(`Path '${path}' must exist`);
  }
  return _void;
};
var validatePathType = (path, pathType, fileSystem) => {
  switch (pathType) {
    case "file": {
      const checkIsFile = fileSystem.stat(path).pipe(map15((info2) => info2.type === "File"), orDie2);
      return fail8(`Expected path '${path}' to be a regular file`).pipe(unlessEffect2(checkIsFile), asVoid2);
    }
    case "directory": {
      const checkIsDirectory = fileSystem.stat(path).pipe(map15((info2) => info2.type === "Directory"), orDie2);
      return fail8(`Expected path '${path}' to be a directory`).pipe(unlessEffect2(checkIsDirectory), asVoid2);
    }
    case "either": {
      return _void;
    }
  }
};
var wizardInternal = (self, help) => {
  switch (self._tag) {
    case "Bool": {
      const primitiveHelp = p("Select true or false");
      const message = sequence(help, primitiveHelp);
      const initial = getOrElse(self.defaultValue, () => false);
      return toggle2({
        message: toAnsiText(message).trimEnd(),
        initial,
        active: "true",
        inactive: "false"
      }).pipe(map27((bool) => `${bool}`));
    }
    case "Choice": {
      const primitiveHelp = p("Select one of the following choices");
      const message = sequence(help, primitiveHelp);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: map3(self.alternatives, ([title]) => ({
          title,
          value: title
        }))
      });
    }
    case "DateTime": {
      const primitiveHelp = p("Enter a date");
      const message = sequence(help, primitiveHelp);
      return date2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((date3) => date3.toISOString()));
    }
    case "Float": {
      const primitiveHelp = p("Enter a floating point value");
      const message = sequence(help, primitiveHelp);
      return float({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((value6) => `${value6}`));
    }
    case "Integer": {
      const primitiveHelp = p("Enter an integer");
      const message = sequence(help, primitiveHelp);
      return integer2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((value6) => `${value6}`));
    }
    case "Path": {
      const primitiveHelp = p("Select a file system path");
      const message = sequence(help, primitiveHelp);
      return file({
        type: self.pathType,
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Redacted": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Secret": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Text": {
      const primitiveHelp = p("Enter some text");
      const message = sequence(help, primitiveHelp);
      return text5({
        message: toAnsiText(message).trimEnd()
      });
    }
  }
};
var getBashCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return '"${cur}"';
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Secret":
    case "Redacted":
    case "Text": {
      return '$(compgen -f "${cur}")';
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -d "${cur}")' : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
      }
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(","));
      return `$(compgen -W "${choices}" -- "\${cur}")`;
    }
  }
};
var getFishCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return empty2();
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Redacted":
    case "Secret":
    case "Text": {
      return make4("-r", "-f");
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-f", "-a", `"(__fish_complete_directories (commandline -ct))"`) : make4("-r");
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
      }
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => `${choice3}''`), join(","));
      return make4("-r", "-f", "-a", `"{${choices}}"`);
    }
  }
};
var getZshCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "";
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([name]) => name), join(" "));
      return `:CHOICE:(${choices})`;
    }
    case "DateTime": {
      return "";
    }
    case "Float": {
      return "";
    }
    case "Integer": {
      return "";
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files -/" : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
      }
    }
    case "Redacted":
    case "Secret":
    case "Text": {
      return "";
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/prompt/list.js
var list3 = (options3) => text5(options3).pipe(map27((output) => output.split(options3.delimiter || ",")));

// node_modules/@effect/cli/dist/esm/internal/usage.js
var empty41 = {
  _tag: "Empty"
};
var mixed = {
  _tag: "Empty"
};
var named = (names, acceptedValues) => ({
  _tag: "Named",
  names,
  acceptedValues
});
var optional = (self) => ({
  _tag: "Optional",
  usage: self
});
var repeated2 = (self) => ({
  _tag: "Repeated",
  usage: self
});
var alternation = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Alternation",
  left: self,
  right: that
}));
var concat4 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Concat",
  left: self,
  right: that
}));
var getHelp2 = (self) => {
  const spans2 = enumerate(self, defaultConfig);
  if (isNonEmptyReadonlyArray(spans2)) {
    const head5 = headNonEmpty(spans2);
    const tail = tailNonEmpty(spans2);
    if (isNonEmptyReadonlyArray(tail)) {
      return pipe(map3(spans2, (span3) => p(span3)), reduceRight(empty38, (left3, right3) => sequence(left3, right3)));
    }
    return p(head5);
  }
  return empty38;
};
var enumerate = /* @__PURE__ */ dual(2, (self, config2) => render5(simplify(self, config2), config2));
var simplify = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return empty41;
    }
    case "Mixed": {
      return mixed;
    }
    case "Named": {
      if (isNone2(head(render5(self, config2)))) {
        return empty41;
      }
      return self;
    }
    case "Optional": {
      if (self.usage._tag === "Empty") {
        return empty41;
      }
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty41 : usage._tag === "Optional" ? usage : optional(usage);
    }
    case "Repeated": {
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty41 : repeated2(usage);
    }
    case "Alternation": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : alternation(leftUsage, rightUsage);
    }
    case "Concat": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : concat4(leftUsage, rightUsage);
    }
  }
};
var render5 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return of(text4(""));
    }
    case "Mixed": {
      return of(text4("<command>"));
    }
    case "Named": {
      const typeInfo = config2.showTypes ? match2(self.acceptedValues, {
        onNone: () => empty37,
        onSome: (s) => concat2(space3, text4(s))
      }) : empty37;
      const namesToShow = config2.showAllNames ? self.names : self.names.length > 1 ? pipe(filter2(self.names, (name) => name.startsWith("--")), head, map2(of), getOrElse(() => self.names)) : self.names;
      const nameInfo = text4(join(namesToShow, ", "));
      return config2.showAllNames && self.names.length > 1 ? of(spans([text4("("), nameInfo, typeInfo, text4(")")])) : of(concat2(nameInfo, typeInfo));
    }
    case "Optional": {
      return map3(render5(self.usage, config2), (span3) => spans([text4("["), span3, text4("]")]));
    }
    case "Repeated": {
      return map3(render5(self.usage, config2), (span3) => concat2(span3, text4("...")));
    }
    case "Alternation": {
      if (self.left._tag === "Repeated" || self.right._tag === "Repeated" || self.left._tag === "Concat" || self.right._tag === "Concat") {
        return appendAll(render5(self.left, config2), render5(self.right, config2));
      }
      return flatMap2(render5(self.left, config2), (left3) => map3(render5(self.right, config2), (right3) => spans([left3, text4("|"), right3])));
    }
    case "Concat": {
      const leftSpan = render5(self.left, config2);
      const rightSpan = render5(self.right, config2);
      const separator = isNonEmptyReadonlyArray(leftSpan) && isNonEmptyReadonlyArray(rightSpan) ? space3 : empty37;
      return flatMap2(leftSpan, (left3) => map3(rightSpan, (right3) => spans([left3, separator, right3])));
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/validationError.js
var ValidationErrorSymbolKey = "@effect/cli/ValidationError";
var ValidationErrorTypeId = /* @__PURE__ */ Symbol.for(ValidationErrorSymbolKey);
var proto20 = {
  [ValidationErrorTypeId]: ValidationErrorTypeId
};
var isValidationError = (u) => typeof u === "object" && u != null && (ValidationErrorTypeId in u);
var isCommandMismatch = (self) => self._tag === "CommandMismatch";
var isHelpRequested = (self) => self._tag === "HelpRequested";
var isMultipleValuesDetected = (self) => self._tag === "MultipleValuesDetected";
var isMissingValue = (self) => self._tag === "MissingValue";
var commandMismatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CommandMismatch";
  op.error = error4;
  return op;
};
var correctedFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CorrectedFlag";
  op.error = error4;
  return op;
};
var invalidArgument = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidArgument";
  op.error = error4;
  return op;
};
var invalidValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidValue";
  op.error = error4;
  return op;
};
var missingFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingFlag";
  op.error = error4;
  return op;
};
var missingValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingValue";
  op.error = error4;
  return op;
};
var multipleValuesDetected = (error4, values4) => {
  const op = Object.create(proto20);
  op._tag = "MultipleValuesDetected";
  op.error = error4;
  op.values = values4;
  return op;
};
var noBuiltInMatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "NoBuiltInMatch";
  op.error = error4;
  return op;
};
var unclusteredFlag = (error4, unclustered, rest) => {
  const op = Object.create(proto20);
  op._tag = "UnclusteredFlag";
  op.error = error4;
  op.unclustered = unclustered;
  op.rest = rest;
  return op;
};

// node_modules/@effect/cli/dist/esm/internal/options.js
var OptionsSymbolKey = "@effect/cli/Options";
var OptionsTypeId = /* @__PURE__ */ Symbol.for(OptionsSymbolKey);
var proto21 = {
  [OptionsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isOptions = (u) => typeof u === "object" && u != null && (OptionsTypeId in u);
var isEmpty19 = (self) => self._tag === "Empty";
var isSingle2 = (self) => self._tag === "Single";
var all8 = function() {
  if (arguments.length === 1) {
    if (isOptions(arguments[0])) {
      return map28(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map28(entries2[0][1], (value6) => ({
        [entries2[0][0]]: value6
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map28(makeBoth(result, options3), ([record2, value6]) => ({
          ...record2,
          [key]: value6
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
var defaultBooleanOptions = {
  ifPresent: true,
  negationNames: [],
  aliases: []
};
var boolean5 = (name, options3) => {
  const {
    aliases,
    ifPresent,
    negationNames
  } = {
    ...defaultBooleanOptions,
    ...options3
  };
  const option4 = makeSingle(name, aliases, boolean4(some2(ifPresent)));
  if (isNonEmptyReadonlyArray(negationNames)) {
    const head5 = headNonEmpty(negationNames);
    const tail = tailNonEmpty(negationNames);
    const negationOption = makeSingle(head5, tail, boolean4(some2(!ifPresent)));
    return withDefault2(orElse14(option4, negationOption), !ifPresent);
  }
  return withDefault2(option4, !ifPresent);
};
var choiceWithValue = (name, choices) => makeSingle(name, empty2(), choice2(choices));
var integer4 = (name) => makeSingle(name, empty2(), integer3);
var none10 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto21);
  op._tag = "Empty";
  return op;
})();
var text7 = (name) => makeSingle(name, empty2(), text6);
var getHelp3 = (self) => getHelpInternal2(self);
var getUsage = (self) => getUsageInternal(self);
var map28 = /* @__PURE__ */ dual(2, (self, f) => makeMap(self, (a) => right2(f(a))));
var optional2 = (self) => withDefault2(map28(self, some2), none2());
var orElse14 = /* @__PURE__ */ dual(2, (self, that) => orElseEither4(self, that).pipe(map28(merge)));
var orElseEither4 = /* @__PURE__ */ dual(2, (self, that) => makeOrElse(self, that));
var processCommandLine = /* @__PURE__ */ dual(3, (self, args2, config2) => matchOptions(args2, toParseableInstruction(self), config2).pipe(flatMap9(([error4, commandArgs, matchedOptions]) => parseInternal(self, matchedOptions, config2).pipe(catchAll2((e) => match2(error4, {
  onNone: () => fail8(e),
  onSome: (err) => fail8(err)
})), map15((a) => [error4, commandArgs, a])))));
var withAlias = /* @__PURE__ */ dual(2, (self, alias) => modifySingle(self, (single2) => {
  const aliases = append(single2.aliases, alias);
  return makeSingle(single2.name, aliases, single2.primitiveType, single2.description, single2.pseudoName);
}));
var withDefault2 = /* @__PURE__ */ dual(2, (self, fallback) => makeWithDefault(self, fallback));
var withDescription2 = /* @__PURE__ */ dual(2, (self, desc) => modifySingle(self, (single2) => {
  const description = sequence(single2.description, p(desc));
  return makeSingle(single2.name, single2.aliases, single2.primitiveType, description, single2.pseudoName);
}));
var wizard2 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal2(self, config2));
var allTupled = (arg) => {
  if (arg.length === 0) {
    return none10;
  }
  if (arg.length === 1) {
    return map28(arg[0], (x) => [x]);
  }
  let result = map28(arg[0], (x) => [x]);
  for (let i = 1;i < arg.length; i++) {
    const curr = arg[i];
    result = map28(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty38;
    }
    case "Single": {
      return descriptionList(of([getSpan(getHelp2(getUsageInternal(self))), sequence(p(getHelp(self.primitiveType)), self.description)]));
    }
    case "KeyValueMap": {
      const identifier2 = getOrThrow2(getIdentifierInternal(self.argumentOption));
      return mapDescriptionList(getHelpInternal2(self.argumentOption), (span3, oldBlock) => {
        const header = p("This setting is a property argument which:");
        const single2 = `${identifier2} key1=value key2=value2`;
        const multiple = `${identifier2} key1=value ${identifier2} key2=value2`;
        const description = enumeration([p(`May be specified a single time:  '${single2}'`), p(`May be specified multiple times: '${multiple}'`)]);
        const newBlock = pipe(oldBlock, sequence(header), sequence(description));
        return [span3, newBlock];
      });
    }
    case "Map": {
      return getHelpInternal2(self.options);
    }
    case "Both":
    case "OrElse": {
      return sequence(getHelpInternal2(self.left), getHelpInternal2(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal2(self.argumentOption);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min5 = getMinSizeInternal(self);
        const max7 = getMaxSizeInternal(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min5} - ${max7}` : min5 === 0 ? "..." : ` ${min5}+`);
        const newBlock = p(isSome2(self.max) ? `This option must be repeated at least ${min5} times and may be repeated up to ${max7} times.` : min5 === 0 ? "This option may be repeated zero or more times." : `This option must be repeated at least ${min5} times.`);
        return [concat2(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal2(self.options), (span3, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span3, sequence(block, optionalDescription)];
      });
    }
    case "WithFallback": {
      const helpDoc = isConfig2(self.effect) ? p("This option can be set from environment variables.") : isPrompt(self.effect) ? p("Will prompt the user for input if this option is not provided.") : empty38;
      return mapDescriptionList(getHelpInternal2(self.options), (span3, block) => [span3, sequence(block, helpDoc)]);
    }
  }
};
var getIdentifierInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return none2();
    }
    case "Single": {
      return some2(self.fullName);
    }
    case "Both":
    case "OrElse": {
      const ids3 = getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
      return match3(ids3, {
        onEmpty: () => none2(),
        onNonEmpty: (ids4) => some2(join(ids4, ", "))
      });
    }
    case "KeyValueMap":
    case "Variadic": {
      return getIdentifierInternal(self.argumentOption);
    }
    case "Map":
    case "WithFallback":
    case "WithDefault": {
      return getIdentifierInternal(self.options);
    }
  }
};
var getMinSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallback": {
      return 0;
    }
    case "Single":
    case "KeyValueMap": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal(self.options);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return leftMinSize + rightMinSize;
    }
    case "OrElse": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return Math.min(leftMinSize, rightMinSize);
    }
    case "Variadic": {
      const selfMinSize = getOrElse(self.min, () => 0);
      const argumentOptionMinSize = getMinSizeInternal(self.argumentOption);
      return selfMinSize * argumentOptionMinSize;
    }
  }
};
var getMaxSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "KeyValueMap": {
      return Number.MAX_SAFE_INTEGER;
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getMaxSizeInternal(self.options);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal(self.left);
      const rightMaxSize = getMaxSizeInternal(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "OrElse": {
      const leftMin = getMaxSizeInternal(self.left);
      const rightMin = getMaxSizeInternal(self.right);
      return Math.min(leftMin, rightMin);
    }
    case "Variadic": {
      const selfMaxSize = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2);
      const optionsMaxSize = getMaxSizeInternal(self.argumentOption);
      return Math.floor(selfMaxSize * optionsMaxSize);
    }
  }
};
var getUsageInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty41;
    }
    case "Single": {
      const acceptedValues = isBool(self.primitiveType) ? none2() : orElse(getChoices(self.primitiveType), () => some2(self.placeholder));
      return named(getNames(self), acceptedValues);
    }
    case "KeyValueMap": {
      return getUsageInternal(self.argumentOption);
    }
    case "Map": {
      return getUsageInternal(self.options);
    }
    case "Both": {
      return concat4(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "OrElse": {
      return alternation(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal(self.argumentOption));
    }
    case "WithDefault":
    case "WithFallback": {
      return optional(getUsageInternal(self.options));
    }
  }
};
var isBoolInternal = (self) => {
  switch (self._tag) {
    case "Single": {
      return isBool(self.primitiveType);
    }
    case "Map": {
      return isBoolInternal(self.options);
    }
    case "WithDefault": {
      return isBoolInternal(self.options);
    }
    default: {
      return false;
    }
  }
};
var makeBoth = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeFullName = (str) => str.length === 1 ? [true, `-${str}`] : [false, `--${str}`];
var makeKeyValueMap = (argumentOption) => {
  const op = Object.create(proto21);
  op._tag = "KeyValueMap";
  op.argumentOption = argumentOption;
  return op;
};
var makeMap = (options3, f) => {
  const op = Object.create(proto21);
  op._tag = "Map";
  op.options = options3;
  op.f = f;
  return op;
};
var makeOrElse = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "OrElse";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeSingle = (name, aliases, primitiveType, description = empty38, pseudoName = none2()) => {
  const op = Object.create(proto21);
  op._tag = "Single";
  op.name = name;
  op.fullName = makeFullName(name)[1];
  op.placeholder = `${getOrElse(pseudoName, () => getTypeName(primitiveType))}`;
  op.aliases = aliases;
  op.primitiveType = primitiveType;
  op.description = description;
  op.pseudoName = pseudoName;
  return op;
};
var makeVariadic = (argumentOption, min5, max7) => {
  if (!isSingle2(argumentOption)) {
    throw new Error("InvalidArgumentException: only single options can be variadic");
  }
  const op = Object.create(proto21);
  op._tag = "Variadic";
  op.argumentOption = argumentOption;
  op.min = min5;
  op.max = max7;
  return op;
};
var makeWithDefault = (options3, fallback) => {
  const op = Object.create(proto21);
  op._tag = "WithDefault";
  op.options = options3;
  op.fallback = fallback;
  return op;
};
var makeWithFallback = (options3, effect4) => {
  const op = Object.create(proto21);
  op._tag = "WithFallback";
  op.options = options3;
  op.effect = effect4;
  return op;
};
var modifySingle = (self, f) => {
  switch (self._tag) {
    case "Empty": {
      return none10;
    }
    case "Single": {
      return f(self);
    }
    case "KeyValueMap": {
      return makeKeyValueMap(f(self.argumentOption));
    }
    case "Map": {
      return makeMap(modifySingle(self.options, f), self.f);
    }
    case "Both": {
      return makeBoth(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "OrElse": {
      return makeOrElse(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "Variadic": {
      return makeVariadic(f(self.argumentOption), self.min, self.max);
    }
    case "WithDefault": {
      return makeWithDefault(modifySingle(self.options, f), self.fallback);
    }
    case "WithFallback": {
      return makeWithFallback(modifySingle(self.options, f), self.effect);
    }
  }
};
var getNames = (self) => {
  const loop2 = (self2) => {
    switch (self2._tag) {
      case "Empty": {
        return empty2();
      }
      case "Single": {
        return prepend(self2.aliases, self2.name);
      }
      case "KeyValueMap":
      case "Variadic": {
        return loop2(self2.argumentOption);
      }
      case "Map":
      case "WithDefault":
      case "WithFallback": {
        return loop2(self2.options);
      }
      case "Both":
      case "OrElse": {
        const left3 = loop2(self2.left);
        const right3 = loop2(self2.right);
        return appendAll(left3, right3);
      }
    }
  };
  const order = mapInput2(boolean, (tuple5) => !tuple5[0]);
  return pipe(loop2(self), map3((str) => makeFullName(str)), sort(order), map3((tuple5) => tuple5[1]));
};
var toParseableInstruction = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single":
    case "KeyValueMap":
    case "Variadic": {
      return of(self);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return toParseableInstruction(self.options);
    }
    case "Both":
    case "OrElse": {
      return appendAll(toParseableInstruction(self.left), toParseableInstruction(self.right));
    }
  }
};
var keyValueSplitter = /=(.*)/;
var parseInternal = (self, args2, config2) => {
  switch (self._tag) {
    case "Empty": {
      return _void;
    }
    case "Single": {
      const singleNames = filterMap2(getNames(self), (name) => get7(args2, name));
      if (isNonEmptyReadonlyArray(singleNames)) {
        const head5 = headNonEmpty(singleNames);
        const tail = tailNonEmpty(singleNames);
        if (isEmptyReadonlyArray(tail)) {
          if (isEmptyReadonlyArray(head5)) {
            return validate4(self.primitiveType, none2(), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          if (isNonEmptyReadonlyArray(head5) && isEmptyReadonlyArray(tailNonEmpty(head5))) {
            const value6 = headNonEmpty(head5);
            return validate4(self.primitiveType, some2(value6), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          return fail8(multipleValuesDetected(empty38, head5));
        }
        const error5 = p(`More than one reference to option '${self.fullName}' detected`);
        return fail8(invalidValue(error5));
      }
      const error4 = p(`Expected to find option: '${self.fullName}'`);
      return fail8(missingValue(error4));
    }
    case "KeyValueMap": {
      const extractKeyValue = (value6) => {
        const split2 = value6.trim().split(keyValueSplitter, 2);
        if (isNonEmptyReadonlyArray(split2) && split2.length === 2 && split2[1] !== "") {
          return succeed8(split2);
        }
        const error4 = p(`Expected a key/value pair but received '${value6}'`);
        return fail8(invalidArgument(error4));
      };
      return parseInternal(self.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (e) => isMultipleValuesDetected(e) ? forEach8(e.values, (kv) => extractKeyValue(kv)).pipe(map15(fromIterable6)) : fail8(e),
        onSuccess: (kv) => extractKeyValue(kv).pipe(map15(make16))
      }));
    }
    case "Map": {
      return parseInternal(self.options, args2, config2).pipe(flatMap9((a) => self.f(a)));
    }
    case "Both": {
      return parseInternal(self.left, args2, config2).pipe(catchAll2((err1) => parseInternal(self.right, args2, config2).pipe(matchEffect2({
        onFailure: (err2) => {
          const error4 = sequence(err1.error, err2.error);
          return fail8(missingValue(error4));
        },
        onSuccess: () => fail8(err1)
      }))), zip5(parseInternal(self.right, args2, config2)));
    }
    case "OrElse": {
      return parseInternal(self.left, args2, config2).pipe(matchEffect2({
        onFailure: (err1) => parseInternal(self.right, args2, config2).pipe(mapBoth3({
          onFailure: (err2) => isMissingValue(err1) && isMissingValue(err2) ? missingValue(sequence(err1.error, err2.error)) : invalidValue(sequence(err1.error, err2.error)),
          onSuccess: (b) => right2(b)
        })),
        onSuccess: (a) => parseInternal(self.right, args2, config2).pipe(matchEffect2({
          onFailure: () => succeed8(left2(a)),
          onSuccess: () => {
            const leftUid = getOrElse(getIdentifierInternal(self.left), () => "???");
            const rightUid = getOrElse(getIdentifierInternal(self.right), () => "???");
            const error4 = p("Collision between two options detected - you can only specify " + `one of either: ['${leftUid}', '${rightUid}']`);
            return fail8(invalidValue(error4));
          }
        }))
      }));
    }
    case "Variadic": {
      const min5 = getOrElse(self.min, () => 0);
      const max7 = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
      const matchedArgument = filterMap2(getNames(self), (name) => get7(args2, name));
      const validateMinMax = (values4) => {
        if (values4.length < min5) {
          const name = self.argumentOption.fullName;
          const error4 = `Expected at least ${min5} value(s) for option: '${name}'`;
          return fail8(invalidValue(p(error4)));
        }
        if (values4.length > max7) {
          const name = self.argumentOption.fullName;
          const error4 = `Expected at most ${max7} value(s) for option: '${name}'`;
          return fail8(invalidValue(p(error4)));
        }
        const primitive2 = self.argumentOption.primitiveType;
        const validatePrimitive = (value6) => validate4(primitive2, some2(value6), config2).pipe(mapError2((e) => invalidValue(p(e))));
        return forEach8(values4, (value6) => validatePrimitive(value6));
      };
      if (every(matchedArgument, isEmptyReadonlyArray)) {
        return validateMinMax(empty2());
      }
      return parseInternal(self.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (error4) => isMultipleValuesDetected(error4) ? validateMinMax(error4.values) : fail8(error4),
        onSuccess: (value6) => validateMinMax(of(value6))
      }));
    }
    case "WithDefault": {
      return parseInternal(self.options, args2, config2).pipe(catchTag2("MissingValue", () => succeed8(self.fallback)));
    }
    case "WithFallback": {
      return parseInternal(self.options, args2, config2).pipe(catchTag2("MissingValue", (e) => self.effect.pipe(catchAll2((e2) => {
        if (isTagged(e2, "QuitException")) {
          return die5(e2);
        }
        if (isConfigError2(e2) && !isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }))));
    }
  }
};
var wizardInternal2 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8(empty2());
    }
    case "Single": {
      const help = getHelpInternal2(self);
      return wizard(self.primitiveType, help).pipe(flatMap9((input) => {
        const args2 = make4(getNames(self)[0], input);
        return parseCommandLine(self, args2, config2).pipe(as3(args2));
      }), zipLeft2(log3()));
    }
    case "KeyValueMap": {
      const message = p("Enter `key=value` pairs separated by spaces");
      return list3({
        message: toAnsiText(message).trim(),
        delimiter: " "
      }).pipe(flatMap9((args2) => {
        const identifier2 = getOrElse(getIdentifierInternal(self), () => "");
        return parseInternal(self, make16([identifier2, args2]), config2).pipe(as3(prepend(args2, identifier2)));
      }), zipLeft2(log3()));
    }
    case "Map": {
      return wizardInternal2(self.options, config2);
    }
    case "Both": {
      return zipWith6(wizardInternal2(self.left, config2), wizardInternal2(self.right, config2), (left3, right3) => appendAll(left3, right3));
    }
    case "OrElse": {
      const alternativeHelp = p("Select which option you would like to use");
      const message = pipe(getHelpInternal2(self), sequence(alternativeHelp));
      const makeChoice = (title, value6) => ({
        title,
        value: value6
      });
      const choices = getSomes([map2(getIdentifierInternal(self.left), (title) => makeChoice(title, self.left)), map2(getIdentifierInternal(self.right), (title) => makeChoice(title, self.right))]);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices
      }).pipe(flatMap9((option4) => wizardInternal2(option4, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument be repeated?");
      const message = pipe(getHelpInternal2(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal(self),
        max: getMaxSizeInternal(self)
      }).pipe(flatMap9((n) => n <= 0 ? succeed8(empty2()) : make26(empty2()).pipe(flatMap9((ref) => wizardInternal2(self.argumentOption, config2).pipe(flatMap9((args2) => update3(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get10(ref)))))));
    }
    case "WithDefault": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`This option is optional - use the default?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: "Yes",
          value: true,
          description: `use the default ${isOption2(self.fallback) ? match2(self.fallback, {
            onNone: () => "",
            onSome: (a) => `(${JSON.stringify(a)})`
          }) : `(${JSON.stringify(self.fallback)})`}`
        }, {
          title: "No",
          value: false,
          description: "use a custom value"
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal2(self.options, config2)));
    }
    case "WithFallback": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      if (isPrompt(self.effect)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal2(self.options, config2)));
    }
  }
};
var matchOptions = (input, options3, config2) => {
  if (isNonEmptyReadonlyArray(options3)) {
    return findOptions(input, options3, config2).pipe(flatMap9(([otherArgs, otherOptions, map1]) => {
      if (isEmpty4(map1)) {
        return succeed8([none2(), input, map1]);
      }
      return matchOptions(otherArgs, otherOptions, config2).pipe(map15(([error4, otherArgs2, map29]) => [error4, otherArgs2, merge9(map1, fromIterable(map29))]));
    }), catchAll2((e) => succeed8([some2(e), input, empty10()])));
  }
  return isEmptyReadonlyArray(input) ? succeed8([none2(), empty2(), empty10()]) : succeed8([none2(), input, empty10()]);
};
var findOptions = (input, options3, config2) => matchLeft(options3, {
  onEmpty: () => succeed8([input, empty2(), empty10()]),
  onNonEmpty: (head5, tail) => parseCommandLine(head5, input, config2).pipe(flatMap9(({
    leftover: leftover2,
    parsed
  }) => match2(parsed, {
    onNone: () => findOptions(leftover2, tail, config2).pipe(map15(([nextArgs, nextOptions, map29]) => [nextArgs, prepend(nextOptions, head5), map29])),
    onSome: ({
      name,
      values: values4
    }) => succeed8([leftover2, tail, make16([name, values4])])
  })), catchTags2({
    CorrectedFlag: (e) => findOptions(input, tail, config2).pipe(catchSome2(() => some2(fail8(e))), flatMap9(([otherArgs, otherOptions, map29]) => fail8(e).pipe(when2(() => isEmpty4(map29)), as3([otherArgs, prepend(otherOptions, head5), map29])))),
    MissingFlag: () => findOptions(input, tail, config2).pipe(map15(([otherArgs, otherOptions, map29]) => [otherArgs, prepend(otherOptions, head5), map29])),
    UnclusteredFlag: (e) => matchUnclustered(e.unclustered, e.rest, options3, config2).pipe(catchAll2(() => fail8(e)))
  }))
});
var CLUSTERED_REGEX = /^-{1}([^-]{2,}$)/;
var FLAG_REGEX = /^(--[^=]+)(?:=(.+))?$/;
var processArgs = (args2) => matchLeft(args2, {
  onEmpty: () => succeed8(empty2()),
  onNonEmpty: (head5, tail) => {
    const value6 = head5.trim();
    if (CLUSTERED_REGEX.test(value6)) {
      const unclustered = value6.substring(1).split("").map((c) => `-${c}`);
      return fail8(unclusteredFlag(empty38, unclustered, tail));
    }
    if (FLAG_REGEX.test(value6)) {
      const result = FLAG_REGEX.exec(value6);
      if (result !== null && result[2] !== undefined) {
        return succeed8(appendAll([result[1], result[2]], tail));
      }
    }
    return succeed8(args2);
  }
});
var parseCommandLine = (self, args2, config2) => {
  switch (self._tag) {
    case "Single": {
      return processArgs(args2).pipe(flatMap9((args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail8(missingFlag(error4));
        },
        onNonEmpty: (head5, tail) => {
          const normalize2 = (value6) => normalizeCase(config2, value6);
          const normalizedHead = normalize2(head5);
          const normalizedNames = map3(getNames(self), (name) => normalize2(name));
          if (contains2(normalizedNames, normalizedHead)) {
            if (isBool(self.primitiveType)) {
              return matchLeft(tail, {
                onEmpty: () => {
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail
                  });
                },
                onNonEmpty: (value6, leftover2) => {
                  if (isTrueValue(value6)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("true")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  if (isFalseValue(value6)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("false")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail
                  });
                }
              });
            }
            return matchLeft(tail, {
              onEmpty: () => {
                const error5 = p(`Expected a value following option: '${self.fullName}'`);
                return fail8(missingValue(error5));
              },
              onNonEmpty: (value6, leftover2) => {
                const parsed = some2({
                  name: head5,
                  values: of(value6)
                });
                return succeed8({
                  parsed,
                  leftover: leftover2
                });
              }
            });
          }
          if (self.name.length > config2.autoCorrectLimit + 1 && levensteinDistance(head5, self.fullName, config2) <= config2.autoCorrectLimit) {
            const error5 = p(`The flag '${head5}' is not recognized. Did you mean '${self.fullName}'?`);
            return fail8(correctedFlag(error5));
          }
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail8(missingFlag(error4));
        }
      })));
    }
    case "KeyValueMap": {
      const normalizedNames = map3(getNames(self.argumentOption), (name) => normalizeCase(config2, name));
      return matchLeft(args2, {
        onEmpty: () => succeed8({
          parsed: none2(),
          leftover: args2
        }),
        onNonEmpty: (head5, tail) => {
          const loop2 = (args3) => {
            let keyValues = empty2();
            let leftover2 = args3;
            while (isNonEmptyReadonlyArray(leftover2)) {
              const name = headNonEmpty(leftover2).trim();
              const normalizedName2 = normalizeCase(config2, name);
              if (leftover2.length >= 2 && contains2(normalizedNames, normalizedName2)) {
                const keyValue = leftover2[1].trim();
                const [key, value6] = keyValue.split("=");
                if (key !== undefined && value6 !== undefined && value6.length > 0) {
                  keyValues = append(keyValues, keyValue);
                  leftover2 = leftover2.slice(2);
                  continue;
                }
              }
              if (name.includes("=")) {
                const [key, value6] = name.split("=");
                if (key !== undefined && value6 !== undefined && value6.length > 0) {
                  keyValues = append(keyValues, name);
                  leftover2 = leftover2.slice(1);
                  continue;
                }
              }
              break;
            }
            return [keyValues, leftover2];
          };
          const normalizedName = normalizeCase(config2, head5);
          if (contains2(normalizedNames, normalizedName)) {
            const [values4, leftover2] = loop2(tail);
            return succeed8({
              parsed: some2({
                name: head5,
                values: values4
              }),
              leftover: leftover2
            });
          }
          return succeed8({
            parsed: none2(),
            leftover: args2
          });
        }
      });
    }
    case "Variadic": {
      const normalizedNames = map3(getNames(self.argumentOption), (name) => normalizeCase(config2, name));
      let optionName = undefined;
      let values4 = empty2();
      let unparsed = args2;
      let leftover2 = empty2();
      while (isNonEmptyReadonlyArray(unparsed)) {
        const name = headNonEmpty(unparsed);
        const normalizedName = normalizeCase(config2, name);
        if (contains2(normalizedNames, normalizedName)) {
          if (optionName === undefined) {
            optionName = name;
          }
          const value6 = unparsed[1];
          if (value6 !== undefined && value6.length > 0) {
            values4 = append(values4, value6.trim());
          }
          unparsed = unparsed.slice(2);
        } else {
          leftover2 = append(leftover2, headNonEmpty(unparsed));
          unparsed = unparsed.slice(1);
        }
      }
      const parsed = fromNullable(optionName).pipe(orElse(() => some2(self.argumentOption.fullName)), map2((name) => ({
        name,
        values: values4
      })));
      return succeed8({
        parsed,
        leftover: leftover2
      });
    }
  }
};
var matchUnclustered = (input, tail, options3, config2) => {
  if (isNonEmptyReadonlyArray(input)) {
    const flag = headNonEmpty(input);
    const otherFlags = tailNonEmpty(input);
    return findOptions(of(flag), options3, config2).pipe(flatMap9(([_, opts1, map1]) => {
      if (isEmpty4(map1)) {
        return fail8(unclusteredFlag(empty38, empty2(), tail));
      }
      return matchUnclustered(otherFlags, tail, opts1, config2).pipe(map15(([_2, opts2, map29]) => [tail, opts2, merge9(map1, fromIterable(map29))]));
    }));
  }
  return succeed8([tail, options3, empty10()]);
};
var merge9 = (map1, map29) => {
  if (isNonEmptyReadonlyArray(map29)) {
    const head5 = headNonEmpty(map29);
    const tail = tailNonEmpty(map29);
    const newMap = match2(get7(map1, head5[0]), {
      onNone: () => set3(map1, head5[0], head5[1]),
      onSome: (elems) => set3(map1, head5[0], appendAll(elems, head5[1]))
    });
    return merge9(newMap, tail);
  }
  return map1;
};
var escape2 = (string8) => string8.replaceAll("\\", "\\\\").replaceAll("'", "'\\''").replaceAll("[", "\\[").replaceAll("]", "\\]").replaceAll(":", "\\:").replaceAll("$", "\\$").replaceAll("`", "\\`").replaceAll("(", "\\(").replaceAll(")", "\\)");
var getShortDescription = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both":
    case "OrElse": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "KeyValueMap":
    case "Variadic": {
      return getShortDescription(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getShortDescription(self.options);
    }
  }
};
var getBashCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const cases = join(names, "|");
      const compgen = getBashCompletions(self.primitiveType);
      return make4(`${cases})`, `    COMPREPLY=( ${compgen} )`, `    return 0`, `    ;;`);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getBashCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getBashCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      const left3 = getBashCompletions2(self.left);
      const right3 = getBashCompletions2(self.right);
      return appendAll(left3, right3);
    }
  }
};
var getFishCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription(self);
      const order = mapInput2(boolean, (tuple5) => !tuple5[0]);
      return pipe(prepend(self.aliases, self.name), map3((name) => [name.length === 1, name]), sort(order), flatMap2(([isShort, name]) => make4(isShort ? "-s" : "-l", name)), appendAll(getFishCompletions(self.primitiveType)), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getFishCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getFishCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      return pipe(getFishCompletions2(self.left), appendAll(getFishCompletions2(self.right)));
    }
  }
};
var getZshCompletions2 = (self, state = {
  conflicts: empty2(),
  multiple: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const description = getShortDescription(self);
      const possibleValues = getZshCompletions(self.primitiveType);
      const multiple = state.multiple ? "*" : "";
      const conflicts = isNonEmptyReadonlyArray(state.conflicts) ? `(${join(state.conflicts, " ")})` : "";
      return map3(names, (name) => `${conflicts}${multiple}${name}[${escape2(description)}]${possibleValues}`);
    }
    case "KeyValueMap": {
      return getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      });
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getZshCompletions2(self.options, state);
    }
    case "Both": {
      const left3 = getZshCompletions2(self.left, state);
      const right3 = getZshCompletions2(self.right, state);
      return appendAll(left3, right3);
    }
    case "OrElse": {
      const leftNames = getNames(self.left);
      const rightNames = getNames(self.right);
      const left3 = getZshCompletions2(self.left, {
        ...state,
        conflicts: appendAll(state.conflicts, rightNames)
      });
      const right3 = getZshCompletions2(self.right, {
        ...state,
        conflicts: appendAll(state.conflicts, leftNames)
      });
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      }) : getZshCompletions2(self.argumentOption, state);
    }
  }
};

// node_modules/@effect/cli/dist/esm/Options.js
var all9 = all8;
var boolean6 = boolean5;
var integer5 = integer4;
var text8 = text7;
var optional3 = optional2;
var withAlias2 = withAlias;
var withDescription3 = withDescription2;

// node_modules/@effect/cli/dist/esm/internal/args.js
var ArgsSymbolKey = "@effect/cli/Args";
var ArgsTypeId = /* @__PURE__ */ Symbol.for(ArgsSymbolKey);
var proto22 = {
  [ArgsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isArgs = (u) => typeof u === "object" && u != null && (ArgsTypeId in u);
var isEmpty20 = (self) => self._tag === "Empty";
var all10 = function() {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map29(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled2(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map29(entries2[0][1], (value6) => ({
        [entries2[0][0]]: value6
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map29(makeBoth2(result, options3), ([record2, value6]) => ({
          ...record2,
          [key]: value6
        }));
      }
      return result;
    }
  }
  return allTupled2(arguments[0]);
};
var none11 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto22);
  op._tag = "Empty";
  return op;
})();
var text9 = (config2) => makeSingle2(fromNullable(config2?.name), text6);
var getHelp4 = (self) => getHelpInternal3(self);
var getUsage2 = (self) => getUsageInternal2(self);
var map29 = /* @__PURE__ */ dual(2, (self, f) => mapEffect6(self, (a) => succeed8(f(a))));
var mapEffect6 = /* @__PURE__ */ dual(2, (self, f) => makeMap2(self, f));
var validate5 = /* @__PURE__ */ dual(3, (self, args2, config2) => validateInternal2(self, args2, config2));
var withDescription4 = /* @__PURE__ */ dual(2, (self, description) => withDescriptionInternal(self, description));
var wizard3 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal3(self, config2));
var allTupled2 = (arg) => {
  if (arg.length === 0) {
    return none11;
  }
  if (arg.length === 1) {
    return map29(arg[0], (x) => [x]);
  }
  let result = map29(arg[0], (x) => [x]);
  for (let i = 1;i < arg.length; i++) {
    const curr = arg[i];
    result = map29(makeBoth2(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty38;
    }
    case "Single": {
      return descriptionList([[weak(self.name), sequence(p(getHelp(self.primitiveType)), self.description)]]);
    }
    case "Map": {
      return getHelpInternal3(self.args);
    }
    case "Both": {
      return sequence(getHelpInternal3(self.left), getHelpInternal3(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal3(self.args);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min5 = getMinSizeInternal2(self);
        const max7 = getMaxSizeInternal2(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min5} - ${max7}` : min5 === 0 ? "..." : ` ${min5}+`);
        const newBlock = p(isSome2(self.max) ? `This argument must be repeated at least ${min5} times and may be repeated up to ${max7} times.` : min5 === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min5} times.`);
        return [concat2(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal3(self.args), (span3, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span3, sequence(block, optionalDescription)];
      });
    }
    case "WithFallbackConfig": {
      return mapDescriptionList(getHelpInternal3(self.args), (span3, block) => [span3, sequence(block, p("This argument can be set from environment variables."))]);
    }
  }
};
var getMinSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal2(self.args);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal2(self.left);
      const rightMinSize = getMinSizeInternal2(self.right);
      return leftMinSize + rightMinSize;
    }
    case "Variadic": {
      const argsMinSize = getMinSizeInternal2(self.args);
      return Math.floor(getOrElse(self.min, () => 0) * argsMinSize);
    }
  }
};
var getMaxSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getMaxSizeInternal2(self.args);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal2(self.left);
      const rightMaxSize = getMaxSizeInternal2(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "Variadic": {
      const argsMaxSize = getMaxSizeInternal2(self.args);
      return Math.floor(getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
    }
  }
};
var getUsageInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty41;
    }
    case "Single": {
      return named(of(self.name), getChoices(self.primitiveType));
    }
    case "Map": {
      return getUsageInternal2(self.args);
    }
    case "Both": {
      return concat4(getUsageInternal2(self.left), getUsageInternal2(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal2(self.args));
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return optional(getUsageInternal2(self.args));
    }
  }
};
var makeSingle2 = (pseudoName, primitiveType, description = empty38) => {
  const op = Object.create(proto22);
  op._tag = "Single";
  op.name = `<${getOrElse(pseudoName, () => getTypeName(primitiveType))}>`;
  op.pseudoName = pseudoName;
  op.primitiveType = primitiveType;
  op.description = description;
  return op;
};
var makeMap2 = (self, f) => {
  const op = Object.create(proto22);
  op._tag = "Map";
  op.args = self;
  op.f = f;
  return op;
};
var makeBoth2 = (left3, right3) => {
  const op = Object.create(proto22);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeWithDefault2 = (self, fallback) => {
  const op = Object.create(proto22);
  op._tag = "WithDefault";
  op.args = self;
  op.fallback = fallback;
  return op;
};
var makeWithFallbackConfig = (args2, config2) => {
  const op = Object.create(proto22);
  op._tag = "WithFallbackConfig";
  op.args = args2;
  op.config = config2;
  return op;
};
var makeVariadic2 = (args2, min5, max7) => {
  const op = Object.create(proto22);
  op._tag = "Variadic";
  op.args = args2;
  op.min = min5;
  op.max = max7;
  return op;
};
var validateInternal2 = (self, args2, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8([args2, undefined]);
    }
    case "Single": {
      return suspend3(() => {
        return matchLeft(args2, {
          onEmpty: () => {
            const choices = getChoices(self.primitiveType);
            if (isSome2(self.pseudoName) && isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument <${self.pseudoName.value}> with choices ${choices.value}`)));
            }
            if (isSome2(self.pseudoName)) {
              return fail8(missingValue(p(`Missing argument <${self.pseudoName.value}>`)));
            }
            if (isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)} with choices ${choices.value}`)));
            }
            return fail8(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)}`)));
          },
          onNonEmpty: (head5, tail) => validate4(self.primitiveType, some2(head5), config2).pipe(mapBoth3({
            onFailure: (text10) => invalidArgument(p(text10)),
            onSuccess: (a) => [tail, a]
          }))
        });
      });
    }
    case "Map": {
      return validateInternal2(self.args, args2, config2).pipe(flatMap9(([leftover2, a]) => matchEffect2(self.f(a), {
        onFailure: (doc) => fail8(invalidArgument(doc)),
        onSuccess: (b) => succeed8([leftover2, b])
      })));
    }
    case "Both": {
      return validateInternal2(self.left, args2, config2).pipe(flatMap9(([args3, a]) => validateInternal2(self.right, args3, config2).pipe(map15(([args4, b]) => [args4, [a, b]]))));
    }
    case "Variadic": {
      const min1 = getOrElse(self.min, () => 0);
      const max1 = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
      const loop2 = (args3, acc) => {
        if (acc.length >= max1) {
          return succeed8([args3, acc]);
        }
        return validateInternal2(self.args, args3, config2).pipe(matchEffect2({
          onFailure: (failure) => acc.length >= min1 && isEmptyReadonlyArray(args3) ? succeed8([args3, acc]) : fail8(failure),
          onSuccess: ([args4, a]) => loop2(args4, append(acc, a))
        }));
      };
      return loop2(args2, empty2()).pipe(map15(([args3, acc]) => [args3, acc]));
    }
    case "WithDefault": {
      return validateInternal2(self.args, args2, config2).pipe(catchTag2("MissingValue", () => succeed8([args2, self.fallback])));
    }
    case "WithFallbackConfig": {
      return validateInternal2(self.args, args2, config2).pipe(catchTag2("MissingValue", (e) => map15(catchAll2(self.config, (e2) => {
        if (isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }), (value6) => [args2, value6])));
    }
  }
};
var withDescriptionInternal = (self, description) => {
  switch (self._tag) {
    case "Empty": {
      return none11;
    }
    case "Single": {
      const desc = sequence(self.description, p(description));
      return makeSingle2(self.pseudoName, self.primitiveType, desc);
    }
    case "Map": {
      return makeMap2(withDescriptionInternal(self.args, description), self.f);
    }
    case "Both": {
      return makeBoth2(withDescriptionInternal(self.left, description), withDescriptionInternal(self.right, description));
    }
    case "Variadic": {
      return makeVariadic2(withDescriptionInternal(self.args, description), self.min, self.max);
    }
    case "WithDefault": {
      return makeWithDefault2(withDescriptionInternal(self.args, description), self.fallback);
    }
    case "WithFallbackConfig": {
      return makeWithFallbackConfig(withDescriptionInternal(self.args, description), self.config);
    }
  }
};
var wizardInternal3 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8(empty2());
    }
    case "Single": {
      const help = getHelpInternal3(self);
      return wizard(self.primitiveType, help).pipe(zipLeft2(log3()), flatMap9((input) => {
        const args2 = of(input);
        return validateInternal2(self, args2, config2).pipe(as3(args2));
      }));
    }
    case "Map": {
      return wizardInternal3(self.args, config2).pipe(tap2((args2) => validateInternal2(self.args, args2, config2)));
    }
    case "Both": {
      return zipWith6(wizardInternal3(self.left, config2), wizardInternal3(self.right, config2), (left3, right3) => appendAll(left3, right3)).pipe(tap2((args2) => validateInternal2(self, args2, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument should be repeated?");
      const message = pipe(getHelpInternal3(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal2(self),
        max: getMaxSizeInternal2(self)
      }).pipe(zipLeft2(log3()), flatMap9((n) => n <= 0 ? succeed8(empty2()) : make26(empty2()).pipe(flatMap9((ref) => wizardInternal3(self.args, config2).pipe(flatMap9((args2) => update3(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get10(ref)), tap2((args2) => validateInternal2(self, args2, config2)))))));
    }
    case "WithDefault": {
      const defaultHelp = p(`This argument is optional - use the default?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Default ['${JSON.stringify(self.fallback)}']`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal3(self.args, config2)));
    }
    case "WithFallbackConfig": {
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal3(self.args, config2)));
    }
  }
};
var getShortDescription2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getShortDescription2(self.args);
    }
  }
};
var getFishCompletions3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription2(self);
      return pipe(getFishCompletions(self.primitiveType), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "Both": {
      return pipe(getFishCompletions3(self.left), appendAll(getFishCompletions3(self.right)));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getFishCompletions3(self.args);
    }
  }
};
var getZshCompletions3 = (self, state = {
  multiple: false,
  optional: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const multiple = state.multiple ? "*" : "";
      const optional4 = state.optional ? "::" : ":";
      const shortDescription = getShortDescription2(self);
      const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
      const possibleValues = getZshCompletions(self.primitiveType);
      return possibleValues.length === 0 ? empty2() : of(`${multiple}${optional4}${self.name}${description}${possibleValues}`);
    }
    case "Map": {
      return getZshCompletions3(self.args, state);
    }
    case "Both": {
      const left3 = getZshCompletions3(self.left, state);
      const right3 = getZshCompletions3(self.right, state);
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions3(self.args, {
        ...state,
        multiple: true
      }) : getZshCompletions3(self.args, state);
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return getZshCompletions3(self.args, {
        ...state,
        optional: true
      });
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/builtInOptions.js
var setLogLevel = (level) => ({
  _tag: "SetLogLevel",
  level
});
var showCompletions = (shellType) => ({
  _tag: "ShowCompletions",
  shellType
});
var showHelp = (usage, helpDoc) => ({
  _tag: "ShowHelp",
  usage,
  helpDoc
});
var showWizard = (command) => ({
  _tag: "ShowWizard",
  command
});
var showVersion = {
  _tag: "ShowVersion"
};
var isShowHelp = (self) => self._tag === "ShowHelp";
var isShowWizard = (self) => self._tag === "ShowWizard";
var completionsOptions = /* @__PURE__ */ choiceWithValue("completions", [["sh", "bash"], ["bash", "bash"], ["fish", "fish"], ["zsh", "zsh"]]).pipe(optional2, /* @__PURE__ */ withDescription2("Generate a completion script for a specific shell."));
var logLevelOptions = /* @__PURE__ */ choiceWithValue("log-level", allLevels.map((level) => [level._tag.toLowerCase(), level])).pipe(optional2, /* @__PURE__ */ withDescription2("Sets the minimum log level for a command."));
var helpOptions = /* @__PURE__ */ boolean5("help").pipe(/* @__PURE__ */ withAlias("h"), /* @__PURE__ */ withDescription2("Show the help documentation for a command."));
var versionOptions = /* @__PURE__ */ boolean5("version").pipe(/* @__PURE__ */ withDescription2("Show the version of the application."));
var wizardOptions = /* @__PURE__ */ boolean5("wizard").pipe(/* @__PURE__ */ withDescription2("Start wizard mode for a command."));
var builtIns = /* @__PURE__ */ all8({
  completions: completionsOptions,
  logLevel: logLevelOptions,
  help: helpOptions,
  wizard: wizardOptions,
  version: versionOptions
});
var builtInOptions = (command, usage, helpDoc) => map28(builtIns, (builtIn) => {
  if (isSome2(builtIn.completions)) {
    return some2(showCompletions(builtIn.completions.value));
  }
  if (isSome2(builtIn.logLevel)) {
    return some2(setLogLevel(builtIn.logLevel.value));
  }
  if (builtIn.help) {
    return some2(showHelp(usage, helpDoc));
  }
  if (builtIn.wizard) {
    return some2(showWizard(command));
  }
  if (builtIn.version) {
    return some2(showVersion);
  }
  return none2();
});

// node_modules/@effect/cli/dist/esm/internal/commandDirective.js
var builtIn = (option4) => ({
  _tag: "BuiltIn",
  option: option4
});
var userDefined = (leftover2, value6) => ({
  _tag: "UserDefined",
  leftover: leftover2,
  value: value6
});
var isBuiltIn = (self) => self._tag === "BuiltIn";
var isUserDefined = (self) => self._tag === "UserDefined";
var map30 = /* @__PURE__ */ dual(2, (self, f) => isUserDefined(self) ? userDefined(self.leftover, f(self.value)) : self);

// node_modules/@effect/cli/dist/esm/internal/commandDescriptor.js
var CommandDescriptorSymbolKey = "@effect/cli/CommandDescriptor";
var TypeId24 = /* @__PURE__ */ Symbol.for(CommandDescriptorSymbolKey);
var proto23 = {
  [TypeId24]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCommand = (u) => typeof u === "object" && u != null && (TypeId24 in u);
var isStandard = (self) => self._tag === "Standard";
var make65 = (name, options3 = none10, args2 = none11) => {
  const op = Object.create(proto23);
  op._tag = "Standard";
  op.name = name;
  op.description = empty38;
  op.options = options3;
  op.args = args2;
  return op;
};
var getHelp5 = (self, config2) => getHelpInternal4(self, config2);
var getNames2 = (self) => fromIterable5(getNamesInternal(self));
var getBashCompletions3 = (self, executable) => getBashCompletionsInternal(self, executable);
var getFishCompletions4 = (self, executable) => getFishCompletionsInternal(self, executable);
var getZshCompletions4 = (self, executable) => getZshCompletionsInternal(self, executable);
var getSubcommands = (self) => fromIterable6(getSubcommandsInternal(self));
var getUsage3 = (self) => getUsageInternal3(self);
var map31 = /* @__PURE__ */ dual(2, (self, f) => mapEffect7(self, (a) => right2(f(a))));
var mapEffect7 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto23);
  op._tag = "Map";
  op.command = self;
  op.f = f;
  return op;
});
var parse7 = /* @__PURE__ */ dual(3, (self, args2, config2) => parseInternal2(self, args2, config2));
var withDescription5 = /* @__PURE__ */ dual(2, (self, help) => withDescriptionInternal2(self, help));
var withSubcommands = /* @__PURE__ */ dual(2, (self, subcommands) => {
  const op = Object.create(proto23);
  op._tag = "Subcommands";
  op.parent = self;
  op.children = map3(subcommands, ([id2, command]) => map31(command, (a) => [id2, a]));
  return op;
});
var wizard4 = /* @__PURE__ */ dual(3, (self, prefix, config2) => wizardInternal4(self, prefix, config2));
var getHelpInternal4 = (self, config2) => {
  switch (self._tag) {
    case "Standard": {
      const header = isEmpty13(self.description) ? empty38 : sequence(h1("DESCRIPTION"), self.description);
      const argsHelp = getHelp4(self.args);
      const argsSection = isEmpty13(argsHelp) ? empty38 : sequence(h1("ARGUMENTS"), argsHelp);
      const options3 = config2.showBuiltIns ? all9([self.options, builtIns]) : self.options;
      const optionsHelp = getHelp3(options3);
      const optionsSection = isEmpty13(optionsHelp) ? empty38 : sequence(h1("OPTIONS"), optionsHelp);
      return sequence(header, sequence(argsSection, optionsSection));
    }
    case "GetUserInput": {
      return isEmpty13(self.description) ? empty38 : sequence(h1("DESCRIPTION"), self.description);
    }
    case "Map": {
      return getHelpInternal4(self.command, config2);
    }
    case "Subcommands": {
      const getUsage4 = (command, preceding) => {
        switch (command._tag) {
          case "Standard":
          case "GetUserInput": {
            const usage = getSpan(getHelp2(getUsageInternal3(command)));
            const usages = append(preceding, usage);
            const finalUsage = reduce(usages, empty37, (acc, next4) => isText3(acc) && acc.value === "" ? next4 : isText3(next4) && next4.value === "" ? acc : spans([acc, space3, next4]));
            const description = getSpan(command.description);
            return of([finalUsage, description]);
          }
          case "Map": {
            return getUsage4(command.command, preceding);
          }
          case "Subcommands": {
            const parentUsage = getUsage4(command.parent, preceding);
            return match2(head(parentUsage), {
              onNone: () => flatMap2(command.children, (child) => getUsage4(child, preceding)),
              onSome: ([usage]) => {
                const childrenUsage = flatMap2(command.children, (child) => getUsage4(child, append(preceding, usage)));
                return appendAll(parentUsage, childrenUsage);
              }
            });
          }
        }
      };
      const printSubcommands = (subcommands) => {
        const maxUsageLength = reduceRight(subcommands, 0, (max7, [usage]) => Math.max(size11(usage), max7));
        const documents = map3(subcommands, ([usage, desc]) => p(spans([usage, text4(" ".repeat(maxUsageLength - size11(usage) + 2)), desc])));
        if (isNonEmptyReadonlyArray(documents)) {
          return enumeration(documents);
        }
        throw new Error("[BUG]: Subcommands.usage - received empty list of subcommands to print");
      };
      return sequence(getHelpInternal4(self.parent, config2), sequence(h1("COMMANDS"), printSubcommands(flatMap2(self.children, (child) => getUsage4(child, empty2())))));
    }
  }
};
var getNamesInternal = (self) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      return of(self.name);
    }
    case "Map": {
      return getNamesInternal(self.command);
    }
    case "Subcommands": {
      return getNamesInternal(self.parent);
    }
  }
};
var getSubcommandsInternal = (self) => {
  const loop2 = (self2, isSubcommand) => {
    switch (self2._tag) {
      case "Standard":
      case "GetUserInput": {
        return of([self2.name, self2]);
      }
      case "Map": {
        return loop2(self2.command, isSubcommand);
      }
      case "Subcommands": {
        return isSubcommand ? loop2(self2.parent, false) : flatMap2(self2.children, (child) => loop2(child, true));
      }
    }
  };
  return loop2(self, false);
};
var getUsageInternal3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return concat4(named(of(self.name), none2()), concat4(getUsage(self.options), getUsage2(self.args)));
    }
    case "GetUserInput": {
      return named(of(self.name), none2());
    }
    case "Map": {
      return getUsageInternal3(self.command);
    }
    case "Subcommands": {
      return concat4(getUsageInternal3(self.parent), mixed);
    }
  }
};
var parseInternal2 = (self, args2, config2) => {
  const parseCommandLine2 = (self2, args3) => matchLeft(args3, {
    onEmpty: () => {
      const error4 = p(`Missing command name: '${self2.name}'`);
      return fail8(commandMismatch(error4));
    },
    onNonEmpty: (head5, tail) => {
      const normalizedArgv0 = normalizeCase(config2, head5);
      const normalizedCommandName = normalizeCase(config2, self2.name);
      return succeed8(tail).pipe(when2(() => normalizedArgv0 === normalizedCommandName), flatten6, catchTag2("NoSuchElementException", () => {
        const error4 = p(`Missing command name: '${self2.name}'`);
        return fail8(commandMismatch(error4));
      }));
    }
  });
  switch (self._tag) {
    case "Standard": {
      const parseBuiltInArgs = (args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail8(commandMismatch(error4));
        },
        onNonEmpty: (argv0) => {
          const normalizedArgv0 = normalizeCase(config2, argv0);
          const normalizedCommandName = normalizeCase(config2, self.name);
          if (normalizedArgv0 === normalizedCommandName) {
            const help = getHelpInternal4(self, config2);
            const usage = getUsageInternal3(self);
            const options3 = builtInOptions(self, usage, help);
            const argsWithoutCommand = drop(args3, 1);
            return processCommandLine(options3, argsWithoutCommand, config2).pipe(flatMap9((tuple5) => tuple5[2]), catchTag2("NoSuchElementException", () => {
              const error5 = p("No built-in option was matched");
              return fail8(noBuiltInMatch(error5));
            }), map15(builtIn));
          }
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail8(commandMismatch(error4));
        }
      });
      const parseUserDefinedArgs = (args3) => parseCommandLine2(self, args3).pipe(flatMap9((commandOptionsAndArgs) => {
        const [optionsAndArgs, forcedCommandArgs] = splitForcedArgs(commandOptionsAndArgs);
        return processCommandLine(self.options, optionsAndArgs, config2).pipe(flatMap9(([error4, commandArgs, optionsType]) => validate5(self.args, appendAll(commandArgs, forcedCommandArgs), config2).pipe(catchAll2((e) => match2(error4, {
          onNone: () => fail8(e),
          onSome: (err) => fail8(err)
        })), map15(([argsLeftover, argsType]) => userDefined(argsLeftover, {
          name: self.name,
          options: optionsType,
          args: argsType
        })))));
      }));
      const exhaustiveSearch = (args3) => {
        if (contains2(args3, "--help") || contains2(args3, "-h")) {
          return parseBuiltInArgs(make4(self.name, "--help"));
        }
        if (contains2(args3, "--wizard")) {
          return parseBuiltInArgs(make4(self.name, "--wizard"));
        }
        if (contains2(args3, "--version")) {
          return parseBuiltInArgs(make4(self.name, "--version"));
        }
        const error4 = p(`Missing command name: '${self.name}'`);
        return fail8(commandMismatch(error4));
      };
      return parseBuiltInArgs(args2).pipe(orElse4(() => parseUserDefinedArgs(args2)), catchSome2((e) => {
        if (isValidationError(e)) {
          if (config2.finalCheckBuiltIn) {
            return some2(exhaustiveSearch(args2).pipe(catchSome2((_) => isValidationError(_) ? some2(fail8(e)) : none2())));
          }
          return some2(fail8(e));
        }
        return none2();
      }));
    }
    case "GetUserInput": {
      return parseCommandLine2(self, args2).pipe(zipRight3(run5(self.prompt)), catchTag2("QuitException", (e) => die5(e)), map15((value6) => userDefined(drop(args2, 1), {
        name: self.name,
        value: value6
      })));
    }
    case "Map": {
      return parseInternal2(self.command, args2, config2).pipe(flatMap9((directive) => {
        if (isUserDefined(directive)) {
          return self.f(directive.value).pipe(map15((value6) => userDefined(directive.leftover, value6)));
        }
        return succeed8(directive);
      }));
    }
    case "Subcommands": {
      const names = getNamesInternal(self);
      const subcommands = getSubcommandsInternal(self);
      const [parentArgs, childArgs] = span(args2, (arg) => !some3(subcommands, ([name]) => name === arg));
      const parseChildren = suspend3(() => {
        const iterator = self.children[Symbol.iterator]();
        const loop2 = (next4) => {
          return parseInternal2(next4, childArgs, config2).pipe(catchIf2(isCommandMismatch, (e) => {
            const next5 = iterator.next();
            return next5.done ? fail8(e) : loop2(next5.value);
          }));
        };
        return loop2(iterator.next().value);
      });
      const helpDirectiveForParent = sync3(() => {
        return builtIn(showHelp(getUsageInternal3(self), getHelpInternal4(self, config2)));
      });
      const helpDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowHelp(directive.option)) {
          const parentName = getOrElse(head(names), () => "");
          const newDirective = builtIn(showHelp(concat4(named(of(parentName), none2()), directive.option.usage), directive.option.helpDoc));
          return succeed8(newDirective);
        }
        return fail8(invalidArgument(empty38));
      }));
      const wizardDirectiveForParent = sync3(() => builtIn(showWizard(self)));
      const wizardDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowWizard(directive.option)) {
          return succeed8(directive);
        }
        return fail8(invalidArgument(empty38));
      }));
      return suspend3(() => parseInternal2(self.parent, parentArgs, config2).pipe(flatMap9((directive) => {
        switch (directive._tag) {
          case "BuiltIn": {
            if (isShowHelp(directive.option)) {
              return isNonEmptyReadonlyArray(childArgs) ? orElse4(helpDirectiveForChild, () => helpDirectiveForParent) : helpDirectiveForParent;
            }
            if (isShowWizard(directive.option)) {
              return orElse4(wizardDirectiveForChild, () => wizardDirectiveForParent);
            }
            return succeed8(directive);
          }
          case "UserDefined": {
            const args3 = appendAll(directive.leftover, childArgs);
            if (isNonEmptyReadonlyArray(args3)) {
              return parseChildren.pipe(mapBoth3({
                onFailure: (err) => {
                  if (isCommandMismatch(err)) {
                    const parentName = getOrElse(head(names), () => "");
                    const childNames = map3(subcommands, ([name]) => `'${name}'`);
                    const oneOf = childNames.length === 1 ? "" : " one of";
                    const error4 = p(`Invalid subcommand for ${parentName} - use${oneOf} ${join(childNames, ", ")}`);
                    return commandMismatch(error4);
                  }
                  return err;
                },
                onSuccess: map30((subcommand) => ({
                  ...directive.value,
                  subcommand: some2(subcommand)
                }))
              }));
            }
            return succeed8(userDefined(directive.leftover, {
              ...directive.value,
              subcommand: none2()
            }));
          }
        }
      }), catchSome2(() => isEmptyReadonlyArray(args2) ? some2(helpDirectiveForParent) : none2())));
    }
  }
};
var splitForcedArgs = (args2) => {
  const [remainingArgs, forcedArgs] = span(args2, (str) => str !== "--");
  return [remainingArgs, drop(forcedArgs, 1)];
};
var withDescriptionInternal2 = (self, description) => {
  switch (self._tag) {
    case "Standard": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "Standard";
      op.name = self.name;
      op.description = helpDoc;
      op.options = self.options;
      op.args = self.args;
      return op;
    }
    case "GetUserInput": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "GetUserInput";
      op.name = self.name;
      op.description = helpDoc;
      op.prompt = self.prompt;
      return op;
    }
    case "Map": {
      return mapEffect7(withDescriptionInternal2(self.command, description), self.f);
    }
    case "Subcommands": {
      const op = Object.create(proto23);
      op._tag = "Subcommands";
      op.parent = withDescriptionInternal2(self.parent, description);
      op.children = self.children.slice();
      return op;
    }
  }
};
var argsWizardHeader = /* @__PURE__ */ code("Args Wizard - ");
var optionsWizardHeader = /* @__PURE__ */ code("Options Wizard - ");
var wizardInternal4 = (self, prefix, config2) => {
  const loop2 = (self2, commandLineRef) => {
    switch (self2._tag) {
      case "GetUserInput":
      case "Standard": {
        return gen2(function* () {
          const logCurrentCommand = get10(commandLineRef).pipe(flatMap9((commandLine) => {
            const currentCommand = p(pipe(strong(highlight("COMMAND:", cyan2)), concat2(space3), concat2(highlight(join(commandLine, " "), magenta2))));
            return log3(toAnsiText(currentCommand));
          }));
          if (isStandard(self2)) {
            yield* logCurrentCommand;
            const commandName = highlight(self2.name, magenta2);
            if (!isEmpty19(self2.options)) {
              const message = p(concat2(optionsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard2(self2.options, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
            if (!isEmpty20(self2.args)) {
              const message = p(concat2(argsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard3(self2.args, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
          }
          return yield* get10(commandLineRef);
        });
      }
      case "Map": {
        return loop2(self2.command, commandLineRef);
      }
      case "Subcommands": {
        const description = p("Select which command you would like to execute");
        const message = toAnsiText(description).trimEnd();
        const makeChoice = (title, index) => ({
          title,
          value: [title, index]
        });
        const choices = pipe(getSubcommandsInternal(self2), map3(([name], index) => makeChoice(name, index)));
        return loop2(self2.parent, commandLineRef).pipe(zipRight3(select({
          message,
          choices
        }).pipe(tap2(([name]) => update3(commandLineRef, append(name))), zipLeft2(log3()), flatMap9(([, nextIndex]) => loop2(self2.children[nextIndex], commandLineRef)))));
      }
    }
  };
  return make26(prefix).pipe(flatMap9((commandLineRef) => loop2(self, commandLineRef).pipe(zipRight3(get10(commandLineRef)))));
};
var getShortDescription3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return getText(getSpan(self.description));
    }
    case "GetUserInput": {
      return getText(getSpan(self.description));
    }
    case "Map": {
      return getShortDescription3(self.command);
    }
    case "Subcommands": {
      return "";
    }
  }
};
var traverseCommand = (self, initialState3, f) => make43(initialState3).pipe(flatMap9((ref) => {
  const loop2 = (self2, parentCommands, subcommands, level) => {
    switch (self2._tag) {
      case "Standard": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "GetUserInput": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "Map": {
        return loop2(self2.command, parentCommands, subcommands, level);
      }
      case "Subcommands": {
        const parentNames = getNamesInternal(self2.parent);
        const nextSubcommands = getSubcommandsInternal(self2);
        const nextParentCommands = appendAll(parentCommands, parentNames);
        return loop2(self2.parent, parentCommands, nextSubcommands, level).pipe(zipRight3(forEach8(self2.children, (child) => loop2(child, nextParentCommands, subcommands, level + 1))));
      }
    }
  };
  return suspend3(() => loop2(self, empty2(), empty2(), 0)).pipe(zipRight3(get13(ref)));
}));
var indentAll = /* @__PURE__ */ dual(2, (self, indent3) => {
  const indentation = allocate(indent3 + 1).join(" ");
  return map3(self, (line4) => `${indentation}${line4}`);
});
var getBashCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const options3 = isStandard(info2.command) ? all9([info2.command.options, builtIns]) : builtIns;
  const optionNames = getNames(options3);
  const optionCases = isStandard(info2.command) ? getBashCompletions2(info2.command.options) : empty2();
  const subcommandNames = pipe(info2.subcommands, map3(([name]) => name), sort(string2));
  const wordList = appendAll(optionNames, subcommandNames);
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map3((command) => command.replace("-", "__")));
  const caseName = join(preformatted, ",");
  const funcName = join(preformatted, "__");
  const funcLines = isEmptyReadonlyArray(info2.parentCommands) ? empty2() : [`${caseName})`, `    cmd="${funcName}"`, "    ;;"];
  const cmdLines = [`${funcName})`, `    opts="${join(wordList, " ")}"`, `    if [[ \${cur} == -* || \${COMP_CWORD} -eq ${info2.level + 1} ]] ; then`, '        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "        return 0", "    fi", '    case "${prev}" in', ...indentAll(optionCases, 8), "    *)", "        COMPREPLY=()", "        ;;", "    esac", '    COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "    return 0", "    ;;"];
  const lines2 = append(state, [funcLines, cmdLines]);
  return succeed8(lines2);
}).pipe(map15((lines2) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const scriptName = `_${rootCommand}_bash_completions`;
  const funcCases = flatMap2(lines2, ([funcLines]) => funcLines);
  const cmdCases = flatMap2(lines2, ([, cmdLines]) => cmdLines);
  return [`function ${scriptName}() {`, "    local i cur prev opts cmd", "    COMPREPLY=()", '    cur="${COMP_WORDS[COMP_CWORD]}"', '    prev="${COMP_WORDS[COMP_CWORD-1]}"', '    cmd=""', '    opts=""', '    for i in "${COMP_WORDS[@]}"; do', '        case "${cmd},${i}" in', '            ",$1")', `                cmd="${executable}"`, "                ;;", ...indentAll(funcCases, 12), "            *)", "                ;;", "        esac", "    done", '    case "${cmd}" in', ...indentAll(cmdCases, 8), "    esac", "}", `complete -F ${scriptName} -o nosort -o bashdefault -o default ${rootCommand}`];
}));
var getFishCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const baseTemplate = make4("complete", "-c", executable);
  const options3 = isStandard(info2.command) ? all8([builtIns, info2.command.options]) : builtIns;
  const optionsCompletions = getFishCompletions2(options3);
  const argsCompletions = isStandard(info2.command) ? getFishCompletions3(info2.command.args) : empty2();
  const rootCompletions = (conditionals2) => pipe(map3(optionsCompletions, (option4) => pipe(baseTemplate, appendAll(conditionals2), append(option4), join(" "))), appendAll(map3(argsCompletions, (option4) => pipe(baseTemplate, appendAll(conditionals2), append(option4), join(" ")))));
  const subcommandCompletions = (conditionals2) => map3(info2.subcommands, ([name, subcommand]) => {
    const description = getShortDescription3(subcommand);
    return pipe(baseTemplate, appendAll(conditionals2), appendAll(make4("-f", "-a", `"${name}"`)), appendAll(description.length === 0 ? empty2() : make4("-d", `'${description}'`)), join(" "));
  });
  if (isEmptyReadonlyArray(info2.parentCommands)) {
    const conditionals2 = make4("-n", '"__fish_use_subcommand"');
    return succeed8(pipe(state, appendAll(rootCompletions(conditionals2)), appendAll(subcommandCompletions(conditionals2))));
  }
  const parentConditionals = pipe(info2.parentCommands, drop(1), append(info2.command.name), map3((command) => `__fish_seen_subcommand_from ${command}`));
  const subcommandConditionals = map3(info2.subcommands, ([name]) => `not __fish_seen_subcommand_from ${name}`);
  const baseConditionals = pipe(appendAll(parentConditionals, subcommandConditionals), join("; and "));
  const conditionals = make4("-n", `"${baseConditionals}"`);
  return succeed8(pipe(state, appendAll(rootCompletions(conditionals)), appendAll(subcommandCompletions(conditionals))));
});
var getZshCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map3((command) => command.replace("-", "__")));
  const underscoreName = join(preformatted, "__");
  const spaceName = join(preformatted, " ");
  const subcommands = pipe(info2.subcommands, map3(([name, subcommand]) => {
    const desc = getShortDescription3(subcommand);
    return `'${name}:${desc}' \\`;
  }));
  const commands = isEmptyReadonlyArray(subcommands) ? `commands=()` : `commands=(
${join(indentAll(subcommands, 8), `
`)}
    )`;
  const handlerLines = [`(( $+functions[_${underscoreName}_commands] )) ||`, `_${underscoreName}_commands() {`, `    local commands; ${commands}`, `    _describe -t commands '${spaceName} commands' commands "$@"`, "}"];
  return succeed8(appendAll(state, handlerLines));
}).pipe(map15((handlers) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const cases = getZshSubcommandCases(self, empty2(), empty2());
  const scriptName = `_${rootCommand}_zsh_completions`;
  return [`#compdef ${executable}`, "", "autoload -U is-at-least", "", `function ${scriptName}() {`, "    typeset -A opt_args", "    typeset -a _arguments_options", "    local ret=1", "", "    if is-at-least 5.2; then", "        _arguments_options=(-s -S -C)", "    else", "        _arguments_options=(-s -C)", "    fi", "", '    local context curcontext="$curcontext" state line', ...indentAll(cases, 4), "}", "", ...handlers, "", `if [ "$funcstack[1]" = "${scriptName}" ]; then`, `    ${scriptName} "$@"`, "else", `    compdef ${scriptName} ${rootCommand}`, "fi"];
}));
var getZshSubcommandCases = (self, parentCommands, subcommands) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      const options3 = isStandard(self) ? all8([builtIns, self.options]) : builtIns;
      const args2 = isStandard(self) ? self.args : none11;
      const optionCompletions = pipe(getZshCompletions2(options3), map3((completion) => `'${completion}' \\`));
      const argCompletions = pipe(getZshCompletions3(args2), map3((completion) => `'${completion}' \\`));
      if (isEmptyReadonlyArray(parentCommands)) {
        return ['_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${self.name}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
      }
      if (isEmptyReadonlyArray(subcommands)) {
        return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), "    && ret=0", ";;"];
      }
      return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${append(parentCommands, self.name).join("__")}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
    }
    case "Map": {
      return getZshSubcommandCases(self.command, parentCommands, subcommands);
    }
    case "Subcommands": {
      const nextSubcommands = getSubcommandsInternal(self);
      const parentNames = getNamesInternal(self.parent);
      const parentLines = getZshSubcommandCases(self.parent, parentCommands, appendAll(subcommands, nextSubcommands));
      const childCases = pipe(self.children, flatMap2((child) => getZshSubcommandCases(child, appendAll(parentCommands, parentNames), subcommands)));
      const hyphenName = pipe(appendAll(parentCommands, parentNames), join("-"));
      const childLines = pipe(parentNames, flatMap2((parentName) => ["case $state in", `    (${parentName})`, `    words=($line[1] "\${words[@]}")`, "    (( CURRENT += 1 ))", `    curcontext="\${curcontext%:*:*}:${hyphenName}-command-$line[1]:"`, `    case $line[1] in`, ...indentAll(childCases, 8), "    esac", "    ;;", "esac"]), appendAll(isEmptyReadonlyArray(parentCommands) ? empty2() : of(";;")));
      return appendAll(parentLines, childLines);
    }
  }
};
var helpRequestedError = (command) => {
  const op = Object.create(proto20);
  op._tag = "HelpRequested";
  op.error = empty38;
  op.command = command;
  return op;
};

// node_modules/@effect/cli/dist/esm/ValidationError.js
var helpRequested = helpRequestedError;

// node_modules/effect/dist/esm/Logger.js
var withMinimumLogLevel2 = withMinimumLogLevel;
var defaultLogger2 = defaultLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;

// node_modules/effect/dist/esm/Unify.js
var unify2 = identity;

// node_modules/@effect/cli/dist/esm/internal/cliApp.js
var proto24 = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make66 = (config2) => {
  const op = Object.create(proto24);
  op.name = config2.name;
  op.version = config2.version;
  op.executable = config2.executable;
  op.command = config2.command;
  op.summary = config2.summary || empty37;
  op.footer = config2.footer || empty38;
  return op;
};
var run6 = /* @__PURE__ */ dual(3, (self, args2, execute2) => contextWithEffect2((context8) => {
  const config2 = getOrElse(getOption2(context8, Tag3), () => defaultConfig);
  const [executable, filteredArgs] = splitExecutable(self, args2);
  const prefixedArgs = appendAll(prefixCommand(self.command), filteredArgs);
  return matchEffect2(parse7(self.command, prefixedArgs, config2), {
    onFailure: (e) => zipRight3(printDocs(e.error), fail8(e)),
    onSuccess: unify2((directive) => {
      switch (directive._tag) {
        case "UserDefined": {
          return matchLeft(directive.leftover, {
            onEmpty: () => execute2(directive.value).pipe(catchSome2((e) => isValidationError(e) && isHelpRequested(e) ? some2(handleBuiltInOption(self, executable, filteredArgs, showHelp(getUsage3(e.command), getHelp5(e.command, config2)), execute2, config2)) : none2())),
            onNonEmpty: (head5) => {
              const error4 = p(`Received unknown argument: '${head5}'`);
              return zipRight3(printDocs(error4), fail8(invalidValue(error4)));
            }
          });
        }
        case "BuiltIn": {
          return handleBuiltInOption(self, executable, filteredArgs, directive.option, execute2, config2).pipe(catchSome2((e) => isValidationError(e) ? some2(zipRight3(printDocs(e.error), fail8(e))) : none2()));
        }
      }
    })
  });
}));
var splitExecutable = (self, args2) => {
  if (self.executable !== undefined) {
    return [self.executable, drop(args2, 2)];
  }
  const [[runtime5, script], optionsAndArgs] = splitAt(args2, 2);
  return [`${runtime5} ${script}`, optionsAndArgs];
};
var printDocs = (error4) => error2(toAnsiText(error4));
var isQuitException = (u) => typeof u === "object" && u != null && ("_tag" in u) && u._tag === "QuitException";
var handleBuiltInOption = (self, executable, args2, builtIn2, execute2, config2) => {
  switch (builtIn2._tag) {
    case "SetLogLevel": {
      const nextArgs = executable.split(/\s+/);
      for (let i = 0;i < args2.length; i++) {
        if (args2[i] === "--log-level" || args2[i - 1] === "--log-level") {
          continue;
        }
        nextArgs.push(args2[i]);
      }
      return run6(self, nextArgs, execute2).pipe(withMinimumLogLevel2(builtIn2.level));
    }
    case "ShowHelp": {
      const banner = h1(code(self.name));
      const header = p(spans([text4(`${self.name} ${self.version}`), isEmpty12(self.summary) ? empty37 : spans([space3, text4("--"), space3, self.summary])]));
      const usage = sequence(h1("USAGE"), pipe(enumerate(builtIn2.usage, config2), map3((span3) => p(concat2(text4("$ "), span3))), reduceRight(empty38, (left3, right3) => sequence(left3, right3))));
      const helpDoc = pipe(banner, sequence(header), sequence(usage), sequence(builtIn2.helpDoc), sequence(self.footer));
      return log3(toAnsiText(helpDoc));
    }
    case "ShowCompletions": {
      const command = fromIterable(getNames2(self.command))[0];
      switch (builtIn2.shellType) {
        case "bash": {
          return getBashCompletions3(self.command, command).pipe(flatMap9((completions) => log3(join(completions, `
`))));
        }
        case "fish": {
          return getFishCompletions4(self.command, command).pipe(flatMap9((completions) => log3(join(completions, `
`))));
        }
        case "zsh":
          return getZshCompletions4(self.command, command).pipe(flatMap9((completions) => log3(join(completions, `
`))));
      }
    }
    case "ShowWizard": {
      const summary5 = isEmpty12(self.summary) ? empty37 : spans([space3, text4("--"), space3, self.summary]);
      const instructions = sequence(p(spans([text4("The wizard mode will assist you with constructing commands for"), space3, code(`${self.name} (${self.version})`), text4(".")])), p("Please answer all prompts provided by the wizard."));
      const description = descriptionList([[text4("Instructions"), instructions]]);
      const header = h1(spans([code("Wizard Mode for CLI Application:"), space3, code(self.name), space3, code(`(${self.version})`), summary5]));
      const help = sequence(header, description);
      const text10 = toAnsiText(help);
      const command = fromIterable(getNames2(self.command))[0];
      const wizardPrefix = getWizardPrefix(builtIn2, command, args2);
      return log3(text10).pipe(zipRight3(wizard4(builtIn2.command, wizardPrefix, config2)), tap2((args3) => log3(toAnsiText(renderWizardArgs(args3)))), flatMap9((args3) => toggle2({
        message: "Would you like to run the command?",
        initial: true,
        active: "yes",
        inactive: "no"
      }).pipe(flatMap9((shouldRunCommand) => {
        const finalArgs = pipe(drop(args3, 1), prependAll(executable.split(/\s+/)));
        return shouldRunCommand ? log3().pipe(zipRight3(run6(self, finalArgs, execute2))) : _void;
      }))), catchAll2((e) => {
        if (isQuitException(e)) {
          const message = p(error3(`

Quitting wizard mode...`));
          return log3(toAnsiText(message));
        }
        return fail8(e);
      }));
    }
    case "ShowVersion": {
      const help = p(self.version);
      return log3(toAnsiText(help));
    }
  }
};
var prefixCommand = (self) => {
  let command = self;
  let prefix = empty2();
  while (command !== undefined) {
    switch (command._tag) {
      case "Standard": {
        prefix = of(command.name);
        command = undefined;
        break;
      }
      case "GetUserInput": {
        prefix = of(command.name);
        command = undefined;
        break;
      }
      case "Map": {
        command = command.command;
        break;
      }
      case "Subcommands": {
        command = command.parent;
        break;
      }
    }
  }
  return prefix;
};
var getWizardPrefix = (builtIn2, rootCommand, commandLineArgs) => {
  const subcommands = getSubcommands(builtIn2.command);
  const [parentArgs, childArgs] = span(commandLineArgs, (name) => !has4(subcommands, name));
  const args2 = matchLeft(childArgs, {
    onEmpty: () => filter2(parentArgs, (arg) => arg !== "--wizard"),
    onNonEmpty: (head5) => append(parentArgs, head5)
  });
  return appendAll(rootCommand.split(/\s+/), args2);
};
var renderWizardArgs = (args2) => {
  const params = pipe(filter2(args2, (param) => param.length > 0), join(" "));
  const executeMsg = text4("You may now execute your command directly with the following options and arguments:");
  return blocks([p(strong(code("Wizard Mode Complete!"))), p(executeMsg), p(concat2(text4("    "), highlight(params, cyan2)))]);
};

// node_modules/@effect/cli/dist/esm/internal/command.js
var CommandSymbolKey = "@effect/cli/Command";
var TypeId25 = /* @__PURE__ */ Symbol.for(CommandSymbolKey);
var parseConfig = (config2) => {
  const args2 = [];
  let argsIndex = 0;
  const options3 = [];
  let optionsIndex = 0;
  function parse8(config3) {
    const tree = {};
    for (const key in config3) {
      tree[key] = parseValue(config3[key]);
    }
    return tree;
  }
  function parseValue(value6) {
    if (isArray(value6)) {
      return {
        _tag: "Array",
        children: map3(value6, parseValue)
      };
    } else if (isArgs(value6)) {
      args2.push(value6);
      return {
        _tag: "Args",
        index: argsIndex++
      };
    } else if (isOptions(value6)) {
      options3.push(value6);
      return {
        _tag: "Options",
        index: optionsIndex++
      };
    } else {
      return {
        _tag: "ParsedConfig",
        tree: parse8(value6)
      };
    }
  }
  return {
    args: args2,
    options: options3,
    tree: parse8(config2)
  };
};
var reconstructConfigTree = (tree, args2, options3) => {
  const output = {};
  for (const key in tree) {
    output[key] = nodeValue(tree[key]);
  }
  return output;
  function nodeValue(node) {
    if (node._tag === "Args") {
      return args2[node.index];
    } else if (node._tag === "Options") {
      return options3[node.index];
    } else if (node._tag === "Array") {
      return map3(node.children, nodeValue);
    } else {
      return reconstructConfigTree(node.tree, args2, options3);
    }
  }
};
var Prototype = {
  ...CommitPrototype2,
  [TypeId25]: TypeId25,
  commit() {
    return this.tag;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var registeredDescriptors = /* @__PURE__ */ globalValue("@effect/cli/Command/registeredDescriptors", () => new WeakMap);
var getDescriptor = (self) => registeredDescriptors.get(self.tag) ?? self.descriptor;
var makeProto = (descriptor2, handler, tag4, transform3 = identity) => {
  const self = Object.create(Prototype);
  self.descriptor = descriptor2;
  self.handler = handler;
  self.transform = transform3;
  self.tag = tag4;
  return self;
};
var makeDerive = (self, options3) => {
  const command = Object.create(Prototype);
  command.descriptor = options3.descriptor ?? self.descriptor;
  command.handler = options3.handler ?? self.handler;
  command.transform = options3.transform ? (effect4, opts) => options3.transform(self.transform(effect4, opts), opts) : self.transform;
  command.tag = self.tag;
  return command;
};
var fromDescriptor = /* @__PURE__ */ dual((args2) => isCommand(args2[0]), (descriptor2, handler) => {
  const self = makeProto(descriptor2, handler ?? ((_) => failSync2(() => helpRequested(getDescriptor(self)))), GenericTag(`@effect/cli/Command/(${fromIterable(getNames2(descriptor2)).join("|")})`));
  return self;
});
var makeDescriptor = (name, config2) => {
  const {
    args: args2,
    options: options3,
    tree
  } = parseConfig(config2);
  return map31(make65(name, all8(options3), all10(args2)), ({
    args: args3,
    options: options4
  }) => reconstructConfigTree(tree, args3, options4));
};
var make67 = (name, config2 = {}, handler) => fromDescriptor(makeDescriptor(name, config2), handler);
var mapDescriptor = /* @__PURE__ */ dual(2, (self, f) => makeDerive(self, {
  descriptor: f(self.descriptor)
}));
var withHandler = /* @__PURE__ */ dual(2, (self, handler) => makeDerive(self, {
  handler,
  transform: identity
}));
var withDescription6 = /* @__PURE__ */ dual(2, (self, help) => mapDescriptor(self, withDescription5(help)));
var withSubcommands2 = /* @__PURE__ */ dual(2, (self, subcommands) => {
  const command = withSubcommands(self.descriptor, map3(subcommands, (_) => [_.tag, _.descriptor]));
  const subcommandMap = reduce(subcommands, new Map, (handlers, subcommand) => {
    handlers.set(subcommand.tag, subcommand);
    registeredDescriptors.set(subcommand.tag, subcommand.descriptor);
    return handlers;
  });
  function handler(args2) {
    if (args2.subcommand._tag === "Some") {
      const [tag4, value6] = args2.subcommand.value;
      const subcommand = subcommandMap.get(tag4);
      const subcommandEffect = subcommand.transform(subcommand.handler(value6), value6);
      return provideService2(subcommandEffect, self.tag, args2);
    }
    return self.handler(args2);
  }
  return makeDerive(self, {
    descriptor: command,
    handler
  });
});
var run7 = /* @__PURE__ */ dual(2, (self, config2) => {
  const app = make66({
    ...config2,
    command: self.descriptor
  });
  registeredDescriptors.set(self.tag, self.descriptor);
  const handler = (args2) => self.transform(self.handler(args2), args2);
  return (args2) => run6(app, args2, handler);
});

// node_modules/@effect/cli/dist/esm/Command.js
var make68 = make67;
var withDescription7 = withDescription6;
var withHandler2 = withHandler;
var withSubcommands3 = withSubcommands2;
var run8 = run7;

// node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
var TypeId26 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
var ExitCode = /* @__PURE__ */ nominal();
var ProcessId = /* @__PURE__ */ nominal();
var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
var makeExecutor = (start3) => {
  const stream2 = (command) => unwrapScoped6(map15(start3(command), (process2) => process2.stdout));
  const streamLines = (command, encoding) => {
    const decoder2 = new TextDecoder(encoding);
    return splitLines3(mapChunks2(stream2(command), map4((bytes) => decoder2.decode(bytes))));
  };
  return {
    [TypeId26]: TypeId26,
    start: start3,
    exitCode: (command) => scoped2(flatMap9(start3(command), (process2) => process2.exitCode)),
    stream: stream2,
    string: (command, encoding = "utf-8") => {
      const decoder2 = new TextDecoder(encoding);
      return pipe(start3(command), flatMap9((process2) => run4(process2.stdout, collectUint8Array)), map15((bytes) => decoder2.decode(bytes)), scoped2);
    },
    lines: (command, encoding = "utf-8") => {
      return pipe(streamLines(command, encoding), runCollect3, map15(toArray2));
    },
    streamLines
  };
};
var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array, (bytes, chunk4) => reduce2(chunk4, bytes, (acc, curr) => {
  const newArray = new Uint8Array(acc.length + curr.length);
  newArray.set(acc);
  newArray.set(curr, acc.length);
  return newArray;
}));

// node_modules/@effect/platform/dist/esm/internal/command.js
var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
var flatten15 = (self) => Array.from(flattenLoop(self));
var flattenLoop = (self) => {
  switch (self._tag) {
    case "StandardCommand": {
      return of2(self);
    }
    case "PipedCommand": {
      return appendAll2(flattenLoop(self.left), flattenLoop(self.right));
    }
  }
};
var Proto3 = {
  [CommandTypeId]: CommandTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto
};
var StandardProto = {
  ...Proto3,
  _tag: "StandardCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      command: this.command,
      args: this.args,
      env: Object.fromEntries(this.env),
      cwd: this.cwd.toJSON(),
      shell: this.shell,
      gid: this.gid.toJSON(),
      uid: this.uid.toJSON()
    };
  }
};
var makeStandard = (options3) => Object.assign(Object.create(StandardProto), options3);
var PipedProto = {
  ...Proto3,
  _tag: "PipedCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      left: this.left.toJSON(),
      right: this.right.toJSON()
    };
  }
};
var makePiped = (options3) => Object.assign(Object.create(PipedProto), options3);
var stdin = /* @__PURE__ */ dual(2, (self, input) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stdin: input
      });
    }
    case "PipedCommand": {
      return makePiped({
        ...self,
        left: stdin(self.left, input)
      });
    }
  }
});

// node_modules/@effect/platform/dist/esm/Command.js
var flatten16 = flatten15;
var stdin2 = stdin;

// node_modules/@effect/platform/dist/esm/CommandExecutor.js
var CommandExecutor2 = CommandExecutor;
var ProcessTypeId2 = ProcessTypeId;
var ExitCode2 = ExitCode;
var ProcessId2 = ProcessId;
var makeExecutor2 = makeExecutor;

// node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
import * as ChildProcess from "child_process";

// node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
var handleErrnoException = (module, method) => (err, [path2]) => {
  let reason = "Unknown";
  switch (err.code) {
    case "ENOENT":
      reason = "NotFound";
      break;
    case "EACCES":
      reason = "PermissionDenied";
      break;
    case "EEXIST":
      reason = "AlreadyExists";
      break;
    case "EISDIR":
      reason = "BadResource";
      break;
    case "ENOTDIR":
      reason = "BadResource";
      break;
    case "EBUSY":
      reason = "Busy";
      break;
    case "ELOOP":
      reason = "BadResource";
      break;
  }
  return SystemError({
    reason,
    module,
    method,
    pathOrDescriptor: path2,
    syscall: err.syscall,
    message: err.message
  });
};

// node_modules/effect/dist/esm/internal/mailbox.js
var TypeId27 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty42 = /* @__PURE__ */ empty5();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty42);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty42, true];

class MailboxImpl extends Class {
  scheduler;
  capacity;
  strategy;
  [TypeId27] = TypeId27;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set,
    offers: /* @__PURE__ */ new Set,
    awaiters: /* @__PURE__ */ new Set
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty5();
  constructor(scheduler, capacity7, strategy) {
    super();
    this.scheduler = scheduler;
    this.capacity = capacity7;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause2) {
    return this.done(exitFailCause(cause2));
  }
  unsafeDone(exit3) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit3);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit3
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty42;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit3) {
    return sync(() => this.unsafeDone(exit3));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty42);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty42, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : undefined;
    } else {
      return;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size17 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size17);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0)
        return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (;entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0)
            return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty42;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty42;
  }
  finalize(exit3) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit3
    };
    for (const taker of openState.takers) {
      taker(exit3);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit3);
    }
    openState.awaiters.clear();
  }
}
var make70 = (capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend")));
var toChannel3 = (self) => {
  const loop2 = flatMap12(self.takeAll, ([messages, done11]) => done11 ? messages.length === 0 ? void_5 : write(messages) : zipRight4(write(messages), loop2));
  return loop2;
};

// node_modules/effect/dist/esm/Mailbox.js
var TypeId28 = TypeId27;
var isMailbox = (u) => hasProperty(u, TypeId28);
var make71 = make70;
var toChannel4 = toChannel3;

// node_modules/@effect/platform-node-shared/dist/esm/internal/stream.js
var fromReadable = (evaluate2, onError4, {
  chunkSize
} = {}) => fromChannel4(fromReadableChannel(evaluate2, onError4, chunkSize ? Number(chunkSize) : undefined));
var fromReadableChannel = (evaluate2, onError4, chunkSize) => acquireUseRelease4(tap2(zip5(sync3(evaluate2), make71()), ([readable, mailbox]) => readableOffer(readable, mailbox, onError4)), ([readable, mailbox]) => readableTake(readable, mailbox, chunkSize), ([readable, mailbox]) => zipRight3(sync3(() => {
  if ("closed" in readable && !readable.closed) {
    readable.destroy();
  }
}), mailbox.shutdown));
var writeInput = (writable, onFailure, {
  encoding,
  endOnDone = true
} = {}, onDone2 = _void) => {
  const write3 = writeEffect(writable, encoding);
  const close2 = endOnDone ? async((resume2) => {
    if ("closed" in writable && writable.closed) {
      resume2(_void);
    } else {
      writable.once("finish", () => resume2(_void));
      writable.end();
    }
  }) : _void;
  return {
    awaitRead: () => _void,
    emit: write3,
    error: (cause2) => zipRight3(close2, onFailure(cause2)),
    done: (_) => zipRight3(close2, onDone2)
  };
};
var writeEffect = (writable, encoding) => (chunk4) => chunk4.length === 0 ? _void : async((resume2) => {
  const iterator = chunk4[Symbol.iterator]();
  let next4 = iterator.next();
  function loop2() {
    const item = next4;
    next4 = iterator.next();
    const success = writable.write(item.value, encoding);
    if (next4.done) {
      resume2(_void);
    } else if (success) {
      loop2();
    } else {
      writable.once("drain", loop2);
    }
  }
  loop2();
});
var readableOffer = (readable, mailbox, onError4) => sync3(() => {
  readable.on("readable", () => {
    mailbox.unsafeOffer(undefined);
  });
  readable.on("error", (err) => {
    mailbox.unsafeDone(fail4(onError4(err)));
  });
  readable.on("end", () => {
    mailbox.unsafeDone(void_3);
  });
  if (readable.readable) {
    mailbox.unsafeOffer(undefined);
  }
});
var readableTake = (readable, mailbox, chunkSize) => {
  const read3 = readChunkChannel(readable, chunkSize);
  const loop2 = flatMap16(mailbox.takeAll, ([, done11]) => done11 ? read3 : zipRight8(read3, loop2));
  return loop2;
};
var readChunkChannel = (readable, chunkSize) => suspend10(() => {
  const arr = [];
  let chunk4 = readable.read(chunkSize);
  if (chunk4 === null) {
    return void_7;
  }
  while (chunk4 !== null) {
    arr.push(chunk4);
    chunk4 = readable.read(chunkSize);
  }
  return write2(unsafeFromArray(arr));
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
var fromWritable = (evaluate2, onError4, options3) => fromChannel3(fromWritableChannel(evaluate2, onError4, options3));
var fromWritableChannel = (writable, onError4, options3) => flatMap16(zip5(sync3(() => writable()), make24()), ([writable2, deferred]) => embedInput2(writableOutput(writable2, deferred, onError4), writeInput(writable2, (cause2) => failCause2(deferred, cause2), options3, complete(deferred, _void))));
var writableOutput = (writable, deferred, onError4) => suspend3(() => {
  function handleError(err) {
    unsafeDone(deferred, fail8(onError4(err)));
  }
  writable.on("error", handleError);
  return ensuring2(_await(deferred), sync3(() => {
    writable.removeListener("error", handleError);
  }));
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
var inputToStdioOption = (stdin3) => typeof stdin3 === "string" ? stdin3 : "pipe";
var outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
var toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
var toPlatformError = (method, error4, command) => {
  const flattened2 = flatten16(command).reduce((acc, curr) => {
    const command2 = `${curr.command} ${curr.args.join(" ")}`;
    return acc.length === 0 ? command2 : `${acc} | ${command2}`;
  }, "");
  return handleErrnoException("Command", method)(error4, [flattened2]);
};
var ProcessProto = {
  [ProcessTypeId2]: ProcessTypeId2,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/CommandExecutor/Process",
      pid: this.pid
    };
  }
};
var runCommand = (fileSystem) => (command) => {
  switch (command._tag) {
    case "StandardCommand": {
      const spawn2 = flatMap9(make24(), (exitCode2) => async((resume2) => {
        const handle = ChildProcess.spawn(command.command, command.args, {
          stdio: [inputToStdioOption(command.stdin), outputToStdioOption(command.stdout), outputToStdioOption(command.stderr)],
          cwd: getOrElse(command.cwd, constUndefined),
          shell: command.shell,
          env: {
            ...process.env,
            ...Object.fromEntries(command.env)
          }
        });
        handle.on("error", (err) => {
          resume2(fail8(toPlatformError("spawn", err, command)));
        });
        handle.on("exit", (...args2) => {
          unsafeDone(exitCode2, succeed8(args2));
        });
        handle.on("spawn", () => {
          resume2(succeed8([handle, exitCode2]));
        });
        return sync3(() => {
          handle.kill("SIGTERM");
        });
      }));
      return pipe(match2(command.cwd, {
        onNone: () => _void,
        onSome: (dir2) => fileSystem.access(dir2)
      }), zipRight3(acquireRelease2(spawn2, ([handle, exitCode2]) => flatMap9(isDone(exitCode2), (done11) => done11 ? _void : suspend3(() => {
        if (handle.kill("SIGTERM")) {
          return _await(exitCode2);
        }
        return _void;
      })))), map15(([handle, exitCodeDeferred]) => {
        let stdin3 = drain3;
        if (handle.stdin !== null) {
          stdin3 = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command));
        }
        const exitCode2 = flatMap9(_await(exitCodeDeferred), ([code2, signal]) => {
          if (code2 !== null) {
            return succeed8(ExitCode2(code2));
          }
          return fail8(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command));
        });
        const isRunning4 = negate2(isDone(exitCodeDeferred));
        const kill = (signal = "SIGTERM") => suspend3(() => handle.kill(signal) ? asVoid2(_await(exitCodeDeferred)) : fail8(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command)));
        const pid = ProcessId2(handle.pid);
        const stderr2 = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command));
        let stdout2 = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command));
        if (typeof command.stdout !== "string") {
          stdout2 = transduce2(stdout2, command.stdout);
        }
        return Object.assign(Object.create(ProcessProto), {
          pid,
          exitCode: exitCode2,
          isRunning: isRunning4,
          kill,
          stdin: stdin3,
          stderr: stderr2,
          stdout: stdout2
        });
      }), typeof command.stdin === "string" ? identity : tap2((process2) => forkDaemon2(run4(command.stdin, process2.stdin))));
    }
    case "PipedCommand": {
      const flattened2 = flatten16(command);
      if (flattened2.length === 1) {
        return pipe(flattened2[0], runCommand(fileSystem));
      }
      const head5 = flattened2[0];
      const tail = flattened2.slice(1);
      const initial = tail.slice(0, tail.length - 1);
      const last5 = tail[tail.length - 1];
      const stream3 = initial.reduce((stdin3, command2) => pipe(stdin2(command2, stdin3), runCommand(fileSystem), map15((process2) => process2.stdout), unwrapScoped6), pipe(runCommand(fileSystem)(head5), map15((process2) => process2.stdout), unwrapScoped6));
      return pipe(stdin2(last5, stream3), runCommand(fileSystem));
    }
  }
};
var layer2 = /* @__PURE__ */ effect(CommandExecutor2, /* @__PURE__ */ pipe(FileSystem, /* @__PURE__ */ map15((fileSystem) => makeExecutor2(runCommand(fileSystem)))));

// node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
var layer3 = layer2;

// node_modules/@effect/platform/dist/esm/internal/effectify.js
var effectify = (fn, onError4, onSyncError) => (...args2) => async((resume2) => {
  try {
    fn(...args2, (err, result) => {
      if (err) {
        resume2(fail8(onError4 ? onError4(err, args2) : err));
      } else {
        resume2(succeed8(result));
      }
    });
  } catch (err) {
    resume2(onSyncError ? fail8(onSyncError(err, args2)) : die5(err));
  }
});

// node_modules/@effect/platform/dist/esm/Effectify.js
var effectify2 = effectify;

// node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
import * as Crypto from "crypto";
import * as NFS from "fs";
import * as OS from "os";
import * as Path3 from "path";
var handleBadArgument = (method) => (err) => BadArgument({
  module: "FileSystem",
  method,
  message: err.message ?? String(err)
});
var access2 = /* @__PURE__ */ (() => {
  const nodeAccess = /* @__PURE__ */ effectify2(NFS.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
  return (path2, options3) => {
    let mode = NFS.constants.F_OK;
    if (options3?.readable) {
      mode |= NFS.constants.R_OK;
    }
    if (options3?.writable) {
      mode |= NFS.constants.W_OK;
    }
    return nodeAccess(path2, mode);
  };
})();
var copy4 = /* @__PURE__ */ (() => {
  const nodeCp = /* @__PURE__ */ effectify2(NFS.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
  return (fromPath, toPath, options3) => nodeCp(fromPath, toPath, {
    force: options3?.overwrite ?? false,
    preserveTimestamps: options3?.preserveTimestamps ?? false,
    recursive: true
  });
})();
var copyFile2 = /* @__PURE__ */ (() => {
  const nodeCopyFile = /* @__PURE__ */ effectify2(NFS.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
  return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
})();
var chmod2 = /* @__PURE__ */ (() => {
  const nodeChmod = /* @__PURE__ */ effectify2(NFS.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
  return (path2, mode) => nodeChmod(path2, mode);
})();
var chown2 = /* @__PURE__ */ (() => {
  const nodeChown = /* @__PURE__ */ effectify2(NFS.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
  return (path2, uid, gid) => nodeChown(path2, uid, gid);
})();
var link2 = /* @__PURE__ */ (() => {
  const nodeLink = /* @__PURE__ */ effectify2(NFS.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
  return (existingPath, newPath) => nodeLink(existingPath, newPath);
})();
var makeDirectory = /* @__PURE__ */ (() => {
  const nodeMkdir = /* @__PURE__ */ effectify2(NFS.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
  return (path2, options3) => nodeMkdir(path2, {
    recursive: options3?.recursive ?? false,
    mode: options3?.mode
  });
})();
var makeTempDirectoryFactory = (method) => {
  const nodeMkdtemp = effectify2(NFS.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (options3) => suspend3(() => {
    const prefix = options3?.prefix ?? "";
    const directory2 = typeof options3?.directory === "string" ? Path3.join(options3.directory, ".") : OS.tmpdir();
    return nodeMkdtemp(prefix ? Path3.join(directory2, prefix) : directory2 + "/");
  });
};
var makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
var removeFactory = (method) => {
  const nodeRm = effectify2(NFS.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => nodeRm(path2, {
    recursive: options3?.recursive ?? false,
    force: options3?.force ?? false
  });
};
var remove9 = /* @__PURE__ */ removeFactory("remove");
var makeTempDirectoryScoped = /* @__PURE__ */ (() => {
  const makeDirectory2 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
  return (options3) => acquireRelease2(makeDirectory2(options3), (directory2) => orDie2(removeDirectory(directory2, {
    recursive: true
  })));
})();
var openFactory = (method) => {
  const nodeOpen = effectify2(NFS.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeClose = effectify2(NFS.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => pipe(acquireRelease2(nodeOpen(path2, options3?.flag ?? "r", options3?.mode), (fd) => orDie2(nodeClose(fd))), map15((fd) => makeFile(FileDescriptor(fd), options3?.flag?.startsWith("a") ?? false)));
};
var open2 = /* @__PURE__ */ openFactory("open");
var makeFile = /* @__PURE__ */ (() => {
  const nodeReadFactory = (method) => effectify2(NFS.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
  const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
  const nodeStat = /* @__PURE__ */ effectify2(NFS.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  const nodeWriteFactory = (method) => effectify2(NFS.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
  const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");

  class FileImpl {
    fd;
    append;
    [FileTypeId];
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore2(1);
    position = 0n;
    constructor(fd, append4) {
      this.fd = fd;
      this.append = append4;
      this[FileTypeId] = FileTypeId;
    }
    get stat() {
      return map15(nodeStat(this.fd), makeFileInfo);
    }
    seek(offset, from) {
      const offsetSize = Size2(offset);
      return this.semaphore.withPermits(1)(sync3(() => {
        if (from === "start") {
          this.position = offsetSize;
        } else if (from === "current") {
          this.position = this.position + offsetSize;
        }
        return this.position;
      }));
    }
    read(buffer3) {
      return this.semaphore.withPermits(1)(map15(suspend3(() => nodeRead(this.fd, {
        buffer: buffer3,
        position: this.position
      })), (bytesRead) => {
        const sizeRead = Size2(bytesRead);
        this.position = this.position + sizeRead;
        return sizeRead;
      }));
    }
    readAlloc(size17) {
      const sizeNumber = Number(size17);
      return this.semaphore.withPermits(1)(flatMap9(sync3(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer3) => map15(nodeReadAlloc(this.fd, {
        buffer: buffer3,
        position: this.position
      }), (bytesRead) => {
        if (bytesRead === 0) {
          return none2();
        }
        this.position = this.position + BigInt(bytesRead);
        if (bytesRead === sizeNumber) {
          return some2(buffer3);
        }
        const dst = Buffer.allocUnsafeSlow(bytesRead);
        buffer3.copy(dst, 0, 0, bytesRead);
        return some2(dst);
      })));
    }
    truncate(length3) {
      return this.semaphore.withPermits(1)(map15(nodeTruncate(this.fd, length3 ? Number(length3) : undefined), () => {
        if (!this.append) {
          const len = BigInt(length3 ?? 0);
          if (this.position > len) {
            this.position = len;
          }
        }
      }));
    }
    write(buffer3) {
      return this.semaphore.withPermits(1)(map15(suspend3(() => nodeWrite(this.fd, buffer3, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
        const sizeWritten = Size2(bytesWritten);
        if (!this.append) {
          this.position = this.position + sizeWritten;
        }
        return sizeWritten;
      }));
    }
    writeAllChunk(buffer3) {
      return flatMap9(suspend3(() => nodeWriteAll(this.fd, buffer3, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
        if (bytesWritten === 0) {
          return fail8(SystemError({
            module: "FileSystem",
            method: "writeAll",
            reason: "WriteZero",
            pathOrDescriptor: this.fd,
            message: "write returned 0 bytes written"
          }));
        }
        if (!this.append) {
          this.position = this.position + BigInt(bytesWritten);
        }
        return bytesWritten < buffer3.length ? this.writeAllChunk(buffer3.subarray(bytesWritten)) : _void;
      });
    }
    writeAll(buffer3) {
      return this.semaphore.withPermits(1)(this.writeAllChunk(buffer3));
    }
  }
  return (fd, append4) => new FileImpl(fd, append4);
})();
var makeTempFileFactory = (method) => {
  const makeDirectory2 = makeTempDirectoryFactory(method);
  const open3 = openFactory(method);
  const randomHexString2 = (bytes) => sync3(() => Crypto.randomBytes(bytes).toString("hex"));
  return (options3) => pipe(zip5(makeDirectory2(options3), randomHexString2(6)), map15(([directory2, random3]) => Path3.join(directory2, random3)), tap2((path2) => scoped2(open3(path2, {
    flag: "w+"
  }))));
};
var makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
var makeTempFileScoped = /* @__PURE__ */ (() => {
  const makeFile2 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
  return (options3) => acquireRelease2(makeFile2(options3), (file3) => orDie2(removeDirectory(Path3.dirname(file3), {
    recursive: true
  })));
})();
var readDirectory = (path2, options3) => tryPromise2({
  try: () => NFS.promises.readdir(path2, options3),
  catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path2])
});
var readFile2 = (path2) => async((resume2, signal) => {
  try {
    NFS.readFile(path2, {
      signal
    }, (err, data) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "readFile")(err, [path2])));
      } else {
        resume2(succeed8(data));
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("readFile")(err)));
  }
});
var readLink = /* @__PURE__ */ (() => {
  const nodeReadLink = /* @__PURE__ */ effectify2(NFS.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
  return (path2) => nodeReadLink(path2);
})();
var realPath = /* @__PURE__ */ (() => {
  const nodeRealPath = /* @__PURE__ */ effectify2(NFS.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
  return (path2) => nodeRealPath(path2);
})();
var rename3 = /* @__PURE__ */ (() => {
  const nodeRename = /* @__PURE__ */ effectify2(NFS.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
  return (oldPath, newPath) => nodeRename(oldPath, newPath);
})();
var makeFileInfo = (stat2) => ({
  type: stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : stat2.isBlockDevice() ? "BlockDevice" : stat2.isCharacterDevice() ? "CharacterDevice" : stat2.isFIFO() ? "FIFO" : stat2.isSocket() ? "Socket" : "Unknown",
  mtime: fromNullable(stat2.mtime),
  atime: fromNullable(stat2.atime),
  birthtime: fromNullable(stat2.birthtime),
  dev: stat2.dev,
  rdev: fromNullable(stat2.rdev),
  ino: fromNullable(stat2.ino),
  mode: stat2.mode,
  nlink: fromNullable(stat2.nlink),
  uid: fromNullable(stat2.uid),
  gid: fromNullable(stat2.gid),
  size: Size2(stat2.size),
  blksize: fromNullable(Size2(stat2.blksize)),
  blocks: fromNullable(stat2.blocks)
});
var stat2 = /* @__PURE__ */ (() => {
  const nodeStat = /* @__PURE__ */ effectify2(NFS.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  return (path2) => map15(nodeStat(path2), makeFileInfo);
})();
var symlink2 = /* @__PURE__ */ (() => {
  const nodeSymlink = /* @__PURE__ */ effectify2(NFS.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
  return (target, path2) => nodeSymlink(target, path2);
})();
var truncate2 = /* @__PURE__ */ (() => {
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  return (path2, length3) => nodeTruncate(path2, length3 !== undefined ? Number(length3) : undefined);
})();
var utimes2 = /* @__PURE__ */ (() => {
  const nodeUtimes = /* @__PURE__ */ effectify2(NFS.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
  return (path2, atime, mtime) => nodeUtimes(path2, atime, mtime);
})();
var watchNode = (path2) => asyncScoped2((emit2) => acquireRelease2(sync3(() => {
  const watcher = NFS.watch(path2, {}, (event, path3) => {
    if (!path3)
      return;
    switch (event) {
      case "rename": {
        emit2.fromEffect(match12(stat2(path3), {
          onSuccess: (_) => WatchEventCreate({
            path: path3
          }),
          onFailure: (_) => WatchEventRemove({
            path: path3
          })
        }));
        return;
      }
      case "change": {
        emit2.single(WatchEventUpdate({
          path: path3
        }));
        return;
      }
    }
  });
  watcher.on("error", (error4) => {
    emit2.fail(SystemError({
      module: "FileSystem",
      reason: "Unknown",
      method: "watch",
      pathOrDescriptor: path2,
      message: error4.message
    }));
  });
  watcher.on("close", () => {
    emit2.end();
  });
  return watcher;
}), (watcher) => sync3(() => watcher.close())));
var watch2 = (backend, path2) => stat2(path2).pipe(map15((stat3) => backend.pipe(flatMap((_) => _.register(path2, stat3)), getOrElse(() => watchNode(path2)))), unwrap5);
var writeFile2 = (path2, data, options3) => async((resume2, signal) => {
  try {
    NFS.writeFile(path2, data, {
      signal,
      flag: options3?.flag,
      mode: options3?.mode
    }, (err) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "writeFile")(err, [path2])));
      } else {
        resume2(_void);
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("writeFile")(err)));
  }
});
var makeFileSystem = /* @__PURE__ */ map15(/* @__PURE__ */ serviceOption2(WatchBackend), (backend) => make60({
  access: access2,
  chmod: chmod2,
  chown: chown2,
  copy: copy4,
  copyFile: copyFile2,
  link: link2,
  makeDirectory,
  makeTempDirectory,
  makeTempDirectoryScoped,
  makeTempFile,
  makeTempFileScoped,
  open: open2,
  readDirectory,
  readFile: readFile2,
  readLink,
  realPath,
  remove: remove9,
  rename: rename3,
  stat: stat2,
  symlink: symlink2,
  truncate: truncate2,
  utimes: utimes2,
  watch(path2) {
    return watch2(backend, path2);
  },
  writeFile: writeFile2
}));
var layer4 = /* @__PURE__ */ effect(FileSystem, makeFileSystem);

// node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
var layer5 = layer4;

// node_modules/@effect/platform-node-shared/dist/esm/internal/path.js
import * as NodePath from "path";
import * as NodeUrl from "url";
var fromFileUrl2 = (url2) => try_2({
  try: () => NodeUrl.fileURLToPath(url2),
  catch: (error4) => BadArgument({
    module: "Path",
    method: "fromFileUrl",
    message: `${error4}`
  })
});
var toFileUrl2 = (path2) => try_2({
  try: () => NodeUrl.pathToFileURL(path2),
  catch: (error4) => BadArgument({
    module: "Path",
    method: "toFileUrl",
    message: `${error4}`
  })
});
var layerPosix = /* @__PURE__ */ succeed11(Path2, /* @__PURE__ */ Path2.of({
  [TypeId23]: TypeId23,
  ...NodePath.posix,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layerWin32 = /* @__PURE__ */ succeed11(Path2, /* @__PURE__ */ Path2.of({
  [TypeId23]: TypeId23,
  ...NodePath.win32,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layer6 = /* @__PURE__ */ succeed11(Path2, /* @__PURE__ */ Path2.of({
  [TypeId23]: TypeId23,
  ...NodePath,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));

// node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
var layer7 = layer6;

// node_modules/@effect/platform-node-shared/dist/esm/internal/terminal.js
import * as readline from "readline";
var defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
var make72 = (shouldQuit = defaultShouldQuit) => gen2(function* (_) {
  const input = yield* _(sync3(() => globalThis.process.stdin));
  const output = yield* _(sync3(() => globalThis.process.stdout));
  const acquireReadlineInterface = sync3(() => readline.createInterface({
    input,
    escapeCodeTimeout: 50
  }));
  const emitKeypressEvents2 = (rl) => {
    readline.emitKeypressEvents(input, rl);
    if (input.isTTY) {
      input.setRawMode(true);
    }
    return rl;
  };
  const releaseReadlineInterface = (rl) => sync3(() => {
    if (input.isTTY) {
      input.setRawMode(false);
    }
    rl.close();
  });
  const handleKeypressEvent = (input2) => async((resume2) => {
    const handleKeypress = (input3, key) => {
      const userInput = {
        input: fromNullable(input3),
        key: {
          name: key.name || "",
          ctrl: key.ctrl || false,
          meta: key.meta || false,
          shift: key.shift || false
        }
      };
      if (shouldQuit(userInput)) {
        resume2(fail8(new QuitException));
      } else {
        resume2(succeed8(userInput));
      }
    };
    input2.once("keypress", handleKeypress);
    return sync3(() => {
      input2.removeListener("keypress", handleKeypress);
    });
  });
  const handleLineEvent = (rl) => async((resume2) => {
    const handleLine = (line4) => {
      resume2(succeed8(line4));
    };
    rl.on("line", handleLine);
    return sync3(() => {
      rl.removeListener("line", handleLine);
    });
  });
  const readInput = acquireUseRelease2(acquireReadlineInterface.pipe(map15(emitKeypressEvents2)), () => handleKeypressEvent(input), releaseReadlineInterface);
  const readLine = acquireUseRelease2(acquireReadlineInterface, (rl) => handleLineEvent(rl), releaseReadlineInterface);
  const display = (prompt4) => uninterruptible2(async((resume2) => {
    output.write(prompt4, (err) => {
      if (err) {
        resume2(fail8(BadArgument({
          module: "Terminal",
          method: "display",
          message: err.message ?? String(err)
        })));
      }
      resume2(_void);
    });
  }));
  return Terminal.of({
    columns: sync3(() => output.columns || 0),
    readInput,
    readLine,
    display
  });
});
var layer8 = /* @__PURE__ */ scoped3(Terminal, /* @__PURE__ */ make72(defaultShouldQuit));

// node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
var layer9 = layer8;

// node_modules/@effect/schema/dist/esm/internal/util.js
var getKeysForIndexSignature2 = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature2(input, parameter.from);
  }
};
var ownKeys2 = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk2 = (f) => {
  let done11 = false;
  let a;
  return () => {
    if (done11) {
      return a;
    }
    a = f();
    done11 = true;
    return a;
  };
};
var formatDate2 = (date5) => {
  try {
    return date5.toISOString();
  } catch (e) {
    return String(date5);
  }
};
var formatUnknown2 = (u) => {
  if (isString(u)) {
    return JSON.stringify(u);
  } else if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  } else if (isDate(u)) {
    return formatDate2(u);
  } else if (isBigInt(u)) {
    return String(u) + "n";
  } else if (!isArray(u) && hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  try {
    JSON.stringify(u);
    if (isArray(u)) {
      return `[${u.map(formatUnknown2).join(",")}]`;
    } else {
      return `{${ownKeys2(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown2(u[k])}`).join(",")}}`;
    }
  } catch (e) {
    return String(u);
  }
};
var formatPropertyKey2 = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty7 = (x) => Array.isArray(x);
var isSingle3 = (x) => !Array.isArray(x);
var formatPathKey2 = (key) => `[${formatPropertyKey2(key)}]`;
var formatPath2 = (path2) => isNonEmpty7(path2) ? path2.map(formatPathKey2).join("") : formatPathKey2(path2);

// node_modules/@effect/schema/dist/esm/internal/errors.js
var getErrorMessage2 = (reason, details, path2, ast) => {
  let out = reason;
  if (path2 && isNonEmptyReadonlyArray(path2)) {
    out += `
at path: ${formatPath2(path2)}`;
  }
  if (details !== undefined) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getSchemaExtendErrorMessage2 = (x, y, path2) => getErrorMessage2("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path2);
var getASTUnsupportedKeySchema = (ast) => getErrorMessage2("Unsupported key schema", undefined, undefined, ast);
var getASTUnsupportedLiteral = (literal2) => getErrorMessage2("Unsupported literal", `literal value: ${formatUnknown2(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage2 = (type2) => getErrorMessage2("Duplicate index signature", `${type2} index signature`);
var getASTIndexSignatureParameterErrorMessage2 = /* @__PURE__ */ getErrorMessage2("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage2 = /* @__PURE__ */ getErrorMessage2("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage2 = (key) => getErrorMessage2("Duplicate property signature transformation", `Duplicate key ${formatUnknown2(key)}`);
var getASTDuplicatePropertySignatureErrorMessage2 = (key) => getErrorMessage2("Duplicate property signature", `Duplicate key ${formatUnknown2(key)}`);

// node_modules/@effect/schema/dist/esm/AST.js
var TypeAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Type");
var MessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Message");
var MissingMessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/MissingMessage");
var IdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Identifier");
var TitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Title");
var DescriptionAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Description");
var ExamplesAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Examples");
var DefaultAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Default");
var JSONSchemaAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONSchema");
var DocumentationAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Documentation");
var ConcurrencyAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Concurrency");
var BatchingAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Batching");
var ParseIssueTitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseOptions");
var DecodingFallbackAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/DecodingFallback");
var SurrogateAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Surrogate");
var StableFilterAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/StableFilter");
var getAnnotation2 = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MessageAnnotationId2);
var getMissingMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MissingMessageAnnotationId2);
var getTitleAnnotation2 = /* @__PURE__ */ getAnnotation2(TitleAnnotationId2);
var getIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(IdentifierAnnotationId2);
var getDescriptionAnnotation2 = /* @__PURE__ */ getAnnotation2(DescriptionAnnotationId2);
var getConcurrencyAnnotation2 = /* @__PURE__ */ getAnnotation2(ConcurrencyAnnotationId2);
var getBatchingAnnotation2 = /* @__PURE__ */ getAnnotation2(BatchingAnnotationId2);
var getParseIssueTitleAnnotation3 = /* @__PURE__ */ getAnnotation2(ParseIssueTitleAnnotationId2);
var getParseOptionsAnnotation2 = /* @__PURE__ */ getAnnotation2(ParseOptionsAnnotationId2);
var getDecodingFallbackAnnotation2 = /* @__PURE__ */ getAnnotation2(DecodingFallbackAnnotationId2);
var getSurrogateAnnotation2 = /* @__PURE__ */ getAnnotation2(SurrogateAnnotationId2);
var getStableFilterAnnotation2 = /* @__PURE__ */ getAnnotation2(StableFilterAnnotationId2);
var hasStableFilter2 = (annotated) => exists(getStableFilterAnnotation2(annotated), (b) => b === true);
var JSONIdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(JSONIdentifierAnnotationId2);

class Declaration2 {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown4, encodeUnknown2, annotations2 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown2;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var createASTGuard2 = (tag4) => (ast) => ast._tag === tag4;
class Literal3 {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal2, annotations2 = {}) {
    this.literal = literal2;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatUnknown2(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isLiteral2 = /* @__PURE__ */ createASTGuard2("Literal");
class UniqueSymbol2 {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations2 = {}) {
    this.symbol = symbol3;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatUnknown2(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
class UndefinedKeyword2 {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var undefinedKeyword2 = /* @__PURE__ */ new UndefinedKeyword2({
  [TitleAnnotationId2]: "undefined"
});
class VoidKeyword2 {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var voidKeyword2 = /* @__PURE__ */ new VoidKeyword2({
  [TitleAnnotationId2]: "void"
});
class NeverKeyword2 {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var neverKeyword2 = /* @__PURE__ */ new NeverKeyword2({
  [TitleAnnotationId2]: "never"
});
class UnknownKeyword2 {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var unknownKeyword2 = /* @__PURE__ */ new UnknownKeyword2({
  [TitleAnnotationId2]: "unknown"
});
class AnyKeyword2 {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var anyKeyword2 = /* @__PURE__ */ new AnyKeyword2({
  [TitleAnnotationId2]: "any"
});
class StringKeyword2 {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var stringKeyword2 = /* @__PURE__ */ new StringKeyword2({
  [TitleAnnotationId2]: "string",
  [DescriptionAnnotationId2]: "a string"
});
var isStringKeyword2 = /* @__PURE__ */ createASTGuard2("StringKeyword");

class NumberKeyword2 {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var numberKeyword2 = /* @__PURE__ */ new NumberKeyword2({
  [TitleAnnotationId2]: "number",
  [DescriptionAnnotationId2]: "a number"
});
var isNumberKeyword2 = /* @__PURE__ */ createASTGuard2("NumberKeyword");

class BooleanKeyword2 {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var booleanKeyword2 = /* @__PURE__ */ new BooleanKeyword2({
  [TitleAnnotationId2]: "boolean",
  [DescriptionAnnotationId2]: "a boolean"
});
var isBooleanKeyword2 = /* @__PURE__ */ createASTGuard2("BooleanKeyword");

class BigIntKeyword2 {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var bigIntKeyword2 = /* @__PURE__ */ new BigIntKeyword2({
  [TitleAnnotationId2]: "bigint",
  [DescriptionAnnotationId2]: "a bigint"
});
class SymbolKeyword2 {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var symbolKeyword2 = /* @__PURE__ */ new SymbolKeyword2({
  [TitleAnnotationId2]: "symbol",
  [DescriptionAnnotationId2]: "a symbol"
});
var isSymbolKeyword2 = /* @__PURE__ */ createASTGuard2("SymbolKeyword");

class ObjectKeyword2 {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var objectKeyword2 = /* @__PURE__ */ new ObjectKeyword2({
  [TitleAnnotationId2]: "object",
  [DescriptionAnnotationId2]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Type3 {
  type;
  annotations;
  constructor(type2, annotations2 = {}) {
    this.type = type2;
    this.annotations = annotations2;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType2 extends Type3 {
  isOptional;
  constructor(type2, isOptional, annotations2 = {}) {
    super(type2, annotations2);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs2 = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType2 {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations2 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations2;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage2);
    }
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatTuple2(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var formatTuple2 = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head5, tail) => {
      const formattedHead = String(head5);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature2 extends OptionalType2 {
  name;
  isReadonly;
  constructor(name, type2, isOptional, isReadonly, annotations2) {
    super(type2, isOptional, annotations2);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isParameter2 = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter2(ast.from);
  }
  return false;
};

class IndexSignature2 {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type2, isReadonly) {
    this.type = type2;
    this.isReadonly = isReadonly;
    if (isParameter2(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage2);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral2 {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations2 = {}) {
    this.annotations = annotations2;
    const keys5 = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys5, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage2(name));
      }
      keys5[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const parameter = getParameterBase(indexSignatures[i].parameter);
      if (isStringKeyword2(parameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword2(parameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatTypeLiteral2(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var formatIndexSignatures2 = (iss) => iss.map(String).join("; ");
var formatTypeLiteral2 = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral2 = /* @__PURE__ */ createASTGuard2("TypeLiteral");
var sortCandidates2 = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap2 = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten17 = (candidates) => flatMap2(candidates, (ast) => isUnion4(ast) ? flatten17(ast.types) : [ast]);
var unify3 = (candidates) => {
  const cs = sortCandidates2(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword2];
      case "UnknownKeyword":
        return [unknownKeyword2];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type2 = typeof ast.literal;
        switch (type2) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap2[type2];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union2 {
  types;
  annotations;
  static make = (types, annotations2) => {
    return isMembers2(types) ? new Union2(types, annotations2) : types.length === 1 ? types[0] : neverKeyword2;
  };
  static unify = (candidates, annotations2) => {
    return Union2.make(unify3(flatten17(candidates)), annotations2);
  };
  _tag = "Union";
  constructor(types, annotations2 = {}) {
    this.types = types;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var mapMembers2 = (members, f) => members.map(f);
var isMembers2 = (as8) => as8.length > 1;
var isUnion4 = /* @__PURE__ */ createASTGuard2("Union");
var toJSONMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend2 {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations2 = {}) {
    this.f = f;
    this.annotations = annotations2;
    this.f = memoizeThunk2(f);
  }
  toString() {
    return getExpected2(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected2(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap2.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap2.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
    toJSONMemoMap2.set(ast, out);
    return out;
  }
}
class Refinement3 {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter11, annotations2 = {}) {
    this.from = from;
    this.filter = filter11;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => `{ ${this.from} | filter }`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isRefinement3 = /* @__PURE__ */ createASTGuard2("Refinement");
var defaultParseOption2 = {};

class Transformation3 {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations2 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isTransformation3 = /* @__PURE__ */ createASTGuard2("Transformation");

class FinalTransformation2 {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode6, encode4) {
    this.decode = decode6;
    this.encode = encode4;
  }
}
var createTransformationGuard = (tag4) => (ast) => ast._tag === tag4;
class PropertySignatureTransformation2 {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode6, encode4) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode4;
  }
}
class TypeLiteralTransformation2 {
  propertySignatureTransformations;
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(to));
      }
      toKeys[to] = true;
    }
  }
}
var isTypeLiteralTransformation2 = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations2 = (ast, annotations3) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  d.annotations.value = {
    ...ast.annotations,
    ...annotations3
  };
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN2 = ".*";
var NUMBER_KEYWORD_PATTERN2 = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralRegExp2 = (ast) => {
  let pattern2 = `^${escape(ast.head)}`;
  for (const span3 of ast.spans) {
    if (isStringKeyword2(span3.type)) {
      pattern2 += STRING_KEYWORD_PATTERN2;
    } else if (isNumberKeyword2(span3.type)) {
      pattern2 += NUMBER_KEYWORD_PATTERN2;
    }
    pattern2 += escape(span3.literal);
  }
  pattern2 += "$";
  return new RegExp(pattern2);
};
var record2 = (key, value6) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go2 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature2(key2, value6, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature2(key2.literal, value6, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteral(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature2(name, value6, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature2(key2.symbol, value6, false, true));
        break;
      case "Union":
        key2.types.forEach(go2);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchema(key2));
    }
  };
  go2(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var typeAST2 = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, typeAST2);
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type2 = typeAST2(e.type);
        return type2 === e.type ? e : new OptionalType2(type2, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, typeAST2);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((type2) => new Type3(type2)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (p3) => {
        const type2 = typeAST2(p3.type);
        return type2 === p3.type ? p3 : new PropertySignature2(p3.name, type2, p3.isOptional, p3.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is3) => {
        const type2 = typeAST2(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature2(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap2(ast.types, typeAST2);
      return types === ast.types ? ast : Union2.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend2(() => typeAST2(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST2(ast.from);
      return from === ast.from ? ast : new Refinement3(from, ast.filter, ast.annotations);
    }
    case "Transformation":
      return typeAST2(ast.to);
  }
  return ast;
};
var blackListAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id2 of annotationIds) {
    delete out[id2];
  }
  return out;
};
var getJSONIdentifier2 = (annotated) => orElse(getJSONIdentifierAnnotation2(annotated), () => getIdentifierAnnotation2(annotated));
var createJSONIdentifierAnnotation2 = (annotated) => match2(getJSONIdentifier2(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId2]: identifier2
  })
});
function changeMap2(as8, f) {
  let changed = false;
  const out = allocate(as8.length);
  for (let i = 0;i < as8.length; i++) {
    const a = as8[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as8;
}
var encodedAST_2 = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, (ast2) => encodedAST_2(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type2 = encodedAST_2(e.type, isBound);
        return type2 === e.type ? e : new OptionalType2(type2, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, (ast2) => encodedAST_2(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((ast2) => new Type3(ast2)), ast.isReadonly, createJSONIdentifierAnnotation2(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (ps) => {
        const type2 = encodedAST_2(ps.type, isBound);
        return type2 === ps.type ? ps : new PropertySignature2(ps.name, type2, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is3) => {
        const type2 = encodedAST_2(is3.type, isBound);
        return type2 === is3.type ? is3 : new IndexSignature2(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, createJSONIdentifierAnnotation2(ast));
    }
    case "Union": {
      const types = changeMap2(ast.types, (ast2) => encodedAST_2(ast2, isBound));
      return types === ast.types ? ast : Union2.make(types, createJSONIdentifierAnnotation2(ast));
    }
    case "Suspend":
      return new Suspend2(() => encodedAST_2(ast.f(), isBound), createJSONIdentifierAnnotation2(ast));
    case "Refinement": {
      const from = encodedAST_2(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (!isTransformation3(ast.from) && hasStableFilter2(ast)) {
          return new Refinement3(from, ast.filter);
        }
      }
      return from;
    }
    case "Transformation":
      return encodedAST_2(ast.from, isBound);
  }
  return ast;
};
var encodedAST2 = (ast) => encodedAST_2(ast, false);
var toJSONAnnotations2 = (annotations3) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations3)) {
    out[String(k)] = annotations3[k];
  }
  return out;
};
var getParameterBase = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
var formatKeyword2 = (ast) => getOrElse(getExpected2(ast), () => ast._tag);
var getExpected2 = (ast) => {
  return getIdentifierAnnotation2(ast).pipe(orElse(() => getTitleAnnotation2(ast)), orElse(() => getDescriptionAnnotation2(ast)));
};
// node_modules/@effect/schema/dist/esm/internal/filters.js
var GreaterThanOrEqualToTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualTo");
var IntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Int");

// node_modules/@effect/schema/dist/esm/Arbitrary.js
var ArbitraryHookId = /* @__PURE__ */ Symbol.for("@effect/schema/ArbitraryHookId");

// node_modules/@effect/schema/dist/esm/TreeFormatter.js
var make73 = (value6, forest = []) => ({
  value: value6,
  forest
});
var formatIssue = (issue) => map15(go2(issue), (tree) => drawTree2(tree));
var formatIssueSync = (issue) => runSync(formatIssue(issue));
var drawTree2 = (tree) => tree.value + draw2(`
`, tree.forest);
var draw2 = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw2(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind2 = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind2 = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated2 = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var getCurrentMessage2 = (issue) => getAnnotated2(issue).pipe(flatMap(getMessageAnnotation2), flatMap9((annotation) => {
  const out = annotation(issue);
  return isString(out) ? succeed8({
    message: out,
    override: false
  }) : isEffect2(out) ? map15(out, (message) => ({
    message,
    override: false
  })) : isString(out.message) ? succeed8({
    message: out.message,
    override: out.override
  }) : map15(out.message, (message) => ({
    message,
    override: out.override
  }));
}));
var createParseIssueGuard2 = (tag4) => (issue) => issue._tag === tag4;
var isComposite3 = /* @__PURE__ */ createParseIssueGuard2("Composite");
var isRefinement4 = /* @__PURE__ */ createParseIssueGuard2("Refinement");
var isTransformation4 = /* @__PURE__ */ createParseIssueGuard2("Transformation");
var getMessage2 = (issue) => getCurrentMessage2(issue).pipe(flatMap9((currentMessage) => {
  const useInnerMessage = !currentMessage.override && (isComposite3(issue) || isRefinement4(issue) && issue.kind === "From" || isTransformation4(issue) && issue.kind !== "Transformation");
  return useInnerMessage ? isTransformation4(issue) || isRefinement4(issue) ? getMessage2(issue.issue) : none2() : succeed8(currentMessage.message);
}));
var getParseIssueTitleAnnotation4 = (issue) => getAnnotated2(issue).pipe(flatMap(getParseIssueTitleAnnotation3), filterMap((annotation) => fromNullable(annotation(issue))));
var formatTypeMessage2 = (e) => getMessage2(e).pipe(orElse4(() => getParseIssueTitleAnnotation4(e)), catchAll2(() => succeed8(e.message ?? `Expected ${String(e.ast)}, actual ${formatUnknown2(e.actual)}`)));
var getParseIssueTitle2 = (issue) => getOrElse(getParseIssueTitleAnnotation4(issue), () => String(issue.ast));
var formatForbiddenMessage2 = (e) => e.message ?? "is forbidden";
var formatUnexpectedMessage2 = (e) => e.message ?? "is unexpected";
var formatMissingMessage2 = (e) => getMissingMessageAnnotation2(e.ast).pipe(flatMap9((annotation) => {
  const out = annotation();
  return isString(out) ? succeed8(out) : out;
}), catchAll2(() => succeed8(e.message ?? "is missing")));
var getTree = (issue, onFailure) => matchEffect2(getMessage2(issue), {
  onFailure,
  onSuccess: (message) => succeed8(make73(message))
});
var go2 = (e) => {
  switch (e._tag) {
    case "Type":
      return map15(formatTypeMessage2(e), make73);
    case "Forbidden":
      return succeed8(make73(getParseIssueTitle2(e), [make73(formatForbiddenMessage2(e))]));
    case "Unexpected":
      return succeed8(make73(formatUnexpectedMessage2(e)));
    case "Missing":
      return map15(formatMissingMessage2(e), make73);
    case "Transformation":
      return getTree(e, () => map15(go2(e.issue), (tree) => make73(getParseIssueTitle2(e), [make73(formatTransformationKind2(e.kind), [tree])])));
    case "Refinement":
      return getTree(e, () => map15(go2(e.issue), (tree) => make73(getParseIssueTitle2(e), [make73(formatRefinementKind2(e.kind), [tree])])));
    case "Pointer":
      return map15(go2(e.issue), (tree) => make73(formatPath2(e.path), [tree]));
    case "Composite": {
      const parseIssueTitle = getParseIssueTitle2(e);
      return getTree(e, () => isNonEmpty7(e.issues) ? map15(forEach8(e.issues, go2), (forest) => make73(parseIssueTitle, forest)) : map15(go2(e.issues), (tree) => make73(parseIssueTitle, [tree])));
    }
  }
};

// node_modules/@effect/schema/dist/esm/ParseResult.js
class Pointer2 {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path2, actual, issue) {
    this.path = path2;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected2 {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing2 {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite3 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}
class Refinement4 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation4 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type4 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden2 {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("@effect/schema/ParseErrorTypeId");
class ParseError2 extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId2] = ParseErrorTypeId2;
  get message() {
    return this.toString();
  }
  toString() {
    return formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError2 = (issue) => new ParseError2({
  issue
});
var succeed20 = right2;
var fail21 = left2;
var flatMap20 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return f(s.right);
  }
  return flatMap9(self, f);
});
var map33 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return right2(f(s.right));
  }
  return map15(self, f);
});
var mapError8 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return left2(f(s.left));
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return mapError2(self, f);
});
var eitherOrUndefined = (self) => {
  const s = self;
  if (s["_tag"] === "Left" || s["_tag"] === "Right") {
    return s;
  }
};
var mapBoth8 = /* @__PURE__ */ dual(2, (self, options3) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return left2(options3.onFailure(s.left));
  }
  if (s["_tag"] === "Right") {
    return right2(options3.onSuccess(s.right));
  }
  return mapBoth3(self, options3);
});
var orElse15 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return f(s.left);
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return catchAll2(self, f);
});
var mergeInternalOptions2 = (options3, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options3;
  }
  if (options3 === undefined) {
    return overrideOptions;
  }
  return {
    ...options3,
    ...overrideOptions
  };
};
var getEither2 = (ast, isDecoding, options3) => {
  const parser2 = goMemo2(ast, isDecoding);
  return (u, overrideOptions) => parser2(u, mergeInternalOptions2(options3, overrideOptions));
};
var getSync2 = (ast, isDecoding, options3) => {
  const parser2 = getEither2(ast, isDecoding, options3);
  return (input, overrideOptions) => getOrThrowWith(parser2(input, overrideOptions), parseError2);
};
var getEffect2 = (ast, isDecoding, options3) => {
  const parser2 = goMemo2(ast, isDecoding);
  return (input, overrideOptions) => parser2(input, {
    ...mergeInternalOptions2(options3, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync2 = (schema, options3) => getSync2(schema.ast, true, options3);
var decodeUnknown4 = (schema, options3) => getEffect2(schema.ast, true, options3);
var encodeUnknownSync2 = (schema, options3) => getSync2(schema.ast, false, options3);
var encodeUnknown2 = (schema, options3) => getEffect2(schema.ast, false, options3);
var decodeSync2 = decodeUnknownSync2;
var validateSync2 = (schema, options3) => getSync2(typeAST2(schema.ast), true, options3);
var is3 = (schema, options3) => {
  const parser2 = goMemo2(typeAST2(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser2(u, {
    exact: true,
    ...mergeInternalOptions2(options3, overrideOptions)
  }));
};
var encodeSync2 = encodeUnknownSync2;
var decodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/encodeMemoMap"), () => new WeakMap);
var goMemo2 = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap2 : encodeMemoMap2;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go3(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation2(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options3) => raw(i, mergeInternalOptions2(options3, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation2(ast);
  const parser2 = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options3) => handleForbidden2(orElse15(parserWithOptions(i, options3), decodingFallbackAnnotation.value), ast, i, options3) : parserWithOptions;
  memoMap.set(ast, parser2);
  return parser2;
};
var getConcurrency2 = (ast) => getOrUndefined(getConcurrencyAnnotation2(ast));
var getBatching2 = (ast) => getOrUndefined(getBatchingAnnotation2(ast));
var go3 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo2(ast.from, true);
        return (i, options3) => {
          options3 = options3 ?? defaultParseOption2;
          const allErrors = options3?.errors === "all";
          const result = flatMap20(orElse15(from(i, options3), (ef) => {
            const issue = new Refinement4(ast, i, "From", ef);
            if (allErrors && hasStableFilter2(ast)) {
              return match2(ast.filter(i, options3, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite3(ast, i, [issue, new Refinement4(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options3, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement4(ast, i, "Predicate", ep))
          }));
          return handleForbidden2(result, ast, i, options3);
        };
      } else {
        const from = goMemo2(typeAST2(ast), true);
        const to = goMemo2(dropRightRefinement2(ast.from), false);
        return (i, options3) => handleForbidden2(flatMap20(from(i, options3), (a) => to(a, options3)), ast, i, options3);
      }
    }
    case "Transformation": {
      const transform3 = getFinalTransformation2(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo2(ast.from, true) : goMemo2(ast.to, false);
      const to = isDecoding ? goMemo2(ast.to, true) : goMemo2(ast.from, false);
      return (i, options3) => handleForbidden2(flatMap20(mapError8(from(i, options3), (e) => new Transformation4(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap20(mapError8(transform3(a, options3 ?? defaultParseOption2, ast, i), (e) => new Transformation4(ast, i, "Transformation", e)), (i2) => mapError8(to(i2, options3), (e) => new Transformation4(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options3);
    }
    case "Declaration": {
      const parse8 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options3) => handleForbidden2(parse8(i, options3 ?? defaultParseOption2, ast), ast, i, options3);
    }
    case "Literal":
      return fromRefinement2(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement2(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement2(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement2(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement2(ast, isString);
    case "NumberKeyword":
      return fromRefinement2(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement2(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement2(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement2(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement2(ast, isObject);
    case "Enums":
      return fromRefinement2(ast, (u) => ast.enums.some(([_, value6]) => value6 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp2(ast);
      return fromRefinement2(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo2(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo2(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options3) => {
        if (!isArray(input)) {
          return left2(new Type4(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer2(i2, input, new Missing2(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite3(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer2(i2, input, new Unexpected2(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite3(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser2 = elements[i];
            const te = parser2(input[i], options3);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, sortByIndex2(output)));
                }
              }
              output.push([stepKey++, eu.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer2(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head5, ...tail] = rest;
          for (;i < len - tail.length; i++) {
            const te = head5(input[i], options3);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, sortByIndex2(output)));
                }
              } else {
                output.push([stepKey++, eu.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer2(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options3);
              const eu = eitherOrUndefined(te);
              if (eu) {
                if (isLeft2(eu)) {
                  const e = new Pointer2(i, input, eu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output)));
                  }
                }
                output.push([stepKey++, eu.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer2(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite3(ast, input, e, sortByIndex2(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite3(ast, input, sortByIndex2(es2), sortByIndex2(output2))) : right2(sortByIndex2(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement2(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo2(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo2(is4.parameter, isDecoding), goMemo2(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union2.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol2(key) : new Literal3(key))));
      const expected = goMemo2(expectedAST, isDecoding);
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options3) => {
        if (!isRecord(input)) {
          return left2(new Type4(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options3?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options3?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys2(input);
          for (const key of inputKeys) {
            const eu = eitherOrUndefined(expected(key, options3));
            if (isLeft2(eu)) {
              if (onExcessPropertyError) {
                const e = new Pointer2(key, input, new Unexpected2(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options3?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer2(name, input, new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite3(ast, input, e, output));
              }
            }
          }
          const parser2 = propertySignatures[i][0];
          const te = parser2(input[name], options3);
          const eu = eitherOrUndefined(te);
          if (eu) {
            if (isLeft2(eu)) {
              const e = new Pointer2(name, input, hasKey ? eu.left : new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite3(ast, input, e, output));
              }
            }
            output[name] = eu.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap9(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer2(index, input, hasKey ? t.left : new Missing2(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite3(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type2 = indexSignature[1];
          const keys5 = getKeysForIndexSignature2(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = eitherOrUndefined(parameter(key, options3));
            if (keu && isRight2(keu)) {
              const vpr = type2(input[key], options3);
              const veu = eitherOrUndefined(vpr);
              if (veu) {
                if (isLeft2(veu)) {
                  const e = new Pointer2(key, input, veu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite3(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = veu.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer2(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite3(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite3(ast, input, sortByIndex2(es2), output2));
          }
          if (options3?.propertyOrder === "original") {
            const keys5 = inputKeys || ownKeys2(input);
            for (const name of expectedKeys) {
              if (keys5.indexOf(name) === -1) {
                keys5.push(name);
              }
            }
            const out = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree2(ast.types, isDecoding);
      const ownKeys3 = ownKeys2(searchTree.keys);
      const len = ownKeys3.length;
      const map34 = new Map;
      for (let i = 0;i < ast.types.length; i++) {
        map34.set(ast.types[i], goMemo2(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency2(ast) ?? 1;
      const batching = getBatching2(ast);
      return (input, options3) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (len > 0) {
          if (isObject2(input)) {
            for (let i = 0;i < len; i++) {
              const name = ownKeys3[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const literals = Union2.make(searchTree.keys[name].literals);
                  es.push([stepKey++, new Composite3(new TypeLiteral2([new PropertySignature2(name, literals, false, true)], []), input, new Pointer2(name, input, new Type4(literals, input[name])))]);
                }
              } else {
                const literals = Union2.make(searchTree.keys[name].literals);
                const fakeps = new PropertySignature2(name, literals, false, true);
                es.push([stepKey++, new Composite3(new TypeLiteral2([fakeps], []), input, new Pointer2(name, input, new Missing2(fakeps)))]);
              }
            }
          } else {
            es.push([stepKey++, new Type4(ast, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map34.get(candidate)(input, options3);
          const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined;
          if (eu) {
            if (isRight2(eu)) {
              return eu;
            } else {
              es.push([stepKey++, eu.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap9(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite3(ast, input, sortByIndex2(es2))) : left2(new Type4(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get18 = memoizeThunk2(() => goMemo2(annotations2(ast.f(), ast.annotations), isDecoding));
      return (a, options3) => get18()(a, options3);
    }
  }
};
var isObject2 = (input) => typeof input === "object" && input !== null;
var fromRefinement2 = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type4(ast, u));
var getLiterals2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getLiterals2(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type2 = isDecoding ? encodedAST2(propertySignature.type) : typeAST2(propertySignature.type);
        if (isLiteral2(type2) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type2]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type2 = isDecoding ? encodedAST2(element.type) : typeAST2(element.type);
        if (isLiteral2(type2) && !element.isOptional) {
          out.push([i, type2]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals2(ast.from, isDecoding);
    case "Suspend":
      return getLiterals2(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals2(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree2 = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags2 = getLiterals2(member, isDecoding);
    if (tags2.length > 0) {
      for (let j = 0;j < tags2.length; j++) {
        const [key, literal2] = tags2[j];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags2.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise
  };
};
var dropRightRefinement2 = (ast) => isRefinement3(ast) ? dropRightRefinement2(ast.from) : ast;
var handleForbidden2 = (effect4, ast, actual, options3) => {
  const eu = eitherOrUndefined(effect4);
  if (eu) {
    return eu;
  }
  if (options3?.isEffectAllowed === true) {
    return effect4;
  }
  try {
    return runSync(either3(effect4));
  } catch (e) {
    return left2(new Forbidden2(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  }
};
var compare2 = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex2(es) {
  return es.sort(compare2).map((t) => t[1]);
}
var getFinalTransformation2 = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map33(out, f);
        }
        return out;
      };
  }
};

// node_modules/@effect/schema/dist/esm/Equivalence.js
var EquivalenceHookId = /* @__PURE__ */ Symbol.for("@effect/schema/EquivalenceHookId");

// node_modules/@effect/schema/dist/esm/Pretty.js
var PrettyHookId = /* @__PURE__ */ Symbol.for("@effect/schema/PrettyHookId");

// node_modules/@effect/schema/dist/esm/Schema.js
var TypeId29 = /* @__PURE__ */ Symbol.for("@effect/schema/Schema");
var make74 = (ast) => class SchemaClass {
  [TypeId29] = variance10;
  static Type;
  static Encoded;
  static Context;
  static [TypeId29] = variance10;
  static ast = ast;
  static annotations(annotations3) {
    return make74(mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static pipe() {
    return pipeArguments(this, arguments);
  }
  static toString() {
    return String(ast);
  }
};
var variance10 = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var toASTAnnotations2 = (annotations3) => {
  if (!annotations3) {
    return {};
  }
  const out = {};
  const custom3 = Object.getOwnPropertySymbols(annotations3);
  for (const sym of custom3) {
    out[sym] = annotations3[sym];
  }
  if (annotations3.typeId !== undefined) {
    const typeId = annotations3.typeId;
    if (typeof typeId === "object") {
      out[TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations3[from] !== undefined) {
      out[to] = annotations3[from];
    }
  };
  move("message", MessageAnnotationId2);
  move("missingMessage", MissingMessageAnnotationId2);
  move("identifier", IdentifierAnnotationId2);
  move("title", TitleAnnotationId2);
  move("description", DescriptionAnnotationId2);
  move("examples", ExamplesAnnotationId2);
  move("default", DefaultAnnotationId2);
  move("documentation", DocumentationAnnotationId2);
  move("jsonSchema", JSONSchemaAnnotationId2);
  move("arbitrary", ArbitraryHookId);
  move("pretty", PrettyHookId);
  move("equivalence", EquivalenceHookId);
  move("concurrency", ConcurrencyAnnotationId2);
  move("batching", BatchingAnnotationId2);
  move("parseIssueTitle", ParseIssueTitleAnnotationId2);
  move("parseOptions", ParseOptionsAnnotationId2);
  move("decodingFallback", DecodingFallbackAnnotationId2);
  return out;
};
var mergeSchemaAnnotations2 = (ast, annotations3) => annotations2(ast, toASTAnnotations2(annotations3));
var asSchema = (schema) => schema;
var format7 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make74(encodedAST2(schema.ast));
var typeSchema = (schema) => make74(typeAST2(schema.ast));
var isSchema2 = (u) => hasProperty(u, TypeId29) && isObject(u[TypeId29]);
var getDefaultLiteralAST2 = (literals) => isMembers2(literals) ? Union2.make(mapMembers2(literals, (literal2) => new Literal3(literal2))) : new Literal3(literals[0]);
var makeLiteralClass2 = (literals, ast = getDefaultLiteralAST2(literals)) => class LiteralClass extends make74(ast) {
  static annotations(annotations3) {
    return makeLiteralClass2(this.literals, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static literals = [...literals];
};
function Literal4(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass2(literals) : Never2;
}
var declareConstructor2 = (typeParameters, options3, annotations3) => make74(new Declaration2(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options3.decode(...typeParameters2.map(make74)), (...typeParameters2) => options3.encode(...typeParameters2.map(make74)), toASTAnnotations2(annotations3)));
var declarePrimitive2 = (is4, annotations3) => {
  const decodeUnknown5 = () => (input, _, ast) => is4(input) ? succeed20(input) : fail21(new Type4(ast, input));
  const encodeUnknown3 = decodeUnknown5;
  return make74(new Declaration2([], decodeUnknown5, encodeUnknown3, toASTAnnotations2(annotations3)));
};
var declare2 = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options3 = arguments[1];
    const annotations4 = arguments[2];
    return declareConstructor2(typeParameters, options3, annotations4);
  }
  const is4 = arguments[0];
  const annotations3 = arguments[1];
  return declarePrimitive2(is4, annotations3);
};
class Never2 extends (/* @__PURE__ */ make74(neverKeyword2)) {
}

class Unknown extends (/* @__PURE__ */ make74(unknownKeyword2)) {
}
class String$2 extends (/* @__PURE__ */ make74(stringKeyword2)) {
}

class Number$2 extends (/* @__PURE__ */ make74(numberKeyword2)) {
}
var getDefaultUnionAST = (members) => Union2.make(members.map((m) => m.ast));
var makeUnionClass = (members, ast = getDefaultUnionAST(members)) => class UnionClass extends make74(ast) {
  static annotations(annotations3) {
    return makeUnionClass(this.members, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static members = [...members];
};
function Union3(...members) {
  return isMembers2(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never2;
}
var getDefaultTupleTypeAST = (elements, rest) => new TupleType2(elements.map((el) => isSchema2(el) ? new OptionalType2(el.ast, false) : el.ast), rest.map((el) => isSchema2(el) ? new Type3(el.ast) : el.ast), true);
var makeTupleTypeClass = (elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) => class TupleTypeClass extends make74(ast) {
  static annotations(annotations3) {
    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static elements = [...elements];
  static rest = [...rest];
};
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

class PropertySignatureDeclaration extends OptionalType2 {
  isReadonly;
  defaultValue;
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
}

class FromPropertySignature extends OptionalType2 {
  isReadonly;
  fromKey;
  constructor(type2, isOptional, isReadonly, annotations3, fromKey) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey;
  }
}

class ToPropertySignature extends OptionalType2 {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
var formatPropertyKey3 = (p3) => {
  if (p3 === undefined) {
    return "never";
  }
  if (isString(p3)) {
    return JSON.stringify(p3);
  }
  return String(p3);
};

class PropertySignatureTransformation3 {
  from;
  to;
  decode;
  encode;
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode6, encode4) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode4;
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey3(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
var mergeSignatureAnnotations = (ast, annotations3) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations3
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation3(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations3
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);

class PropertySignatureImpl {
  ast;
  [TypeId29];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations3) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations2(annotations3)));
  }
  toString() {
    return String(this.ast);
  }
}
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations3) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations2(annotations3)), this.from);
  }
}
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, undefined), self);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation3(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys3 = ownKeys2(fields);
  const pss = [];
  if (ownKeys3.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0;i < ownKeys3.length; i++) {
      const key = ownKeys3[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature2(key, type2, isOptional, true));
            to.push(new PropertySignature2(key, typeAST2(type2), isOptional, true, toAnnotations));
            pss.push(new PropertySignature2(key, type2, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key;
            from.push(new PropertySignature2(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature2(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation2(fromKey, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature2(key, field.ast, false, true));
        to.push(new PropertySignature2(key, typeAST2(field.ast), false, true));
        pss.push(new PropertySignature2(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature2(ps.name, typeAST2(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature2(is4.parameter, typeAST2(is4.type), is4.isReadonly));
        });
      }
      return new Transformation3(new TypeLiteral2(from, issFrom, {
        [TitleAnnotationId2]: "Struct (Encoded side)"
      }), new TypeLiteral2(to, issTo, {
        [TitleAnnotationId2]: "Struct (Type side)"
      }), new TypeLiteralTransformation2(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral2(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys3 = ownKeys2(fields);
  for (const key of ownKeys3) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
var makeTypeLiteralClass = (fields, records, ast = getDefaultTypeLiteralAST(fields, records)) => {
  return class TypeLiteralClass extends make74(ast) {
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations2(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options3) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption2(options3) ? propsWithDefaults : validateSync2(this)(propsWithDefaults);
    };
    static pick(...keys5) {
      return Struct(pick2(fields, ...keys5));
    }
    static omit(...keys5) {
      return Struct(omit2(fields, ...keys5));
    }
  };
};
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var intersectTypeLiterals = (x, y, path2) => {
  if (isTypeLiteral2(x) && isTypeLiteral2(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type2
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature2(name, extendAST(type2, ps.type, path2.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral2(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path2));
};
var preserveRefinementAnnotations = /* @__PURE__ */ blackListAnnotations([IdentifierAnnotationId2]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement3(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path2) => Union2.make(intersectUnionMembers([x], [y], path2));
var getTypes = (ast) => isUnion4(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path2) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword2(x) || isNumber(y.literal) && isNumberKeyword2(x) || isBoolean(y.literal) && isBooleanKeyword2(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword2) {
        if (isStringKeyword2(x) || isLiteral2(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === stringKeyword2) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword2) {
        if (isNumberKeyword2(x) || isLiteral2(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === numberKeyword2) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword2) {
        if (isBooleanKeyword2(x) || isLiteral2(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === booleanKeyword2) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path2);
    case "Suspend":
      return [new Suspend2(() => extendAST(x, y.f(), path2))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path2));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path2);
        case "Suspend":
          return [new Suspend2(() => extendAST(x.f(), y, path2))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path2)];
        case "Transformation": {
          if (isTypeLiteralTransformation2(x.transformation)) {
            return [new Transformation3(intersectTypeLiterals(x.from, y, path2), intersectTypeLiterals(x.to, typeAST2(y), path2), new TypeLiteralTransformation2(x.transformation.propertySignatureTransformations))];
          }
          break;
        }
      }
      break;
    }
    case "Transformation": {
      if (isTypeLiteralTransformation2(y.transformation)) {
        switch (x._tag) {
          case "Union":
            return intersectUnionMembers(x.types, [y], path2);
          case "Suspend":
            return [new Suspend2(() => extendAST(x.f(), y, path2))];
          case "Refinement":
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
          case "TypeLiteral":
            return [new Transformation3(intersectTypeLiterals(x, y.from, path2), intersectTypeLiterals(typeAST2(x), y.to, path2), new TypeLiteralTransformation2(y.transformation.propertySignatureTransformations))];
          case "Transformation":
            {
              if (isTypeLiteralTransformation2(x.transformation)) {
                return [new Transformation3(intersectTypeLiterals(x.from, y.from, path2), intersectTypeLiterals(x.to, y.to, path2), new TypeLiteralTransformation2(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
              }
            }
            break;
        }
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path2));
}));
var extend3 = /* @__PURE__ */ dual(2, (self, that) => make74(extendAST(self.ast, that.ast, [])));
var suspend11 = (f) => make74(new Suspend2(() => f().ast));
var refineTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/refine");
var makeRefineClass2 = (from, filter11, ast) => class RefineClass extends make74(ast) {
  static annotations(annotations3) {
    return makeRefineClass2(this.from, this.filter, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static [refineTypeId] = from;
  static from = from;
  static filter = filter11;
  static make = (a, options3) => {
    return getDisableValidationMakeOption2(options3) ? a : validateSync2(this)(a);
  };
};
var fromFilterPredicateReturnTypeItem2 = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type4(ast, input));
  }
  if (isString(item)) {
    return some2(new Type4(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type4(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer2(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue2 = (out, ast, input) => {
  if (isSingle3(out)) {
    return fromFilterPredicateReturnTypeItem2(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem2(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite3(ast, input, issues));
    }
  }
  return none2();
};
function filter11(predicate, annotations3) {
  return (self) => {
    function filter12(input, options3, ast2) {
      return toFilterParseIssue2(predicate(input, options3, ast2), ast2, input);
    }
    const ast = new Refinement3(self.ast, filter12, toASTAnnotations2(annotations3));
    return makeRefineClass2(self, filter12, ast);
  };
}
var makeTransformationClass2 = (from, to, ast) => class TransformationClass extends make74(ast) {
  static annotations(annotations3) {
    return makeTransformationClass2(this.from, this.to, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static from = from;
  static to = to;
};
var transformOrFail2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]) && isSchema2(args2[1]), (from, to, options3) => makeTransformationClass2(from, to, new Transformation3(from.ast, to.ast, new FinalTransformation2(options3.decode, options3.encode))));
var transform3 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]) && isSchema2(args2[1]), (from, to, options3) => transformOrFail2(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed20(options3.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed20(options3.encode(toI, toA))
}));
var JsonString = /* @__PURE__ */ String$2.annotations({
  [IdentifierAnnotationId2]: "JsonString",
  [TitleAnnotationId2]: "JsonString",
  [DescriptionAnnotationId2]: "a JSON string"
});
var FiniteTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Finite");
var finite = (annotations3) => (self) => self.pipe(filter11((a) => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations3
}));
var GreaterThanOrEqualToTypeId2 = GreaterThanOrEqualToTypeId;
var greaterThanOrEqualTo6 = (min5, annotations3) => (self) => self.pipe(filter11((a) => a >= min5, {
  typeId: GreaterThanOrEqualToTypeId2,
  description: min5 === 0 ? "a non-negative number" : `a number greater than or equal to ${min5}`,
  jsonSchema: {
    minimum: min5
  },
  ...annotations3
}));
var IntTypeId2 = IntTypeId;
var int2 = (annotations3) => (self) => self.pipe(filter11((a) => Number.isSafeInteger(a), {
  typeId: IntTypeId2,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
}));
var nonNegative = (annotations3) => greaterThanOrEqualTo6(0, annotations3);
class Int2 extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ int2({
  identifier: "Int",
  title: "Int"
}))) {
}
class NonNegative extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
}))) {
}
var toComposite = (eff, onSuccess, ast, actual) => mapBoth8(eff, {
  onFailure: (e) => new Composite3(ast, actual, e),
  onSuccess
});
var hrTime = /* @__PURE__ */ Tuple(/* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
  [TitleAnnotationId2]: "seconds",
  [DescriptionAnnotationId2]: "seconds"
})), /* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
  [TitleAnnotationId2]: "nanos",
  [DescriptionAnnotationId2]: "nanos"
})));
var isField = (u) => isSchema2(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys2(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[refineTypeId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema2(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var getClassTag = (tag4) => withConstructorDefault(propertySignature(Literal4(tag4)), () => tag4);
var TaggedError2 = (identifier2) => (tag4, fieldsOr, annotations3) => {
  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag4;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag4)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag4,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations3,
    disableToString: true
  }) {
    static _tag = tag4;
    get message() {
      return `{ ${ownKeys2(fields).map((p3) => `${formatPropertyKey2(p3)}: ${formatUnknown2(this[p3])}`).join(", ")} }`;
    }
  };
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys2(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage2(key));
    }
    out[key] = b[key];
  }
  return out;
};
var orElseTitleAnnotation = (schema, title) => {
  const annotation = getTitleAnnotation2(schema.ast);
  if (isNone2(annotation)) {
    return schema.annotations({
      title
    });
  }
  return schema;
};
var getDisableValidationMakeOption2 = (options3) => isBoolean(options3) ? options3 : options3?.disableValidation ?? false;
var makeClass = ({
  Base: Base3,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier2}`);
  const validateSchema = orElseTitleAnnotation(schema, `${identifier2} (Constructor)`);
  const encodedSide = orElseTitleAnnotation(schema, `${identifier2} (Encoded side)`);
  const typeSide = orElseTitleAnnotation(typeSchema(schema), `${identifier2} (Type side)`);
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is3(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options3 = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption2(options3)) {
        props = validateSync2(validateSchema)(props);
      }
      super(props, true);
    }
    static [TypeId29] = variance10;
    static get ast() {
      const declaration = declare2([typeSide], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed20(input) : fail21(new Type4(ast, input)),
        encode: () => (input, options3) => input instanceof this ? succeed20(input) : map33(encodeUnknown2(typeSide)(input, options3), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        title: identifier2,
        description: `an instance of ${identifier2}`,
        pretty: (pretty6) => (self) => `${identifier2}(${pretty6(self)})`,
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId2]: typeSide.ast,
        ...annotations3
      });
      const transformation = transform3(encodedSide, declaration, {
        strict: true,
        decode: (input) => new this(input, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId2]: schema.ast
      });
      return transformation.ast;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make74(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFields, options3, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail2(schema, typeSchema(Struct(transformedFields)), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options3, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail2(encodedSchema(schema), Struct(transformedFields), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys2(fields).map((p3) => `${formatPropertyKey2(p3)}: ${formatUnknown2(this[p3])}`).join(", ")} })`;
      },
      configurable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("Runtime"),
  id: Int2.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int2.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("Composite"),
  left: suspend11(() => FiberIdEncoded),
  right: suspend11(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union3(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId2) => {
  switch (fiberId2._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId2.id}, ${fiberId2.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId2.right)}, ${fiberIdPretty(fiberId2.left)})`;
  }
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal4("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal4("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal4("Fail"),
  error: error4
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal4("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeParallelEncoded = (causeEncoded) => Struct({
  _tag: Literal4("Parallel"),
  left: causeEncoded,
  right: causeEncoded
});
var causeSequentialEncoded = (causeEncoded) => Struct({
  _tag: Literal4("Sequential"),
  left: causeEncoded,
  right: causeEncoded
});
var causeEncoded = (error4, defect) => {
  const recur = suspend11(() => out);
  const out = Union3(CauseEmptyEncoded, causeFailEncoded(error4), causeDieEncoded(defect), CauseInterruptEncoded, causeSequentialEncoded(recur), causeParallelEncoded(recur)).annotations({
    title: `CauseEncoded<${format7(error4)}>`
  });
  return out;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause2) => {
  const f = (cause3) => {
    switch (cause3._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause3.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause3)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause3.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause3.left)}, ${f(cause3.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause3.left)}, ${f(cause3.right)})`;
    }
  };
  return f(cause2);
};
var causeParse = (decodeUnknown5) => (u, options3, ast) => isCause2(u) ? toComposite(decodeUnknown5(causeEncode(u), options3), causeDecode, ast, u) : fail21(new Type4(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare2([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown4(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown2(causeEncoded(error5, defect2)))
  }, {
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return empty29;
    case "Fail":
      return fail5(cause2.error);
    case "Die":
      return die4(cause2.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause2.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause2.left), causeDecode(cause2.right));
    case "Parallel":
      return parallel4(causeDecode(cause2.left), causeDecode(cause2.right));
  }
}
function causeEncode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause2.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause2.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause2.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  return transform3(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: Unknown
  }), {
    strict: false,
    decode: causeDecode,
    encode: causeEncode
  });
};
var Defect = /* @__PURE__ */ transform3(Unknown, Unknown, {
  strict: true,
  decode: (u) => {
    if (isObject(u) && "message" in u && typeof u.message === "string") {
      const err = new Error(u.message, {
        cause: u
      });
      if ("name" in u && typeof u.name === "string") {
        err.name = u.name;
      }
      err.stack = "stack" in u && typeof u.stack === "string" ? u.stack : "";
      return err;
    }
    return String(u);
  },
  encode: (defect) => {
    if (defect instanceof Error) {
      return {
        name: defect.name,
        message: defect.message
      };
    }
    return String(defect);
  }
}).annotations({
  identifier: "Defect"
});

// node_modules/effect/dist/esm/FiberSet.js
var TypeId30 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId30);
var Proto4 = {
  [TypeId30]: TypeId30,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake11 = (backing, deferred) => {
  const self = Object.create(Proto4);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make75 = () => acquireRelease2(map15(make24(), (deferred) => unsafeMake11(new Set, deferred)), (set8) => withFiberRuntime2((parent) => {
  const state = set8.state;
  if (state._tag === "Closed")
    return _void;
  set8.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set8.deferred));
}));
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make15(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(undefined, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId2) => has3(ids2(fiberId2), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self, fiber, options3) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options3?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure(exit3) && (options3?.propagateInterruption === true ? !isInternalInterruption(exit3.cause) : !isInterruptedOnly2(exit3.cause))) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
}();
var runtime5 = (self) => () => map15(runtime4(), (runtime6) => {
  const runFork4 = runFork3(runtime6);
  return (effect4, options3) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options3);
    unsafeAdd(self, fiber);
    return fiber;
  };
});
var join5 = (self) => _await(self.deferred);

// node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
var poolVariance = {
  _E: (_) => _,
  _A: (_) => _
};
class PoolImpl extends Class {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set;
  available = /* @__PURE__ */ new Set;
  availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set;
  waiters = 0;
  constructor(scope4, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope4;
    this.acquire = acquire;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope4) => this.acquire.pipe(scopeExtend(scope4), exit, flatMap7((exit3) => {
    const item = {
      exit: exit3,
      finalizer: catchAllCause(scope4.close(exit3), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as(exit3._tag === "Success" ? this.strategy.onAcquire(item) : zipRight(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope4, exit3) => exit3._tag === "Failure" ? scope4.close(exit3) : void_);
  get currentUsage() {
    let count4 = this.waiters;
    for (const item of this.items) {
      count4 += item.refCount;
    }
    return count4;
  }
  get targetSize() {
    if (this.isShuttingDown)
      return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = /* @__PURE__ */ suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap7(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect(toAcquire, {
      concurrency: toAcquire
    }), zipLeft(this.availableLatch.open), flatMap7((items) => items.some((_) => _.exit._tag === "Failure") ? void_ : this.resizeLoop));
  });
  resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight(scopeTag), flatMap7((scope4) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self = this;
      return flatMap7(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), function loop() {
        if (self.isShuttingDown) {
          return interrupt2;
        } else if (self.available.size > 0) {
          return succeed(unsafeHead(self.available));
        }
        self.availableLatch.unsafeClose();
        return flatMap7(self.availableLatch.await, loop);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring(sync(() => this.waiters--)), tap((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope4.addFinalizer(() => zipRight(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = /* @__PURE__ */ flatMap7(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      this.isShuttingDown = true;
      const size17 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size17);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight(this.semaphore.releaseAll), zipRight(this.availableLatch.open), zipRight(semaphore.take(size17)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var reportUnhandledError = (cause2) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause2, unhandledLogLevel);
  }
  return void_;
});

// node_modules/@effect/platform/dist/esm/Transferable.js
class Collector extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
}
var unsafeMakeCollector = () => {
  const tranferables = [];
  const unsafeAddAll = (transfers) => {
    for (const transfer of transfers) {
      tranferables.push(transfer);
    }
  };
  const unsafeRead = () => tranferables;
  const unsafeClear = () => {
    tranferables.length = 0;
  };
  return Collector.of({
    unsafeAddAll,
    addAll: (transferables) => sync3(() => unsafeAddAll(transferables)),
    unsafeRead,
    read: sync3(unsafeRead),
    unsafeClear,
    clear: sync3(unsafeClear)
  });
};

// node_modules/@effect/platform/dist/esm/internal/workerError.js
var WorkerErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");

// node_modules/@effect/platform/dist/esm/WorkerError.js
var WorkerErrorTypeId2 = WorkerErrorTypeId;
class WorkerError extends (/* @__PURE__ */ TaggedError2()("WorkerError", {
  reason: /* @__PURE__ */ Literal4("spawn", "decode", "send", "unknown", "encode"),
  cause: Defect
})) {
  [WorkerErrorTypeId2] = WorkerErrorTypeId2;
  static Cause = /* @__PURE__ */ Cause({
    error: this,
    defect: Defect
  });
  static encodeCause = /* @__PURE__ */ encodeSync2(this.Cause);
  static decodeCause = /* @__PURE__ */ decodeSync2(this.Cause);
  get message() {
    switch (this.reason) {
      case "send":
        return "An error occurred calling .postMessage";
      case "spawn":
        return "An error occurred while spawning a worker";
      case "decode":
        return "An error occurred during decoding";
      case "encode":
        return "An error occurred during encoding";
      case "unknown":
        return "An unexpected error occurred";
    }
  }
}

// node_modules/@effect/platform/dist/esm/internal/worker.js
var PlatformWorkerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/PlatformWorker");
var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");
var WorkerManagerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/WorkerManager");
var WorkerManager = /* @__PURE__ */ GenericTag("@effect/platform/Worker/WorkerManager");
var Spawner = /* @__PURE__ */ GenericTag("@effect/platform/Worker/Spawner");
var makeManager = /* @__PURE__ */ gen2(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode: encode5,
      initialMessage
    }) {
      return gen2(function* (_) {
        const id2 = idCounter++;
        let requestIdCounter = 0;
        const requestMap = new Map;
        const collector = unsafeMakeCollector();
        const wrappedEncode = encode5 ? (message) => zipRight3(collector.clear, provideService2(encode5(message), Collector, collector)) : succeed8;
        const readyLatch = yield* make24();
        const backing = yield* platform.spawn(id2);
        yield* backing.run((message) => {
          if (message[0] === 0) {
            return complete(readyLatch, _void);
          }
          return handleMessage(message[1]);
        }).pipe(onError2((cause2) => forEach8(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? failCause2(mailbox, cause2) : mailbox.failCause(cause2))), retry(spaced2(1000)), annotateLogs2({
          package: "@effect/platform",
          module: "Worker"
        }), interruptible4, forkScoped2);
        yield* addFinalizer3(() => zipRight3(forEach8(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? interrupt3(mailbox) : mailbox.end, {
          discard: true
        }), sync3(() => requestMap.clear())));
        const handleMessage = (response) => suspend3(() => {
          const mailbox = requestMap.get(response[0]);
          if (!mailbox)
            return _void;
          switch (response[1]) {
            case 0: {
              return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : mailbox.offerAll(response[2]);
            }
            case 1: {
              if (response.length === 2) {
                return DeferredTypeId2 in mailbox ? interrupt3(mailbox) : mailbox.end;
              }
              return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : zipRight3(mailbox.offerAll(response[2]), mailbox.end);
            }
            case 2:
            case 3: {
              if (response[1] === 2) {
                return DeferredTypeId2 in mailbox ? fail3(mailbox, response[2]) : mailbox.fail(response[2]);
              }
              const cause2 = WorkerError.decodeCause(response[2]);
              return DeferredTypeId2 in mailbox ? failCause2(mailbox, cause2) : mailbox.failCause(cause2);
            }
          }
        });
        const executeAcquire = (request, makeMailbox) => withFiberRuntime2((fiber) => {
          const context8 = fiber.getFiberRef(currentContext2);
          const span3 = getOption2(context8, ParentSpan).pipe(filter((span4) => span4._tag === "Span"));
          const id3 = requestIdCounter++;
          return makeMailbox.pipe(tap2((mailbox) => {
            requestMap.set(id3, mailbox);
            return wrappedEncode(request).pipe(tap2((payload) => backing.send([id3, 0, payload, span3._tag === "Some" ? [span3.value.traceId, span3.value.spanId, span3.value.sampled] : undefined], collector.unsafeRead())), catchAllCause2((cause2) => isMailbox(mailbox) ? mailbox.failCause(cause2) : failCause2(mailbox, cause2)));
          }), map15((mailbox) => ({
            id: id3,
            mailbox
          })));
        });
        const executeRelease = ({
          id: id3
        }, exit3) => {
          const release = sync3(() => requestMap.delete(id3));
          return isFailure(exit3) ? zipRight3(orDie2(backing.send([id3, 1])), release) : release;
        };
        const execute2 = (request) => fromChannel4(acquireUseRelease4(executeAcquire(request, make71()), ({
          mailbox
        }) => toChannel4(mailbox), executeRelease));
        const executeEffect = (request) => acquireUseRelease2(executeAcquire(request, make24()), ({
          mailbox
        }) => _await(mailbox), executeRelease);
        yield* _await(readyLatch);
        if (initialMessage) {
          yield* sync3(initialMessage).pipe(flatMap9(executeEffect), mapError2((cause2) => new WorkerError({
            reason: "spawn",
            cause: cause2
          })));
        }
        return {
          id: id2,
          execute: execute2,
          executeEffect
        };
      });
    }
  });
});
var layerManager = /* @__PURE__ */ effect(WorkerManager, makeManager);
var makePlatform = () => (options3) => PlatformWorker.of({
  [PlatformWorkerTypeId]: PlatformWorkerTypeId,
  spawn(id2) {
    return gen2(function* (_) {
      const spawn2 = yield* Spawner;
      let currentPort;
      const buffer3 = [];
      const run9 = (handler) => uninterruptibleMask3((restore) => make39().pipe(bindTo3("scope"), bind3("port", ({
        scope: scope4
      }) => options3.setup({
        worker: spawn2(id2),
        scope: scope4
      })), tap2(({
        port: port2,
        scope: scope4
      }) => {
        currentPort = port2;
        return addFinalizer2(scope4, sync3(() => {
          currentPort = undefined;
        }));
      }), bind3("fiberSet", ({
        scope: scope4
      }) => make75().pipe(extend2(scope4))), bind3("runFork", ({
        fiberSet
      }) => runtime5(fiberSet)()), tap2(({
        fiberSet,
        port: port2,
        runFork: runFork4,
        scope: scope4
      }) => options3.listen({
        port: port2,
        scope: scope4,
        emit(data) {
          runFork4(handler(data));
        },
        deferred: fiberSet.deferred
      })), tap2(({
        port: port2
      }) => {
        if (buffer3.length > 0) {
          for (const [message, transfers] of buffer3) {
            port2.postMessage([0, message], transfers);
          }
          buffer3.length = 0;
        }
      }), flatMap9(({
        fiberSet,
        scope: scope4
      }) => restore(join5(fiberSet)).pipe(ensuring2(close(scope4, void_3))))));
      const send = (message, transfers) => try_2({
        try: () => {
          if (currentPort === undefined) {
            buffer3.push([message, transfers]);
          } else {
            currentPort.postMessage([0, message], transfers);
          }
        },
        catch: (cause2) => new WorkerError({
          reason: "send",
          cause: cause2
        })
      });
      return {
        run: run9,
        send
      };
    });
  }
});

// node_modules/@effect/platform/dist/esm/Worker.js
var makePlatform2 = makePlatform;
var PlatformWorker2 = PlatformWorker;
var layerManager2 = layerManager;

// node_modules/@effect/platform-node/dist/esm/internal/worker.js
var platformWorkerImpl = /* @__PURE__ */ makePlatform2()({
  setup({
    scope: scope4,
    worker
  }) {
    return flatMap9(make24(), (exitDeferred) => {
      worker.on("exit", () => {
        unsafeDone(exitDeferred, void_3);
      });
      return as3(addFinalizer2(scope4, suspend3(() => {
        worker.postMessage([1]);
        return _await(exitDeferred);
      }).pipe(timeout2(5000), catchAllCause2(() => sync3(() => worker.terminate())))), worker);
    });
  },
  listen({
    deferred,
    emit: emit2,
    port: port2
  }) {
    port2.on("message", (message) => {
      emit2(message);
    });
    port2.on("messageerror", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "decode",
        cause: cause2
      }));
    });
    port2.on("error", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: cause2
      }));
    });
    port2.on("exit", (code2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: new Error(`exited with code ${code2}`)
      }));
    });
    return _void;
  }
});
var layerWorker = /* @__PURE__ */ succeed11(PlatformWorker2, platformWorkerImpl);
var layerManager3 = /* @__PURE__ */ provide3(layerManager2, layerWorker);

// node_modules/@effect/platform-node/dist/esm/NodeWorker.js
var layerManager4 = layerManager3;

// node_modules/@effect/platform-node/dist/esm/NodeContext.js
var layer11 = /* @__PURE__ */ pipe(/* @__PURE__ */ mergeAll4(layer7, layer3, layer9, layerManager4), /* @__PURE__ */ provideMerge2(layer5));

// node_modules/@effect/platform/dist/esm/Runtime.js
var defaultTeardown = (exit3, onExit3) => {
  onExit3(isFailure(exit3) && !isInterruptedOnly2(exit3.cause) ? 1 : 0);
};
var addPrettyLogger = (refs, fiberId2) => {
  const loggers = getOrDefault2(refs, currentLoggers2);
  if (!has3(loggers, defaultLogger2)) {
    return refs;
  }
  return updateAs2(refs, {
    fiberId: fiberId2,
    fiberRef: currentLoggers2,
    value: loggers.pipe(remove4(defaultLogger2), add4(prettyLoggerDefault2))
  });
};
var makeRunMain = (f) => dual((args2) => isEffect2(args2[0]), (effect4, options3) => {
  const fiber = options3?.disableErrorReporting === true ? runFork2(effect4, {
    updateRefs: options3?.disablePrettyLogger === true ? undefined : addPrettyLogger
  }) : runFork2(tapErrorCause2(effect4, (cause2) => {
    if (isInterruptedOnly2(cause2)) {
      return _void;
    }
    return logError2(cause2);
  }), {
    updateRefs: options3?.disablePrettyLogger === true ? undefined : addPrettyLogger
  });
  const teardown = options3?.teardown ?? defaultTeardown;
  return f({
    fiber,
    teardown
  });
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
var runMain = /* @__PURE__ */ makeRunMain(({
  fiber,
  teardown
}) => {
  const keepAlive = setInterval(constVoid, 2 ** 31 - 1);
  let receivedSignal = false;
  fiber.addObserver((exit3) => {
    if (!receivedSignal) {
      process.removeListener("SIGINT", onSigint);
      process.removeListener("SIGTERM", onSigint);
    }
    clearInterval(keepAlive);
    teardown(exit3, (code2) => {
      if (receivedSignal || code2 !== 0) {
        process.exit(code2);
      }
    });
  });
  function onSigint() {
    receivedSignal = true;
    process.removeListener("SIGINT", onSigint);
    process.removeListener("SIGTERM", onSigint);
    fiber.unsafeInterruptAsFork(fiber.id());
  }
  process.on("SIGINT", onSigint);
  process.on("SIGTERM", onSigint);
});

// node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
var runMain2 = runMain;

// node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
var runMain3 = runMain2;

// src/index.ts
var import_config4 = __toESM(require_config(), 1);

// node_modules/@effect/cli/dist/esm/Args.js
var text10 = text9;
var withDescription8 = withDescription4;

// node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol4 = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  constructor({
    name: name14,
    message,
    cause: cause2
  }) {
    super(message);
    this[_a] = true;
    this.name = name14;
    this.cause = cause2;
  }
  static isInstance(error4) {
    return _AISDKError2.hasMarker(error4, marker);
  }
  static hasMarker(error4, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error4 != null && typeof error4 === "object" && markerSymbol in error4 && typeof error4[markerSymbol] === "boolean" && error4[markerSymbol] === true;
  }
};
_a = symbol4;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol22 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
  constructor({
    message,
    url: url2,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause: cause2,
    isRetryable = statusCode != null && (statusCode === 408 || statusCode === 409 || statusCode === 429 || statusCode >= 500),
    data
  }) {
    super({ name, message, cause: cause2 });
    this[_a2] = true;
    this.url = url2;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker2);
  }
};
_a2 = symbol22;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol32 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker3);
  }
};
_a3 = symbol32;
function getErrorMessage3(error4) {
  if (error4 == null) {
    return "unknown error";
  }
  if (typeof error4 === "string") {
    return error4;
  }
  if (error4 instanceof Error) {
    return error4.message;
  }
  return JSON.stringify(error4);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol42 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause: cause2,
    argument
  }) {
    super({ name: name3, message, cause: cause2 });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker4);
  }
};
_a4 = symbol42;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text: text11, cause: cause2 }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text11}.
Error message: ${getErrorMessage3(cause2)}`,
      cause: cause2
    });
    this[_a7] = true;
    this.text = text11;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var LoadAPIKeyError = class extends AISDKError {
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = true;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker8);
  }
};
_a8 = symbol8;
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var TooManyEmbeddingValuesForCallError = class extends AISDKError {
  constructor(options3) {
    super({
      name: name11,
      message: `Too many values for a single embedding call. The ${options3.provider} model "${options3.modelId}" can only embed up to ${options3.maxEmbeddingsPerCall} values per call, but ${options3.values.length} values were provided.`
    });
    this[_a12] = true;
    this.provider = options3.provider;
    this.modelId = options3.modelId;
    this.maxEmbeddingsPerCall = options3.maxEmbeddingsPerCall;
    this.values = options3.values;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker12);
  }
};
_a12 = symbol12;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value: value6, cause: cause2 }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value6)}.
Error message: ${getErrorMessage3(cause2)}`,
      cause: cause2
    });
    this[_a13] = true;
    this.value = value6;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker13);
  }
  static wrap({
    value: value6,
    cause: cause2
  }) {
    return _TypeValidationError2.isInstance(cause2) && cause2.value === value6 ? cause2 : new _TypeValidationError2({ value: value6, cause: cause2 });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var UnsupportedFunctionalityError = class extends AISDKError {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = true;
    this.functionality = functionality;
  }
  static isInstance(error4) {
    return AISDKError.hasMarker(error4, marker14);
  }
};
_a14 = symbol14;

// node_modules/nanoid/non-secure/index.js
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size17 = defaultSize) => {
    let id2 = "";
    let i = size17 | 0;
    while (i--) {
      id2 += alphabet[Math.random() * alphabet.length | 0];
    }
    return id2;
  };
};

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);
function combineHeaders(...headers) {
  return headers.reduce((combinedHeaders, currentHeaders) => ({
    ...combinedHeaders,
    ...currentHeaders != null ? currentHeaders : {}
  }), {});
}
function createEventSourceParserStream() {
  let buffer3 = "";
  let event = undefined;
  let data = [];
  let lastEventId = undefined;
  let retry6 = undefined;
  function parseLine(line4, controller) {
    if (line4 === "") {
      dispatchEvent(controller);
      return;
    }
    if (line4.startsWith(":")) {
      return;
    }
    const colonIndex = line4.indexOf(":");
    if (colonIndex === -1) {
      handleField(line4, "");
      return;
    }
    const field = line4.slice(0, colonIndex);
    const valueStart = colonIndex + 1;
    const value6 = valueStart < line4.length && line4[valueStart] === " " ? line4.slice(valueStart + 1) : line4.slice(valueStart);
    handleField(field, value6);
  }
  function dispatchEvent(controller) {
    if (data.length > 0) {
      controller.enqueue({
        event,
        data: data.join(`
`),
        id: lastEventId,
        retry: retry6
      });
      data = [];
      event = undefined;
      retry6 = undefined;
    }
  }
  function handleField(field, value6) {
    switch (field) {
      case "event":
        event = value6;
        break;
      case "data":
        data.push(value6);
        break;
      case "id":
        lastEventId = value6;
        break;
      case "retry":
        const parsedRetry = parseInt(value6, 10);
        if (!isNaN(parsedRetry)) {
          retry6 = parsedRetry;
        }
        break;
    }
  }
  return new TransformStream({
    transform(chunk4, controller) {
      const { lines: lines3, incompleteLine } = splitLines4(buffer3, chunk4);
      buffer3 = incompleteLine;
      for (let i = 0;i < lines3.length; i++) {
        parseLine(lines3[i], controller);
      }
    },
    flush(controller) {
      parseLine(buffer3, controller);
      dispatchEvent(controller);
    }
  });
}
function splitLines4(buffer3, chunk4) {
  const lines3 = [];
  let currentLine = buffer3;
  for (let i = 0;i < chunk4.length; ) {
    const char4 = chunk4[i++];
    if (char4 === `
`) {
      lines3.push(currentLine);
      currentLine = "";
    } else if (char4 === "\r") {
      lines3.push(currentLine);
      currentLine = "";
      if (chunk4[i] === `
`) {
        i++;
      }
    } else {
      currentLine += char4;
    }
  }
  return { lines: lines3, incompleteLine: currentLine };
}
function extractResponseHeaders(response) {
  const headers = {};
  response.headers.forEach((value6, key) => {
    headers[key] = value6;
  });
  return headers;
}
var createIdGenerator = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size17) => `${prefix}${separator}${generator(size17)}`;
};
var generateId = createIdGenerator();
function removeUndefinedEntries(record3) {
  return Object.fromEntries(Object.entries(record3).filter(([_key, value6]) => value6 != null));
}
function isAbortError(error4) {
  return error4 instanceof Error && (error4.name === "AbortError" || error4.name === "TimeoutError");
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate7) {
  return { [validatorSymbol]: true, validate: validate7 };
}
function isValidator(value6) {
  return typeof value6 === "object" && value6 !== null && validatorSymbol in value6 && value6[validatorSymbol] === true && "validate" in value6;
}
function asValidator(value6) {
  return isValidator(value6) ? value6 : zodValidator(value6);
}
function zodValidator(zodSchema) {
  return validator((value6) => {
    const result = zodSchema.safeParse(value6);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function validateTypes({
  value: value6,
  schema: inputSchema
}) {
  const result = safeValidateTypes({ value: value6, schema: inputSchema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value: value6, cause: result.error });
  }
  return result.value;
}
function safeValidateTypes({
  value: value6,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value: value6 };
    }
    const result = validator2.validate(value6);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value: value6, cause: result.error })
    };
  } catch (error4) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value: value6, cause: error4 })
    };
  }
}
function parseJSON({
  text: text11,
  schema
}) {
  try {
    const value6 = import_secure_json_parse.default.parse(text11);
    if (schema == null) {
      return value6;
    }
    return validateTypes({ value: value6, schema });
  } catch (error4) {
    if (JSONParseError.isInstance(error4) || TypeValidationError.isInstance(error4)) {
      throw error4;
    }
    throw new JSONParseError({ text: text11, cause: error4 });
  }
}
function safeParseJSON({
  text: text11,
  schema
}) {
  try {
    const value6 = import_secure_json_parse.default.parse(text11);
    if (schema == null) {
      return { success: true, value: value6, rawValue: value6 };
    }
    const validationResult = safeValidateTypes({ value: value6, schema });
    return validationResult.success ? { ...validationResult, rawValue: value6 } : validationResult;
  } catch (error4) {
    return {
      success: false,
      error: JSONParseError.isInstance(error4) ? error4 : new JSONParseError({ text: text11, cause: error4 })
    };
  }
}
function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? undefined : providerOptions[provider]) == null) {
    return;
  }
  const parsedProviderOptions = safeValidateTypes({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url: url2,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url: url2,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url: url2,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url2, {
      method: "POST",
      headers: removeUndefinedEntries(headers),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values
        });
      } catch (error4) {
        if (isAbortError(error4) || APICallError.isInstance(error4)) {
          throw error4;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error4,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: body.values
      });
    } catch (error4) {
      if (error4 instanceof Error) {
        if (isAbortError(error4) || APICallError.isInstance(error4)) {
          throw error4;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error4,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error4) {
    if (isAbortError(error4)) {
      throw error4;
    }
    if (error4 instanceof TypeError && error4.message === "fetch failed") {
      const cause2 = error4.cause;
      if (cause2 != null) {
        throw new APICallError({
          message: `Cannot connect to API: ${cause2.message}`,
          cause: cause2,
          url: url2,
          requestBodyValues: body.values,
          isRetryable: true
        });
      }
    }
    throw error4;
  }
};
async function resolve3(value6) {
  if (typeof value6 === "function") {
    value6 = value6();
  }
  return Promise.resolve(value6);
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError({
        message: errorToMessage(parsedError),
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? undefined : isRetryable(response, parsedError)
      })
    };
  } catch (parseError3) {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: response.body.pipeThrough(new TextDecoderStream).pipeThrough(createEventSourceParserStream()).pipeThrough(new TransformStream({
      transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(safeParseJSON({
          text: data,
          schema: chunkSchema
        }));
      }
    }))
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = safeParseJSON({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url: url2,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var { btoa: btoa2, atob: atob2 } = globalThis;
function convertUint8ArrayToBase64(array9) {
  let latin1string = "";
  for (let i = 0;i < array9.length; i++) {
    latin1string += String.fromCodePoint(array9[i]);
  }
  return btoa2(latin1string);
}
function withoutTrailingSlash(url2) {
  return url2 == null ? undefined : url2.replace(/\/$/, "");
}

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid2,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom3,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys5 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys5.push(key);
      }
    }
    return keys5;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array9, separator = " | ") {
    return array9.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value6) => {
    if (typeof value6 === "bigint") {
      return value6.toString();
    }
    return value6;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first3, second) => {
    return {
      ...first3,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error4) => {
      for (const issue of error4.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value6) {
    if (!(value6 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value6}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error4 = new ZodError(issues);
  return error4;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map34) {
  overrideErrorMap = map34;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path: path3, errorMaps, issueData } = params;
  const fullPath = [...path3, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map34 of maps) {
    errorMessage = map34(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status2, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status2.dirty();
      arrayValue.push(s.value);
    }
    return { status: status2.value, value: arrayValue };
  }
  static async mergeObjectAsync(status2, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value6 = await pair.value;
      syncPairs.push({
        key,
        value: value6
      });
    }
    return ParseStatus.mergeObjectSync(status2, syncPairs);
  }
  static mergeObjectSync(status2, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value6 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value6.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status2.dirty();
      if (value6.status === "dirty")
        status2.dirty();
      if (key.value !== "__proto__" && (typeof value6.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value6.value;
      }
    }
    return { status: status2.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value6) => ({ status: "dirty", value: value6 });
var OK = (value6) => ({ status: "valid", value: value6 });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid2 = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value6, path3, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value6;
    this._path = path3;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error4 = new ZodError(ctx.common.issues);
        this._error = error4;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option4) {
    return ZodUnion.create([this, option4], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform4) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform4 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args2) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args2.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args2.precision}}`;
  } else if (args2.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args2.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args2) {
  return new RegExp(`^${timeRegexSource(args2)}$`);
}
function datetimeRegex(args2) {
  let regex = `${dateRegexSource}T${timeRegexSource(args2)}`;
  const opts = [];
  opts.push(args2.local ? `Z?` : `Z`);
  if (args2.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status2 = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status2.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options3) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options3) });
  }
  ip(options3) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options3) });
  }
  cidr(options3) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options3) });
  }
  datetime(options3) {
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options3
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options3?.precision === "undefined" ? null : options3?.precision,
      offset: options3?.offset ?? false,
      local: options3?.local ?? false,
      ...errorUtil.errToObj(options3?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options3) {
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options3
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options3?.precision === "undefined" ? null : options3?.precision,
      ...errorUtil.errToObj(options3?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value6, options3) {
    return this._addCheck({
      kind: "includes",
      value: value6,
      position: options3?.position,
      ...errorUtil.errToObj(options3?.message)
    });
  }
  startsWith(value6, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value6,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value6, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value6,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxLength() {
    let max7 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max7 === null || ch.value < max7)
          max7 = ch.value;
      }
    }
    return max7;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step3) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step3.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step3.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status2 = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  gte(value6, message) {
    return this.setLimit("min", value6, true, errorUtil.toString(message));
  }
  gt(value6, message) {
    return this.setLimit("min", value6, false, errorUtil.toString(message));
  }
  lte(value6, message) {
    return this.setLimit("max", value6, true, errorUtil.toString(message));
  }
  lt(value6, message) {
    return this.setLimit("max", value6, false, errorUtil.toString(message));
  }
  setLimit(kind, value6, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value6,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value6, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value6,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxValue() {
    let max7 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max7 === null || ch.value < max7)
          max7 = ch.value;
      }
    }
    return max7;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max7 = null;
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      } else if (ch.kind === "max") {
        if (max7 === null || ch.value < max7)
          max7 = ch.value;
      }
    }
    return Number.isFinite(min5) && Number.isFinite(max7);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status2 = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value6, message) {
    return this.setLimit("min", value6, true, errorUtil.toString(message));
  }
  gt(value6, message) {
    return this.setLimit("min", value6, false, errorUtil.toString(message));
  }
  lte(value6, message) {
    return this.setLimit("max", value6, true, errorUtil.toString(message));
  }
  lt(value6, message) {
    return this.setLimit("max", value6, false, errorUtil.toString(message));
  }
  setLimit(kind, value6, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value6,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value6, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value6,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxValue() {
    let max7 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max7 === null || ch.value < max7)
          max7 = ch.value;
      }
    }
    return max7;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status2 = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status2.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5 != null ? new Date(min5) : null;
  }
  get maxDate() {
    let max7 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max7 === null || ch.value < max7)
          max7 = ch.value;
      }
    }
    return max7 != null ? new Date(max7) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status: status2 } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status2.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status2.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status2.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status2, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status2, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys5 = util.objectKeys(shape);
    this._cached = { shape, keys: keys5 };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status: status2, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value6 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value6, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status2.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value6 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value6, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value6 = await pair.value;
          syncPairs.push({
            key,
            value: value6,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status2, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options3 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options3.map(async (option4) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option4._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option4 of options3) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option4._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return util.objectValues(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [undefined];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else if (type2 instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodBranded) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodReadonly) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodCatch) {
    return getDiscriminator(type2._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator2 = this.discriminator;
    const discriminatorValue = ctx.data[discriminator2];
    const option4 = this.optionsMap.get(discriminatorValue);
    if (!option4) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator2]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option4._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option4._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator2, options3, params) {
    const optionsMap = new Map;
    for (const type2 of options3) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator2]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator2}\` could not be extracted from all schema options`);
      }
      for (const value6 of discriminatorValues) {
        if (optionsMap.has(value6)) {
          throw new Error(`Discriminator property ${String(discriminator2)} has duplicate value ${String(value6)}`);
        }
        optionsMap.set(value6, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: discriminator2,
      options: options3,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status2.dirty();
      }
      return { status: status2.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left3, right3]) => handleParsed(left3, right3));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left3, right3, params) => {
  return new ZodIntersection({
    left: left3,
    right: right3,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status2.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status2, results);
      });
    } else {
      return ParseStatus.mergeArray(status2, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status2, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first3, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first3,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first3,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value6], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value6, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value6 = await pair.value;
          if (key.status === "aborted" || value6.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value6.status === "dirty") {
            status2.dirty();
          }
          finalMap.set(key.value, value6.value);
        }
        return { status: status2.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value6 = pair.value;
        if (key.status === "aborted" || value6.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value6.status === "dirty") {
          status2.dirty();
        }
        finalMap.set(key.value, value6.value);
      }
      return { status: status2.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status2.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status2.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status2.dirty();
        parsedSet.add(element.value);
      }
      return { status: status2.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size17, message) {
    return this.min(size17, message).max(size17, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args2, error4) {
      return makeIssue({
        data: args2,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error4
        }
      });
    }
    function makeReturnsIssue(returns, error4) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error4
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args2) {
        const error4 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args2, params).catch((e) => {
          error4.addIssue(makeArgsIssue(args2, e));
          throw error4;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error4.addIssue(makeReturnsIssue(result, e));
          throw error4;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args2) {
        const parsedArgs = me._def.args.safeParse(args2, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args2, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args2, returns, params) {
    return new ZodFunction({
      args: args2 ? args2 : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value6, params) => {
  return new ZodLiteral({
    value: value6,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values4, params) {
  return new ZodEnum({
    values: values4,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values4, newDef = this._def) {
    return ZodEnum.create(values4, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values4, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values4.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values4, params) => {
  return new ZodNativeEnum({
    values: values4,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const effect4 = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status2.abort();
        } else {
          status2.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect4.type === "preprocess") {
      const processed = effect4.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status2.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status2.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status2.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status2.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect4.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect4.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status2.dirty();
        executeRefinement(inner.value);
        return { status: status2.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status2.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status2.value, value: inner.value };
          });
        });
      }
    }
    if (effect4.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base))
          return INVALID;
        const result = effect4.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status2.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid2(base))
            return INVALID;
          return Promise.resolve(effect4.transform(base.value, checkCtx)).then((result) => ({
            status: status2.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect4);
  }
}
ZodEffects.create = (schema, effect4, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect4,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status2.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status2.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p3 === "string" ? { message: p3 } : p3;
  return p22;
}
function custom3(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check2(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom3((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// node_modules/@ai-sdk/google/dist/index.mjs
function convertJSONSchemaToOpenAPISchema(jsonSchema) {
  if (isEmptyObjectSchema(jsonSchema)) {
    return;
  }
  if (typeof jsonSchema === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type: type2,
    description,
    required: required3,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format: format8,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema;
  const result = {};
  if (description)
    result.description = description;
  if (required3)
    result.required = required3;
  if (format8)
    result.format = format8;
  if (constValue !== undefined) {
    result.enum = [constValue];
  }
  if (type2) {
    if (Array.isArray(type2)) {
      if (type2.includes("null")) {
        result.type = type2.filter((t) => t !== "null")[0];
        result.nullable = true;
      } else {
        result.type = type2;
      }
    } else if (type2 === "null") {
      result.type = "null";
    } else {
      result.type = type2;
    }
  }
  if (enumValues !== undefined) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce((acc, [key, value6]) => {
      acc[key] = convertJSONSchemaToOpenAPISchema(value6);
      return acc;
    }, {});
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (anyOf) {
    if (anyOf.some((schema) => typeof schema === "object" && (schema == null ? undefined : schema.type) === "null")) {
      const nonNullSchemas = anyOf.filter((schema) => !(typeof schema === "object" && (schema == null ? undefined : schema.type) === "null"));
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (minLength !== undefined) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema(jsonSchema) {
  return jsonSchema != null && typeof jsonSchema === "object" && jsonSchema.type === "object" && (jsonSchema.properties == null || Object.keys(jsonSchema.properties).length === 0) && !jsonSchema.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt4) {
  var _a15, _b;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  for (const { role, content } of prompt4) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new UnsupportedFunctionalityError({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts2 = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts2.push({ text: part.text });
              break;
            }
            case "image": {
              parts2.push(part.image instanceof URL ? {
                fileData: {
                  mimeType: (_a15 = part.mimeType) != null ? _a15 : "image/jpeg",
                  fileUri: part.image.toString()
                }
              } : {
                inlineData: {
                  mimeType: (_b = part.mimeType) != null ? _b : "image/jpeg",
                  data: convertUint8ArrayToBase64(part.image)
                }
              });
              break;
            }
            case "file": {
              parts2.push(part.data instanceof URL ? {
                fileData: {
                  mimeType: part.mimeType,
                  fileUri: part.data.toString()
                }
              } : {
                inlineData: {
                  mimeType: part.mimeType,
                  data: part.data
                }
              });
              break;
            }
          }
        }
        contents.push({ role: "user", parts: parts2 });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? undefined : { text: part.text };
              }
              case "file": {
                if (part.mimeType !== "image/png") {
                  throw new UnsupportedFunctionalityError({
                    functionality: "Only PNG images are supported in assistant messages"
                  });
                }
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mimeType,
                    data: part.data
                  }
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.args
                  }
                };
              }
            }
          }).filter((part) => part !== undefined)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        contents.push({
          role: "user",
          parts: content.map((part) => ({
            functionResponse: {
              name: part.toolName,
              response: {
                name: part.toolName,
                content: part.result
              }
            }
          }))
        });
        break;
      }
    }
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 ? { parts: systemInstructionParts } : undefined,
    contents
  };
}
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleErrorDataSchema = exports_external.object({
  error: exports_external.object({
    code: exports_external.number().nullable(),
    message: exports_external.string(),
    status: exports_external.string()
  })
});
var googleFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: googleErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function prepareTools(mode, useSearchGrounding, dynamicRetrievalConfig, modelId) {
  var _a15, _b;
  const tools = ((_a15 = mode.tools) == null ? undefined : _a15.length) ? mode.tools : undefined;
  const toolWarnings = [];
  const isGemini2 = modelId.includes("gemini-2");
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  if (useSearchGrounding) {
    return {
      tools: isGemini2 ? { googleSearch: {} } : {
        googleSearchRetrieval: !supportsDynamicRetrieval || !dynamicRetrievalConfig ? {} : { dynamicRetrievalConfig }
      },
      toolConfig: undefined,
      toolWarnings
    };
  }
  if (tools == null) {
    return { tools: undefined, toolConfig: undefined, toolWarnings };
  }
  const functionDeclarations = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      functionDeclarations.push({
        name: tool.name,
        description: (_b = tool.description) != null ? _b : "",
        parameters: convertJSONSchemaToOpenAPISchema(tool.parameters)
      });
    }
  }
  const toolChoice = mode.toolChoice;
  if (toolChoice == null) {
    return {
      tools: { functionDeclarations },
      toolConfig: undefined,
      toolWarnings
    };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: { functionDeclarations },
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    default:
      return "unknown";
  }
}
var GoogleGenerativeAILanguageModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v1";
    this.defaultObjectGenerationMode = "json";
    this.supportsImageUrls = false;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config2;
  }
  get supportsStructuredOutputs() {
    var _a15;
    return (_a15 = this.settings.structuredOutputs) != null ? _a15 : true;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    mode,
    prompt: prompt4,
    maxTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerMetadata
  }) {
    var _a15, _b, _c;
    const type2 = mode.type;
    const warnings = [];
    const googleOptions = parseProviderOptions({
      provider: "google",
      providerOptions: providerMetadata,
      schema: googleGenerativeAIProviderOptionsSchema
    });
    if (((_a15 = googleOptions == null ? undefined : googleOptions.thinkingConfig) == null ? undefined : _a15.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
      warnings.push({
        type: "other",
        message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
      });
    }
    const generationConfig = {
      maxOutputTokens: maxTokens,
      temperature,
      topK,
      topP,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      seed,
      responseMimeType: (responseFormat == null ? undefined : responseFormat.type) === "json" ? "application/json" : undefined,
      responseSchema: (responseFormat == null ? undefined : responseFormat.type) === "json" && responseFormat.schema != null && this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : undefined,
      ...this.settings.audioTimestamp && {
        audioTimestamp: this.settings.audioTimestamp
      },
      responseModalities: googleOptions == null ? undefined : googleOptions.responseModalities,
      thinkingConfig: googleOptions == null ? undefined : googleOptions.thinkingConfig
    };
    const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(prompt4);
    switch (type2) {
      case "regular": {
        const { tools, toolConfig, toolWarnings } = prepareTools(mode, (_b = this.settings.useSearchGrounding) != null ? _b : false, this.settings.dynamicRetrievalConfig, this.modelId);
        return {
          args: {
            generationConfig,
            contents,
            systemInstruction,
            safetySettings: this.settings.safetySettings,
            tools,
            toolConfig,
            cachedContent: this.settings.cachedContent
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      case "object-json": {
        return {
          args: {
            generationConfig: {
              ...generationConfig,
              responseMimeType: "application/json",
              responseSchema: mode.schema != null && this.supportsStructuredOutputs ? convertJSONSchemaToOpenAPISchema(mode.schema) : undefined
            },
            contents,
            systemInstruction,
            safetySettings: this.settings.safetySettings,
            cachedContent: this.settings.cachedContent
          },
          warnings
        };
      }
      case "object-tool": {
        return {
          args: {
            generationConfig,
            contents,
            systemInstruction,
            tools: {
              functionDeclarations: [
                {
                  name: mode.tool.name,
                  description: (_c = mode.tool.description) != null ? _c : "",
                  parameters: convertJSONSchemaToOpenAPISchema(mode.tool.parameters)
                }
              ]
            },
            toolConfig: { functionCallingConfig: { mode: "ANY" } },
            safetySettings: this.settings.safetySettings,
            cachedContent: this.settings.cachedContent
          },
          warnings
        };
      }
      default: {
        const _exhaustiveCheck = type2;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  supportsUrl(url2) {
    return this.config.isSupportedUrl(url2);
  }
  async doGenerate(options3) {
    var _a15, _b, _c, _d, _e;
    const { args: args2, warnings } = await this.getArgs(options3);
    const body = JSON.stringify(args2);
    const mergedHeaders = combineHeaders(await resolve3(this.config.headers), options3.headers);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:generateContent`,
      headers: mergedHeaders,
      body: args2,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(responseSchema),
      abortSignal: options3.abortSignal,
      fetch: this.config.fetch
    });
    const { contents: rawPrompt, ...rawSettings } = args2;
    const candidate = response.candidates[0];
    const parts2 = candidate.content == null || typeof candidate.content !== "object" || !("parts" in candidate.content) ? [] : candidate.content.parts;
    const toolCalls = getToolCallsFromParts({
      parts: parts2,
      generateId: this.config.generateId
    });
    const usageMetadata = response.usageMetadata;
    return {
      text: getTextFromParts(parts2),
      reasoning: getReasoningDetailsFromParts(parts2),
      files: (_a15 = getInlineDataParts(parts2)) == null ? undefined : _a15.map((part) => ({
        data: part.inlineData.data,
        mimeType: part.inlineData.mimeType
      })),
      toolCalls,
      finishReason: mapGoogleGenerativeAIFinishReason({
        finishReason: candidate.finishReason,
        hasToolCalls: toolCalls != null && toolCalls.length > 0
      }),
      usage: {
        promptTokens: (_b = usageMetadata == null ? undefined : usageMetadata.promptTokenCount) != null ? _b : NaN,
        completionTokens: (_c = usageMetadata == null ? undefined : usageMetadata.candidatesTokenCount) != null ? _c : NaN
      },
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders, body: rawResponse },
      warnings,
      providerMetadata: {
        google: {
          groundingMetadata: (_d = candidate.groundingMetadata) != null ? _d : null,
          safetyRatings: (_e = candidate.safetyRatings) != null ? _e : null
        }
      },
      sources: extractSources({
        groundingMetadata: candidate.groundingMetadata,
        generateId: this.config.generateId
      }),
      request: { body }
    };
  }
  async doStream(options3) {
    const { args: args2, warnings } = await this.getArgs(options3);
    const body = JSON.stringify(args2);
    const headers = combineHeaders(await resolve3(this.config.headers), options3.headers);
    const { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:streamGenerateContent?alt=sse`,
      headers,
      body: args2,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),
      abortSignal: options3.abortSignal,
      fetch: this.config.fetch
    });
    const { contents: rawPrompt, ...rawSettings } = args2;
    let finishReason = "unknown";
    let usage = {
      promptTokens: Number.NaN,
      completionTokens: Number.NaN
    };
    let providerMetadata = undefined;
    const generateId2 = this.config.generateId;
    let hasToolCalls = false;
    return {
      stream: response.pipeThrough(new TransformStream({
        transform(chunk4, controller) {
          var _a15, _b, _c, _d, _e, _f;
          if (!chunk4.success) {
            controller.enqueue({ type: "error", error: chunk4.error });
            return;
          }
          const value6 = chunk4.value;
          const usageMetadata = value6.usageMetadata;
          if (usageMetadata != null) {
            usage = {
              promptTokens: (_a15 = usageMetadata.promptTokenCount) != null ? _a15 : NaN,
              completionTokens: (_b = usageMetadata.candidatesTokenCount) != null ? _b : NaN
            };
          }
          const candidate = (_c = value6.candidates) == null ? undefined : _c[0];
          if (candidate == null) {
            return;
          }
          const content = candidate.content;
          if (content != null) {
            const deltaText = getTextFromParts(content.parts);
            if (deltaText != null) {
              controller.enqueue({
                type: "text-delta",
                textDelta: deltaText
              });
            }
            const reasoningDeltaText = getReasoningDetailsFromParts(content.parts);
            if (reasoningDeltaText != null) {
              for (const part of reasoningDeltaText) {
                controller.enqueue({
                  type: "reasoning",
                  textDelta: part.text
                });
              }
            }
            const inlineDataParts = getInlineDataParts(content.parts);
            if (inlineDataParts != null) {
              for (const part of inlineDataParts) {
                controller.enqueue({
                  type: "file",
                  mimeType: part.inlineData.mimeType,
                  data: part.inlineData.data
                });
              }
            }
            const toolCallDeltas = getToolCallsFromParts({
              parts: content.parts,
              generateId: generateId2
            });
            if (toolCallDeltas != null) {
              for (const toolCall of toolCallDeltas) {
                controller.enqueue({
                  type: "tool-call-delta",
                  toolCallType: "function",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  argsTextDelta: toolCall.args
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallType: "function",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  args: toolCall.args
                });
                hasToolCalls = true;
              }
            }
          }
          if (candidate.finishReason != null) {
            finishReason = mapGoogleGenerativeAIFinishReason({
              finishReason: candidate.finishReason,
              hasToolCalls
            });
            const sources = (_d = extractSources({
              groundingMetadata: candidate.groundingMetadata,
              generateId: generateId2
            })) != null ? _d : [];
            for (const source of sources) {
              controller.enqueue({ type: "source", source });
            }
            providerMetadata = {
              google: {
                groundingMetadata: (_e = candidate.groundingMetadata) != null ? _e : null,
                safetyRatings: (_f = candidate.safetyRatings) != null ? _f : null
              }
            };
          }
        },
        flush(controller) {
          controller.enqueue({
            type: "finish",
            finishReason,
            usage,
            providerMetadata
          });
        }
      })),
      rawCall: { rawPrompt, rawSettings },
      rawResponse: { headers: responseHeaders },
      warnings,
      request: { body }
    };
  }
};
function getToolCallsFromParts({
  parts: parts2,
  generateId: generateId2
}) {
  const functionCallParts = parts2 == null ? undefined : parts2.filter((part) => ("functionCall" in part));
  return functionCallParts == null || functionCallParts.length === 0 ? undefined : functionCallParts.map((part) => ({
    toolCallType: "function",
    toolCallId: generateId2(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args)
  }));
}
function getTextFromParts(parts2) {
  const textParts = parts2 == null ? undefined : parts2.filter((part) => ("text" in part) && part.thought !== true);
  return textParts == null || textParts.length === 0 ? undefined : textParts.map((part) => part.text).join("");
}
function getReasoningDetailsFromParts(parts2) {
  const reasoningParts = parts2 == null ? undefined : parts2.filter((part) => ("text" in part) && part.thought === true && part.text != null);
  return reasoningParts == null || reasoningParts.length === 0 ? undefined : reasoningParts.map((part) => ({ type: "text", text: part.text }));
}
function getInlineDataParts(parts2) {
  return parts2 == null ? undefined : parts2.filter((part) => ("inlineData" in part));
}
function extractSources({
  groundingMetadata,
  generateId: generateId2
}) {
  var _a15;
  return (_a15 = groundingMetadata == null ? undefined : groundingMetadata.groundingChunks) == null ? undefined : _a15.filter((chunk4) => chunk4.web != null).map((chunk4) => ({
    sourceType: "url",
    id: generateId2(),
    url: chunk4.web.uri,
    title: chunk4.web.title
  }));
}
var contentSchema = exports_external.object({
  parts: exports_external.array(exports_external.union([
    exports_external.object({
      functionCall: exports_external.object({
        name: exports_external.string(),
        args: exports_external.unknown()
      })
    }),
    exports_external.object({
      inlineData: exports_external.object({
        mimeType: exports_external.string(),
        data: exports_external.string()
      })
    }),
    exports_external.object({
      text: exports_external.string().nullish(),
      thought: exports_external.boolean().nullish()
    })
  ])).nullish()
});
var groundingChunkSchema = exports_external.object({
  web: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish(),
  retrievedContext: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish()
});
var groundingMetadataSchema = exports_external.object({
  webSearchQueries: exports_external.array(exports_external.string()).nullish(),
  retrievalQueries: exports_external.array(exports_external.string()).nullish(),
  searchEntryPoint: exports_external.object({ renderedContent: exports_external.string() }).nullish(),
  groundingChunks: exports_external.array(groundingChunkSchema).nullish(),
  groundingSupports: exports_external.array(exports_external.object({
    segment: exports_external.object({
      startIndex: exports_external.number().nullish(),
      endIndex: exports_external.number().nullish(),
      text: exports_external.string().nullish()
    }),
    segment_text: exports_external.string().nullish(),
    groundingChunkIndices: exports_external.array(exports_external.number()).nullish(),
    supportChunkIndices: exports_external.array(exports_external.number()).nullish(),
    confidenceScores: exports_external.array(exports_external.number()).nullish(),
    confidenceScore: exports_external.array(exports_external.number()).nullish()
  })).nullish(),
  retrievalMetadata: exports_external.union([
    exports_external.object({
      webDynamicRetrievalScore: exports_external.number()
    }),
    exports_external.object({})
  ]).nullish()
});
var safetyRatingSchema = exports_external.object({
  category: exports_external.string().nullish(),
  probability: exports_external.string().nullish(),
  probabilityScore: exports_external.number().nullish(),
  severity: exports_external.string().nullish(),
  severityScore: exports_external.number().nullish(),
  blocked: exports_external.boolean().nullish()
});
var responseSchema = exports_external.object({
  candidates: exports_external.array(exports_external.object({
    content: contentSchema.nullish().or(exports_external.object({}).strict()),
    finishReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(safetyRatingSchema).nullish(),
    groundingMetadata: groundingMetadataSchema.nullish()
  })),
  usageMetadata: exports_external.object({
    promptTokenCount: exports_external.number().nullish(),
    candidatesTokenCount: exports_external.number().nullish(),
    totalTokenCount: exports_external.number().nullish()
  }).nullish()
});
var chunkSchema = exports_external.object({
  candidates: exports_external.array(exports_external.object({
    content: contentSchema.nullish(),
    finishReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(safetyRatingSchema).nullish(),
    groundingMetadata: groundingMetadataSchema.nullish()
  })).nullish(),
  usageMetadata: exports_external.object({
    promptTokenCount: exports_external.number().nullish(),
    candidatesTokenCount: exports_external.number().nullish(),
    totalTokenCount: exports_external.number().nullish()
  }).nullish()
});
var googleGenerativeAIProviderOptionsSchema = exports_external.object({
  responseModalities: exports_external.array(exports_external.enum(["TEXT", "IMAGE"])).nullish(),
  thinkingConfig: exports_external.object({
    thinkingBudget: exports_external.number().nullish(),
    includeThoughts: exports_external.boolean().nullish()
  }).nullish()
});
var GoogleGenerativeAIEmbeddingModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v1";
    this.modelId = modelId;
    this.settings = settings;
    this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    return 2048;
  }
  get supportsParallelCalls() {
    return true;
  }
  async doEmbed({
    values: values4,
    headers,
    abortSignal
  }) {
    if (values4.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values: values4
      });
    }
    const mergedHeaders = combineHeaders(await resolve3(this.config.headers), headers);
    const { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
      headers: mergedHeaders,
      body: {
        requests: values4.map((value6) => ({
          model: `models/${this.modelId}`,
          content: { role: "user", parts: [{ text: value6 }] },
          outputDimensionality: this.settings.outputDimensionality,
          taskType: this.settings.taskType
        }))
      },
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(googleGenerativeAITextEmbeddingResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.embeddings.map((item) => item.values),
      usage: undefined,
      rawResponse: { headers: responseHeaders }
    };
  }
};
var googleGenerativeAITextEmbeddingResponseSchema = exports_external.object({
  embeddings: exports_external.array(exports_external.object({ values: exports_external.array(exports_external.number()) }))
});
function isSupportedFileUrl(url2) {
  return url2.toString().startsWith("https://generativelanguage.googleapis.com/v1beta/files/");
}
function createGoogleGenerativeAI(options3 = {}) {
  var _a15;
  const baseURL = (_a15 = withoutTrailingSlash(options3.baseURL)) != null ? _a15 : "https://generativelanguage.googleapis.com/v1beta";
  const getHeaders = () => ({
    "x-goog-api-key": loadApiKey({
      apiKey: options3.apiKey,
      environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
      description: "Google Generative AI"
    }),
    ...options3.headers
  });
  const createChatModel = (modelId, settings = {}) => {
    var _a22;
    return new GoogleGenerativeAILanguageModel(modelId, settings, {
      provider: "google.generative-ai",
      baseURL,
      headers: getHeaders,
      generateId: (_a22 = options3.generateId) != null ? _a22 : generateId,
      isSupportedUrl: isSupportedFileUrl,
      fetch: options3.fetch
    });
  };
  const createEmbeddingModel = (modelId, settings = {}) => new GoogleGenerativeAIEmbeddingModel(modelId, settings, {
    provider: "google.generative-ai",
    baseURL,
    headers: getHeaders,
    fetch: options3.fetch
  });
  const provider = function(modelId, settings) {
    if (new.target) {
      throw new Error("The Google Generative AI model function cannot be called with the new keyword.");
    }
    return createChatModel(modelId, settings);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.generativeAI = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  return provider;
}
var google = createGoogleGenerativeAI();

// node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/dist/index.mjs
var marker15 = "vercel.ai.error";
var symbol15 = Symbol.for(marker15);
var _a15;
var _AISDKError3 = class _AISDKError4 extends Error {
  constructor({
    name: name14,
    message,
    cause: cause2
  }) {
    super(message);
    this[_a15] = true;
    this.name = name14;
    this.cause = cause2;
  }
  static isInstance(error4) {
    return _AISDKError4.hasMarker(error4, marker15);
  }
  static hasMarker(error4, marker152) {
    const markerSymbol = Symbol.for(marker152);
    return error4 != null && typeof error4 === "object" && markerSymbol in error4 && typeof error4[markerSymbol] === "boolean" && error4[markerSymbol] === true;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
_a15 = symbol15;
var AISDKError2 = _AISDKError3;
var name14 = "AI_APICallError";
var marker22 = `vercel.ai.error.${name14}`;
var symbol23 = Symbol.for(marker22);
var _a22;
_a22 = symbol23;
var name22 = "AI_EmptyResponseBodyError";
var marker32 = `vercel.ai.error.${name22}`;
var symbol33 = Symbol.for(marker32);
var _a32;
_a32 = symbol33;
var name32 = "AI_InvalidArgumentError";
var marker42 = `vercel.ai.error.${name32}`;
var symbol43 = Symbol.for(marker42);
var _a42;
var InvalidArgumentError2 = class extends AISDKError2 {
  constructor({
    message,
    cause: cause2,
    argument
  }) {
    super({ name: name32, message, cause: cause2 });
    this[_a42] = true;
    this.argument = argument;
  }
  static isInstance(error4) {
    return AISDKError2.hasMarker(error4, marker42);
  }
};
_a42 = symbol43;
var name42 = "AI_InvalidPromptError";
var marker52 = `vercel.ai.error.${name42}`;
var symbol52 = Symbol.for(marker52);
var _a52;
_a52 = symbol52;
var name52 = "AI_InvalidResponseDataError";
var marker62 = `vercel.ai.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
_a62 = symbol62;
var name62 = "AI_JSONParseError";
var marker72 = `vercel.ai.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
_a72 = symbol72;
var name72 = "AI_LoadAPIKeyError";
var marker82 = `vercel.ai.error.${name72}`;
var symbol82 = Symbol.for(marker82);
var _a82;
_a82 = symbol82;
var name82 = "AI_LoadSettingError";
var marker92 = `vercel.ai.error.${name82}`;
var symbol92 = Symbol.for(marker92);
var _a92;
_a92 = symbol92;
var name92 = "AI_NoContentGeneratedError";
var marker102 = `vercel.ai.error.${name92}`;
var symbol102 = Symbol.for(marker102);
var _a102;
_a102 = symbol102;
var name102 = "AI_NoSuchModelError";
var marker112 = `vercel.ai.error.${name102}`;
var symbol112 = Symbol.for(marker112);
var _a112;
_a112 = symbol112;
var name112 = "AI_TooManyEmbeddingValuesForCallError";
var marker122 = `vercel.ai.error.${name112}`;
var symbol122 = Symbol.for(marker122);
var _a122;
_a122 = symbol122;
var name122 = "AI_TypeValidationError";
var marker132 = `vercel.ai.error.${name122}`;
var symbol132 = Symbol.for(marker132);
var _a132;
_a132 = symbol132;
var name132 = "AI_UnsupportedFunctionalityError";
var marker142 = `vercel.ai.error.${name132}`;
var symbol142 = Symbol.for(marker142);
var _a142;
_a142 = symbol142;

// node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse2 = __toESM(require_secure_json_parse(), 1);
var createIdGenerator2 = ({
  prefix,
  size: defaultSize = 7,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError2({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size17) => `${prefix}${separator}${generator(size17)}`;
};
var generateId2 = createIdGenerator2();
var validatorSymbol2 = Symbol.for("vercel.ai.validator");

// node_modules/@ai-sdk/ui-utils/dist/index.mjs
var import_secure_json_parse3 = __toESM(require_secure_json_parse(), 1);

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: undefined,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options3) => typeof options3 === "string" ? {
  ...defaultOptions,
  name: options3
} : {
  ...defaultOptions,
  ...options3
};
// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options3) => {
  const _options = getDefaultOptions(options3);
  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(([name15, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name15],
        jsonSchema: undefined
      }
    ]))
  };
};
// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value6, errorMessage, refs) {
  res[key] = value6;
  addErrorMessage(res, key, errorMessage, refs);
}
// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        break;
      case "max":
        setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type2) => {
  if ("type" in type2 && type2.type === "string")
    return false;
  return "allOf" in type2;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === undefined) {
        unevaluatedProperties = undefined;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = undefined;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : undefined;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex2 = undefined;
var zodPatterns = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex2 === undefined) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check2.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_) => {})(check2);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value6, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value6,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value6, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern2 = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern2 += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern2 += source[i];
            pattern2 += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern2 += source[i];
            inCharRange = true;
          } else {
            pattern2 += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern2 += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern2 += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern2 += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern2 += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern2 += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern2);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern2;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type: type2, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type: type2, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys5 = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values4 = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys5, values4],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values4) => typeof values4)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? undefined : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options3 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options3.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {
    const types2 = options3.reduce((types3, x) => {
      const type2 = primitiveMappings[x._def.typeName];
      return type2 && !types3.includes(type2) ? [...types3, type2] : types3;
    }, []);
    return {
      type: types2.length > 1 ? types2 : types2[0]
    };
  } else if (options3.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types2 = options3.reduce((acc, x) => {
      const type2 = typeof x._def.value;
      switch (type2) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type2];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types2.length === options3.length) {
      const uniqueTypes = types2.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options3.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options3.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options3.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === undefined || propDef._def === undefined) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === undefined) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== undefined) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== undefined)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return;
    default:
      return ((_) => {
        return;
      })(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value6, index) => refs.currentPath[index] === value6)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : undefined;
    }
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options3) => {
  const refs = getRefs(options3);
  let definitions = typeof options3 === "object" && options3.definitions ? Object.entries(options3.definitions).reduce((acc, [name16, schema2]) => ({
    ...acc,
    [name16]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name16]
    }, true) ?? parseAnyDef(refs)
  }), {}) : undefined;
  const name15 = typeof options3 === "string" ? options3 : options3?.nameStrategy === "title" ? undefined : options3?.name;
  const main = parseDef(schema._def, name15 === undefined ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name15]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options3 === "object" && options3.name !== undefined && options3.nameStrategy === "title" ? options3.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name15 === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name15
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name15]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && (("anyOf" in combined) || ("oneOf" in combined) || ("allOf" in combined) || ("type" in combined) && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
// node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default = zodToJsonSchema;

// node_modules/@ai-sdk/ui-utils/dist/index.mjs
var textStreamPart = {
  code: "0",
  name: "text",
  parse: (value6) => {
    if (typeof value6 !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value: value6 };
  }
};
var functionCallStreamPart = {
  code: "1",
  name: "function_call",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("function_call" in value6) || typeof value6.function_call !== "object" || value6.function_call == null || !("name" in value6.function_call) || !("arguments" in value6.function_call) || typeof value6.function_call.name !== "string" || typeof value6.function_call.arguments !== "string") {
      throw new Error('"function_call" parts expect an object with a "function_call" property.');
    }
    return {
      type: "function_call",
      value: value6
    };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value6) => {
    if (!Array.isArray(value6)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value: value6 };
  }
};
var errorStreamPart = {
  code: "3",
  name: "error",
  parse: (value6) => {
    if (typeof value6 !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value: value6 };
  }
};
var assistantMessageStreamPart = {
  code: "4",
  name: "assistant_message",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("id" in value6) || !("role" in value6) || !("content" in value6) || typeof value6.id !== "string" || typeof value6.role !== "string" || value6.role !== "assistant" || !Array.isArray(value6.content) || !value6.content.every((item) => item != null && typeof item === "object" && ("type" in item) && item.type === "text" && ("text" in item) && item.text != null && typeof item.text === "object" && ("value" in item.text) && typeof item.text.value === "string")) {
      throw new Error('"assistant_message" parts expect an object with an "id", "role", and "content" property.');
    }
    return {
      type: "assistant_message",
      value: value6
    };
  }
};
var assistantControlDataStreamPart = {
  code: "5",
  name: "assistant_control_data",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("threadId" in value6) || !("messageId" in value6) || typeof value6.threadId !== "string" || typeof value6.messageId !== "string") {
      throw new Error('"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.');
    }
    return {
      type: "assistant_control_data",
      value: {
        threadId: value6.threadId,
        messageId: value6.messageId
      }
    };
  }
};
var dataMessageStreamPart = {
  code: "6",
  name: "data_message",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("role" in value6) || !("data" in value6) || typeof value6.role !== "string" || value6.role !== "data") {
      throw new Error('"data_message" parts expect an object with a "role" and "data" property.');
    }
    return {
      type: "data_message",
      value: value6
    };
  }
};
var toolCallsStreamPart = {
  code: "7",
  name: "tool_calls",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("tool_calls" in value6) || typeof value6.tool_calls !== "object" || value6.tool_calls == null || !Array.isArray(value6.tool_calls) || value6.tool_calls.some((tc) => tc == null || typeof tc !== "object" || !("id" in tc) || typeof tc.id !== "string" || !("type" in tc) || typeof tc.type !== "string" || !("function" in tc) || tc.function == null || typeof tc.function !== "object" || !("arguments" in tc.function) || typeof tc.function.name !== "string" || typeof tc.function.arguments !== "string")) {
      throw new Error('"tool_calls" parts expect an object with a ToolCallPayload.');
    }
    return {
      type: "tool_calls",
      value: value6
    };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value6) => {
    if (!Array.isArray(value6)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value: value6 };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("toolCallId" in value6) || typeof value6.toolCallId !== "string" || !("toolName" in value6) || typeof value6.toolName !== "string" || !("args" in value6) || typeof value6.args !== "object") {
      throw new Error('"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.');
    }
    return {
      type: "tool_call",
      value: value6
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("toolCallId" in value6) || typeof value6.toolCallId !== "string" || !("result" in value6)) {
      throw new Error('"tool_result" parts expect an object with a "toolCallId" and a "result" property.');
    }
    return {
      type: "tool_result",
      value: value6
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("toolCallId" in value6) || typeof value6.toolCallId !== "string" || !("toolName" in value6) || typeof value6.toolName !== "string") {
      throw new Error('"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.');
    }
    return {
      type: "tool_call_streaming_start",
      value: value6
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("toolCallId" in value6) || typeof value6.toolCallId !== "string" || !("argsTextDelta" in value6) || typeof value6.argsTextDelta !== "string") {
      throw new Error('"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.');
    }
    return {
      type: "tool_call_delta",
      value: value6
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("finishReason" in value6) || typeof value6.finishReason !== "string") {
      throw new Error('"finish_message" parts expect an object with a "finishReason" property.');
    }
    const result = {
      finishReason: value6.finishReason
    };
    if ("usage" in value6 && value6.usage != null && typeof value6.usage === "object" && "promptTokens" in value6.usage && "completionTokens" in value6.usage) {
      result.usage = {
        promptTokens: typeof value6.usage.promptTokens === "number" ? value6.usage.promptTokens : Number.NaN,
        completionTokens: typeof value6.usage.completionTokens === "number" ? value6.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value6) => {
    if (value6 == null || typeof value6 !== "object" || !("finishReason" in value6) || typeof value6.finishReason !== "string") {
      throw new Error('"finish_step" parts expect an object with a "finishReason" property.');
    }
    const result = {
      finishReason: value6.finishReason,
      isContinued: false
    };
    if ("usage" in value6 && value6.usage != null && typeof value6.usage === "object" && "promptTokens" in value6.usage && "completionTokens" in value6.usage) {
      result.usage = {
        promptTokens: typeof value6.usage.promptTokens === "number" ? value6.usage.promptTokens : Number.NaN,
        completionTokens: typeof value6.usage.completionTokens === "number" ? value6.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value6 && typeof value6.isContinued === "boolean") {
      result.isContinued = value6.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var streamParts = [
  textStreamPart,
  functionCallStreamPart,
  dataStreamPart,
  errorStreamPart,
  assistantMessageStreamPart,
  assistantControlDataStreamPart,
  dataMessageStreamPart,
  toolCallsStreamPart,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart
];
var streamPartsByCode = {
  [textStreamPart.code]: textStreamPart,
  [functionCallStreamPart.code]: functionCallStreamPart,
  [dataStreamPart.code]: dataStreamPart,
  [errorStreamPart.code]: errorStreamPart,
  [assistantMessageStreamPart.code]: assistantMessageStreamPart,
  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
  [dataMessageStreamPart.code]: dataMessageStreamPart,
  [toolCallsStreamPart.code]: toolCallsStreamPart,
  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,
  [toolCallStreamPart.code]: toolCallStreamPart,
  [toolResultStreamPart.code]: toolResultStreamPart,
  [toolCallStreamingStartStreamPart.code]: toolCallStreamingStartStreamPart,
  [toolCallDeltaStreamPart.code]: toolCallDeltaStreamPart,
  [finishMessageStreamPart.code]: finishMessageStreamPart,
  [finishStepStreamPart.code]: finishStepStreamPart
};
var StreamStringPrefixes = {
  [textStreamPart.name]: textStreamPart.code,
  [functionCallStreamPart.name]: functionCallStreamPart.code,
  [dataStreamPart.name]: dataStreamPart.code,
  [errorStreamPart.name]: errorStreamPart.code,
  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
  [dataMessageStreamPart.name]: dataMessageStreamPart.code,
  [toolCallsStreamPart.name]: toolCallsStreamPart.code,
  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,
  [toolCallStreamPart.name]: toolCallStreamPart.code,
  [toolResultStreamPart.name]: toolResultStreamPart.code,
  [toolCallStreamingStartStreamPart.name]: toolCallStreamingStartStreamPart.code,
  [toolCallDeltaStreamPart.name]: toolCallDeltaStreamPart.code,
  [finishMessageStreamPart.name]: finishMessageStreamPart.code,
  [finishStepStreamPart.name]: finishStepStreamPart.code
};
var validCodes = streamParts.map((part) => part.code);
function formatStreamPart(type2, value6) {
  const streamPart = streamParts.find((part) => part.name === type2);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type2}`);
  }
  return `${streamPart.code}:${JSON.stringify(value6)}
`;
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, {
  validate: validate7
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: undefined,
    [validatorSymbol2]: true,
    jsonSchema: jsonSchema2,
    validate: validate7
  };
}
function isSchema3(value6) {
  return typeof value6 === "object" && value6 !== null && schemaSymbol in value6 && value6[schemaSymbol] === true && "jsonSchema" in value6 && "validate" in value6;
}
function asSchema2(schema) {
  return isSchema3(schema) ? schema : zodSchema(schema);
}
function zodSchema(zodSchema2) {
  return jsonSchema(esm_default(zodSchema2), {
    validate: (value6) => {
      const result = zodSchema2.safeParse(value6);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    }
  });
}

// node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs
var marker17 = "vercel.ai.error";
var symbol17 = Symbol.for(marker17);
var _a17;
var _AISDKError5 = class _AISDKError6 extends Error {
  constructor({
    name: name142,
    message,
    cause: cause2
  }) {
    super(message);
    this[_a17] = true;
    this.name = name142;
    this.cause = cause2;
  }
  static isInstance(error4) {
    return _AISDKError6.hasMarker(error4, marker17);
  }
  static hasMarker(error4, marker152) {
    const markerSymbol = Symbol.for(marker152);
    return error4 != null && typeof error4 === "object" && markerSymbol in error4 && typeof error4[markerSymbol] === "boolean" && error4[markerSymbol] === true;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message
    };
  }
};
_a17 = symbol17;
var AISDKError3 = _AISDKError5;
var name16 = "AI_APICallError";
var marker23 = `vercel.ai.error.${name16}`;
var symbol24 = Symbol.for(marker23);
var _a23;
var APICallError2 = class extends AISDKError3 {
  constructor({
    message,
    url: url2,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause: cause2,
    isRetryable = statusCode != null && (statusCode === 408 || statusCode === 409 || statusCode === 429 || statusCode >= 500),
    data
  }) {
    super({ name: name16, message, cause: cause2 });
    this[_a23] = true;
    this.url = url2;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker23);
  }
  static isAPICallError(error4) {
    return error4 instanceof Error && error4.name === name16 && typeof error4.url === "string" && typeof error4.requestBodyValues === "object" && (error4.statusCode == null || typeof error4.statusCode === "number") && (error4.responseHeaders == null || typeof error4.responseHeaders === "object") && (error4.responseBody == null || typeof error4.responseBody === "string") && (error4.cause == null || typeof error4.cause === "object") && typeof error4.isRetryable === "boolean" && (error4.data == null || typeof error4.data === "object");
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      requestBodyValues: this.requestBodyValues,
      statusCode: this.statusCode,
      responseHeaders: this.responseHeaders,
      responseBody: this.responseBody,
      cause: this.cause,
      isRetryable: this.isRetryable,
      data: this.data
    };
  }
};
_a23 = symbol24;
var name23 = "AI_EmptyResponseBodyError";
var marker33 = `vercel.ai.error.${name23}`;
var symbol34 = Symbol.for(marker33);
var _a33;
_a33 = symbol34;
function getErrorMessage4(error4) {
  if (error4 == null) {
    return "unknown error";
  }
  if (typeof error4 === "string") {
    return error4;
  }
  if (error4 instanceof Error) {
    return error4.message;
  }
  return JSON.stringify(error4);
}
var name33 = "AI_InvalidArgumentError";
var marker43 = `vercel.ai.error.${name33}`;
var symbol44 = Symbol.for(marker43);
var _a43;
var InvalidArgumentError3 = class extends AISDKError3 {
  constructor({
    message,
    cause: cause2,
    argument
  }) {
    super({ name: name33, message, cause: cause2 });
    this[_a43] = true;
    this.argument = argument;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker43);
  }
};
_a43 = symbol44;
var name43 = "AI_InvalidPromptError";
var marker53 = `vercel.ai.error.${name43}`;
var symbol53 = Symbol.for(marker53);
var _a53;
var InvalidPromptError = class extends AISDKError3 {
  constructor({
    prompt: prompt22,
    message,
    cause: cause2
  }) {
    super({ name: name43, message: `Invalid prompt: ${message}`, cause: cause2 });
    this[_a53] = true;
    this.prompt = prompt22;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker53);
  }
  static isInvalidPromptError(error4) {
    return error4 instanceof Error && error4.name === name43 && prompt != null;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      prompt: this.prompt
    };
  }
};
_a53 = symbol53;
var name53 = "AI_InvalidResponseDataError";
var marker63 = `vercel.ai.error.${name53}`;
var symbol63 = Symbol.for(marker63);
var _a63;
_a63 = symbol63;
var name63 = "AI_JSONParseError";
var marker73 = `vercel.ai.error.${name63}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var JSONParseError2 = class extends AISDKError3 {
  constructor({ text: text11, cause: cause2 }) {
    super({
      name: name63,
      message: `JSON parsing failed: Text: ${text11}.
Error message: ${getErrorMessage4(cause2)}`,
      cause: cause2
    });
    this[_a73] = true;
    this.text = text11;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker73);
  }
  static isJSONParseError(error4) {
    return error4 instanceof Error && error4.name === name63 && "text" in error4 && typeof error4.text === "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      valueText: this.text
    };
  }
};
_a73 = symbol73;
var name73 = "AI_LoadAPIKeyError";
var marker83 = `vercel.ai.error.${name73}`;
var symbol83 = Symbol.for(marker83);
var _a83;
_a83 = symbol83;
var name83 = "AI_LoadSettingError";
var marker93 = `vercel.ai.error.${name83}`;
var symbol93 = Symbol.for(marker93);
var _a93;
_a93 = symbol93;
var name93 = "AI_NoContentGeneratedError";
var marker103 = `vercel.ai.error.${name93}`;
var symbol103 = Symbol.for(marker103);
var _a103;
_a103 = symbol103;
var name103 = "AI_NoSuchModelError";
var marker113 = `vercel.ai.error.${name103}`;
var symbol113 = Symbol.for(marker113);
var _a113;
_a113 = symbol113;
var name113 = "AI_TooManyEmbeddingValuesForCallError";
var marker123 = `vercel.ai.error.${name113}`;
var symbol123 = Symbol.for(marker123);
var _a123;
_a123 = symbol123;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError3 = class _TypeValidationError4 extends AISDKError3 {
  constructor({ value: value6, cause: cause2 }) {
    super({
      name: name123,
      message: `Type validation failed: Value: ${JSON.stringify(value6)}.
Error message: ${getErrorMessage4(cause2)}`,
      cause: cause2
    });
    this[_a133] = true;
    this.value = value6;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker133);
  }
  static wrap({
    value: value6,
    cause: cause2
  }) {
    return _TypeValidationError4.isInstance(cause2) && cause2.value === value6 ? cause2 : new _TypeValidationError4({ value: value6, cause: cause2 });
  }
  static isTypeValidationError(error4) {
    return error4 instanceof Error && error4.name === name123;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      value: this.value
    };
  }
};
_a133 = symbol133;
var TypeValidationError2 = _TypeValidationError3;
var name133 = "AI_UnsupportedFunctionalityError";
var marker143 = `vercel.ai.error.${name133}`;
var symbol143 = Symbol.for(marker143);
var _a143;
_a143 = symbol143;

// node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_secure_json_parse4 = __toESM(require_secure_json_parse(), 1);
var createIdGenerator3 = ({
  prefix,
  size: defaultSize = 7,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError3({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size17) => `${prefix}${separator}${generator(size17)}`;
};
var generateId3 = createIdGenerator3();
function getErrorMessage5(error4) {
  if (error4 == null) {
    return "unknown error";
  }
  if (typeof error4 === "string") {
    return error4;
  }
  if (error4 instanceof Error) {
    return error4.message;
  }
  return JSON.stringify(error4);
}
function isAbortError2(error4) {
  return error4 instanceof Error && (error4.name === "AbortError" || error4.name === "TimeoutError");
}
var validatorSymbol3 = Symbol.for("vercel.ai.validator");
function validator2(validate7) {
  return { [validatorSymbol3]: true, validate: validate7 };
}
function isValidator2(value6) {
  return typeof value6 === "object" && value6 !== null && validatorSymbol3 in value6 && value6[validatorSymbol3] === true && "validate" in value6;
}
function asValidator2(value6) {
  return isValidator2(value6) ? value6 : zodValidator2(value6);
}
function zodValidator2(zodSchema2) {
  return validator2((value6) => {
    const result = zodSchema2.safeParse(value6);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes2({
  value: value6,
  schema
}) {
  const validator22 = asValidator2(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value: value6 };
    }
    const result = validator22.validate(value6);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value: value6, cause: result.error })
    };
  } catch (error4) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value: value6, cause: error4 })
    };
  }
}
function safeParseJSON2({
  text: text11,
  schema
}) {
  try {
    const value6 = import_secure_json_parse4.default.parse(text11);
    if (schema == null) {
      return {
        success: true,
        value: value6
      };
    }
    return safeValidateTypes2({ value: value6, schema });
  } catch (error4) {
    return {
      success: false,
      error: JSONParseError2.isJSONParseError(error4) ? error4 : new JSONParseError2({ text: text11, cause: error4 })
    };
  }
}
var { btoa: btoa3, atob: atob3 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob3(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase642(array10) {
  let latin1string = "";
  for (let i = 0;i < array10.length; i++) {
    latin1string += String.fromCodePoint(array10[i]);
  }
  return btoa3(latin1string);
}

// node_modules/ai/dist/index.mjs
var import_api = __toESM(require_src(), 1);
var import_api2 = __toESM(require_src(), 1);
var __defProp2 = Object.defineProperty;
var __export2 = (target, all11) => {
  for (var name114 in all11)
    __defProp2(target, name114, { get: all11[name114], enumerable: true });
};
async function delay2(delayInMs) {
  return delayInMs === undefined ? Promise.resolve() : new Promise((resolve4) => setTimeout(resolve4, delayInMs));
}
var name17 = "AI_RetryError";
var marker18 = `vercel.ai.error.${name17}`;
var symbol18 = Symbol.for(marker18);
var _a18;
var RetryError = class extends AISDKError3 {
  constructor({
    message,
    reason,
    errors: errors3
  }) {
    super({ name: name17, message });
    this[_a18] = true;
    this.reason = reason;
    this.errors = errors3;
    this.lastError = errors3[errors3.length - 1];
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker18);
  }
  static isRetryError(error4) {
    return error4 instanceof Error && error4.name === name17 && typeof error4.reason === "string" && Array.isArray(error4.errors);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      reason: this.reason,
      lastError: this.lastError,
      errors: this.errors
    };
  }
};
_a18 = symbol18;
var retryWithExponentialBackoff = ({
  maxRetries = 2,
  initialDelayInMs = 2000,
  backoffFactor = 2
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor
}, errors3 = []) {
  try {
    return await f();
  } catch (error4) {
    if (isAbortError2(error4)) {
      throw error4;
    }
    if (maxRetries === 0) {
      throw error4;
    }
    const errorMessage = getErrorMessage5(error4);
    const newErrors = [...errors3, error4];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error4 instanceof Error && APICallError2.isAPICallError(error4) && error4.isRetryable === true && tryNumber <= maxRetries) {
      await delay2(delayInMs);
      return _retryWithExponentialBackoff(f, { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor }, newErrors);
    }
    if (tryNumber === 1) {
      throw error4;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    "operation.name": `${operationId}${(telemetry == null ? undefined : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? undefined : telemetry.functionId,
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? undefined : telemetry.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a114;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    ...Object.entries(settings).reduce((attributes, [key, value6]) => {
      attributes[`ai.settings.${key}`] = value6;
      return attributes;
    }, {}),
    ...Object.entries((_a114 = telemetry == null ? undefined : telemetry.metadata) != null ? _a114 : {}).reduce((attributes, [key, value6]) => {
      attributes[`ai.telemetry.metadata.${key}`] = value6;
      return attributes;
    }, {}),
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value6]) => {
      if (value6 !== undefined) {
        attributes[`ai.request.headers.${key}`] = value6;
      }
      return attributes;
    }, {})
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan2;
  },
  startActiveSpan(name114, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan2);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan2);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan2);
    }
  }
};
var noopSpan2 = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled: isEnabled3 = false,
  tracer: tracer2
} = {}) {
  if (!isEnabled3) {
    return noopTracer;
  }
  if (tracer2) {
    return tracer2;
  }
  return import_api.trace.getTracer("ai");
}
function recordSpan({
  name: name114,
  tracer: tracer2,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer2.startActiveSpan(name114, { attributes }, async (span3) => {
    try {
      const result = await fn(span3);
      if (endWhenDone) {
        span3.end();
      }
      return result;
    } catch (error4) {
      try {
        if (error4 instanceof Error) {
          span3.recordException({
            name: error4.name,
            message: error4.message,
            stack: error4.stack
          });
          span3.setStatus({
            code: import_api2.SpanStatusCode.ERROR,
            message: error4.message
          });
        } else {
          span3.setStatus({ code: import_api2.SpanStatusCode.ERROR });
        }
      } finally {
        span3.end();
      }
      throw error4;
    }
  });
}
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? undefined : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value6]) => {
    if (value6 === undefined) {
      return attributes2;
    }
    if (typeof value6 === "object" && "input" in value6 && typeof value6.input === "function") {
      if ((telemetry == null ? undefined : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value6.input();
      return result === undefined ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value6 === "object" && "output" in value6 && typeof value6.output === "function") {
      if ((telemetry == null ? undefined : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value6.output();
      return result === undefined ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value6 };
  }, {});
}
var name24 = "AI_DownloadError";
var marker24 = `vercel.ai.error.${name24}`;
var symbol25 = Symbol.for(marker24);
var _a24;
var DownloadError = class extends AISDKError3 {
  constructor({
    url: url2,
    statusCode,
    statusText,
    cause: cause2,
    message = cause2 == null ? `Failed to download ${url2}: ${statusCode} ${statusText}` : `Failed to download ${url2}: ${cause2}`
  }) {
    super({ name: name24, message, cause: cause2 });
    this[_a24] = true;
    this.url = url2;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker24);
  }
  static isDownloadError(error4) {
    return error4 instanceof Error && error4.name === name24 && typeof error4.url === "string" && (error4.statusCode == null || typeof error4.statusCode === "number") && (error4.statusText == null || typeof error4.statusText === "string");
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      url: this.url,
      statusCode: this.statusCode,
      statusText: this.statusText,
      cause: this.cause
    };
  }
};
_a24 = symbol25;
async function download({
  url: url2,
  fetchImplementation = fetch
}) {
  var _a114;
  const urlText = url2.toString();
  try {
    const response = await fetchImplementation(urlText);
    if (!response.ok) {
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mimeType: (_a114 = response.headers.get("content-type")) != null ? _a114 : undefined
    };
  } catch (error4) {
    if (DownloadError.isInstance(error4)) {
      throw error4;
    }
    throw new DownloadError({ url: urlText, cause: error4 });
  }
}
var mimeTypeSignatures = [
  { mimeType: "image/gif", bytes: [71, 73, 70] },
  { mimeType: "image/png", bytes: [137, 80, 78, 71] },
  { mimeType: "image/jpeg", bytes: [255, 216] },
  { mimeType: "image/webp", bytes: [82, 73, 70, 70] }
];
function detectImageMimeType(image) {
  for (const { bytes, mimeType } of mimeTypeSignatures) {
    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {
      return mimeType;
    }
  }
  return;
}
var name34 = "AI_InvalidDataContentError";
var marker34 = `vercel.ai.error.${name34}`;
var symbol35 = Symbol.for(marker34);
var _a34;
var InvalidDataContentError = class extends AISDKError3 {
  constructor({
    content,
    cause: cause2,
    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`
  }) {
    super({ name: name34, message, cause: cause2 });
    this[_a34] = true;
    this.content = content;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker34);
  }
  static isInvalidDataContentError(error4) {
    return error4 instanceof Error && error4.name === name34 && error4.content != null;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      cause: this.cause,
      content: this.content
    };
  }
};
_a34 = symbol35;
var dataContentSchema = exports_external.union([
  exports_external.string(),
  exports_external.instanceof(Uint8Array),
  exports_external.instanceof(ArrayBuffer),
  exports_external.custom((value6) => {
    var _a114, _b;
    return (_b = (_a114 = globalThis.Buffer) == null ? undefined : _a114.isBuffer(value6)) != null ? _b : false;
  }, { message: "Must be a Buffer" })
]);
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase642(new Uint8Array(content));
  }
  return convertUint8ArrayToBase642(content);
}
function convertDataContentToUint8Array(content) {
  if (content instanceof Uint8Array) {
    return content;
  }
  if (typeof content === "string") {
    try {
      return convertBase64ToUint8Array(content);
    } catch (error4) {
      throw new InvalidDataContentError({
        message: "Invalid data content. Content string is not a base64-encoded media.",
        content,
        cause: error4
      });
    }
  }
  if (content instanceof ArrayBuffer) {
    return new Uint8Array(content);
  }
  throw new InvalidDataContentError({ content });
}
function convertUint8ArrayToText(uint8Array) {
  try {
    return new TextDecoder().decode(uint8Array);
  } catch (error4) {
    throw new Error("Error decoding Uint8Array to text");
  }
}
var name44 = "AI_InvalidMessageRoleError";
var marker44 = `vercel.ai.error.${name44}`;
var symbol45 = Symbol.for(marker44);
var _a44;
var InvalidMessageRoleError = class extends AISDKError3 {
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
  }) {
    super({ name: name44, message });
    this[_a44] = true;
    this.role = role;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker44);
  }
  static isInvalidMessageRoleError(error4) {
    return error4 instanceof Error && error4.name === name44 && typeof error4.role === "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      role: this.role
    };
  }
};
_a44 = symbol45;
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mimeType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error4) {
    return {
      mimeType: undefined,
      base64Content: undefined
    };
  }
}
async function convertToLanguageModelPrompt({
  prompt: prompt4,
  modelSupportsImageUrls = true,
  modelSupportsUrl = () => false,
  downloadImplementation = download
}) {
  const downloadedAssets = await downloadAssets(prompt4.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);
  return [
    ...prompt4.system != null ? [{ role: "system", content: prompt4.system }] : [],
    ...prompt4.messages.map((message) => convertToLanguageModelMessage(message, downloadedAssets))
  ];
}
function convertToLanguageModelMessage(message, downloadedAssets) {
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerMetadata: message.experimental_providerMetadata
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerMetadata: message.experimental_providerMetadata
        };
      }
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerMetadata: message.experimental_providerMetadata
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerMetadata: message.experimental_providerMetadata
        };
      }
      return {
        role: "assistant",
        content: message.content.filter((part) => part.type !== "text" || part.text !== "").map((part) => {
          const { experimental_providerMetadata, ...rest } = part;
          return {
            ...rest,
            providerMetadata: experimental_providerMetadata
          };
        }),
        providerMetadata: message.experimental_providerMetadata
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.map((part) => ({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          result: part.result,
          content: part.experimental_content,
          isError: part.isError,
          providerMetadata: part.experimental_providerMetadata
        })),
        providerMetadata: message.experimental_providerMetadata
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
async function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {
  const urls = messages.filter((message) => message.role === "user").map((message) => message.content).filter((content) => Array.isArray(content)).flat().filter((part) => part.type === "image" || part.type === "file").filter((part) => !(part.type === "image" && modelSupportsImageUrls === true)).map((part) => part.type === "image" ? part.image : part.data).map((part) => typeof part === "string" && (part.startsWith("http:") || part.startsWith("https:")) ? new URL(part) : part).filter((image) => image instanceof URL).filter((url2) => !modelSupportsUrl(url2));
  const downloadedImages = await Promise.all(urls.map(async (url2) => ({
    url: url2,
    data: await downloadImplementation({ url: url2 })
  })));
  return Object.fromEntries(downloadedImages.map(({ url: url2, data }) => [url2.toString(), data]));
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerMetadata: part.experimental_providerMetadata
    };
  }
  let mimeType = part.mimeType;
  let data;
  let content;
  let normalizedData;
  const type2 = part.type;
  switch (type2) {
    case "image":
      data = part.image;
      break;
    case "file":
      data = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type2}`);
  }
  try {
    content = typeof data === "string" ? new URL(data) : data;
  } catch (error4) {
    content = data;
  }
  if (content instanceof URL) {
    if (content.protocol === "data:") {
      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());
      if (dataUrlMimeType == null || base64Content == null) {
        throw new Error(`Invalid data URL format in part ${type2}`);
      }
      mimeType = dataUrlMimeType;
      normalizedData = convertDataContentToUint8Array(base64Content);
    } else {
      const downloadedFile = downloadedAssets[content.toString()];
      if (downloadedFile) {
        normalizedData = downloadedFile.data;
        mimeType != null || (mimeType = downloadedFile.mimeType);
      } else {
        normalizedData = content;
      }
    }
  } else {
    normalizedData = convertDataContentToUint8Array(content);
  }
  switch (type2) {
    case "image":
      if (mimeType == null && normalizedData instanceof Uint8Array) {
        mimeType = detectImageMimeType(normalizedData);
      }
      return {
        type: "image",
        image: normalizedData,
        mimeType,
        providerMetadata: part.experimental_providerMetadata
      };
    case "file":
      if (mimeType == null) {
        throw new Error(`Mime type is missing for file part`);
      }
      return {
        type: "file",
        data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,
        mimeType,
        providerMetadata: part.experimental_providerMetadata
      };
  }
}
var name54 = "AI_InvalidArgumentError";
var marker54 = `vercel.ai.error.${name54}`;
var symbol54 = Symbol.for(marker54);
var _a54;
var InvalidArgumentError4 = class extends AISDKError3 {
  constructor({
    parameter,
    value: value6,
    message
  }) {
    super({
      name: name54,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a54] = true;
    this.parameter = parameter;
    this.value = value6;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker54);
  }
  static isInvalidArgumentError(error4) {
    return error4 instanceof Error && error4.name === name54 && typeof error4.parameter === "string" && typeof error4.value === "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      parameter: this.parameter,
      value: this.value
    };
  }
};
_a54 = symbol54;
function prepareCallSettings({
  maxTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  stopSequences,
  seed,
  maxRetries
}) {
  if (maxTokens != null) {
    if (!Number.isInteger(maxTokens)) {
      throw new InvalidArgumentError4({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be an integer"
      });
    }
    if (maxTokens < 1) {
      throw new InvalidArgumentError4({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be >= 1"
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError4({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError4({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError4({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError4({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError4({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError4({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
    }
  }
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError4({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError4({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  return {
    maxTokens,
    temperature: temperature != null ? temperature : 0,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : undefined,
    seed,
    maxRetries: maxRetries != null ? maxRetries : 2
  };
}
var jsonValueSchema = exports_external.lazy(() => exports_external.union([
  exports_external.null(),
  exports_external.string(),
  exports_external.number(),
  exports_external.boolean(),
  exports_external.record(exports_external.string(), jsonValueSchema),
  exports_external.array(jsonValueSchema)
]));
var providerMetadataSchema = exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), jsonValueSchema));
var toolResultContentSchema = exports_external.array(exports_external.union([
  exports_external.object({ type: exports_external.literal("text"), text: exports_external.string() }),
  exports_external.object({
    type: exports_external.literal("image"),
    data: exports_external.string(),
    mimeType: exports_external.string().optional()
  })
]));
var textPartSchema = exports_external.object({
  type: exports_external.literal("text"),
  text: exports_external.string(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var imagePartSchema = exports_external.object({
  type: exports_external.literal("image"),
  image: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  mimeType: exports_external.string().optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var filePartSchema = exports_external.object({
  type: exports_external.literal("file"),
  data: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  mimeType: exports_external.string(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolCallPartSchema = exports_external.object({
  type: exports_external.literal("tool-call"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  args: exports_external.unknown()
});
var toolResultPartSchema = exports_external.object({
  type: exports_external.literal("tool-result"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  result: exports_external.unknown(),
  content: toolResultContentSchema.optional(),
  isError: exports_external.boolean().optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreSystemMessageSchema = exports_external.object({
  role: exports_external.literal("system"),
  content: exports_external.string(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreUserMessageSchema = exports_external.object({
  role: exports_external.literal("user"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = exports_external.object({
  role: exports_external.literal("assistant"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([textPartSchema, toolCallPartSchema]))
  ]),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreToolMessageSchema = exports_external.object({
  role: exports_external.literal("tool"),
  content: exports_external.array(toolResultPartSchema),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreMessageSchema = exports_external.union([
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);
function detectPromptType(prompt4) {
  if (!Array.isArray(prompt4)) {
    return "other";
  }
  if (prompt4.length === 0) {
    return "messages";
  }
  const characteristics = prompt4.map(detectSingleMessageCharacteristics);
  if (characteristics.some((c) => c === "has-ui-specific-parts")) {
    return "ui-messages";
  } else if (characteristics.every((c) => c === "has-core-specific-parts" || c === "message")) {
    return "messages";
  } else {
    return "other";
  }
}
function detectSingleMessageCharacteristics(message) {
  if (typeof message === "object" && message !== null && (message.role === "function" || message.role === "data" || ("toolInvocations" in message) || ("experimental_attachments" in message))) {
    return "has-ui-specific-parts";
  } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || ("experimental_providerMetadata" in message))) {
    return "has-core-specific-parts";
  } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && ["system", "user", "assistant", "tool"].includes(message.role)) {
    return "message";
  } else {
    return "other";
  }
}
function attachmentsToParts(attachments) {
  var _a114, _b, _c;
  const parts2 = [];
  for (const attachment of attachments) {
    let url2;
    try {
      url2 = new URL(attachment.url);
    } catch (error4) {
      throw new Error(`Invalid URL: ${attachment.url}`);
    }
    switch (url2.protocol) {
      case "http:":
      case "https:": {
        if ((_a114 = attachment.contentType) == null ? undefined : _a114.startsWith("image/")) {
          parts2.push({ type: "image", image: url2 });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image, it must specify a content type");
          }
          parts2.push({
            type: "file",
            data: url2,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      case "data:": {
        let header;
        let base64Content;
        let mimeType;
        try {
          [header, base64Content] = attachment.url.split(",");
          mimeType = header.split(";")[0].split(":")[1];
        } catch (error4) {
          throw new Error(`Error processing data URL: ${attachment.url}`);
        }
        if (mimeType == null || base64Content == null) {
          throw new Error(`Invalid data URL format: ${attachment.url}`);
        }
        if ((_b = attachment.contentType) == null ? undefined : _b.startsWith("image/")) {
          parts2.push({
            type: "image",
            image: convertDataContentToUint8Array(base64Content)
          });
        } else if ((_c = attachment.contentType) == null ? undefined : _c.startsWith("text/")) {
          parts2.push({
            type: "text",
            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))
          });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image or text, it must specify a content type");
          }
          parts2.push({
            type: "file",
            data: base64Content,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      default: {
        throw new Error(`Unsupported URL protocol: ${url2.protocol}`);
      }
    }
  }
  return parts2;
}
var name64 = "AI_MessageConversionError";
var marker64 = `vercel.ai.error.${name64}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var MessageConversionError = class extends AISDKError3 {
  constructor({
    originalMessage,
    message
  }) {
    super({ name: name64, message });
    this[_a64] = true;
    this.originalMessage = originalMessage;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker64);
  }
};
_a64 = symbol64;
function convertToCoreMessages(messages, options3) {
  var _a114;
  const tools = (_a114 = options3 == null ? undefined : options3.tools) != null ? _a114 : {};
  const coreMessages = [];
  for (const message of messages) {
    const { role, content, toolInvocations, experimental_attachments } = message;
    switch (role) {
      case "system": {
        coreMessages.push({
          role: "system",
          content
        });
        break;
      }
      case "user": {
        coreMessages.push({
          role: "user",
          content: experimental_attachments ? [
            { type: "text", text: content },
            ...attachmentsToParts(experimental_attachments)
          ] : content
        });
        break;
      }
      case "assistant": {
        if (toolInvocations == null) {
          coreMessages.push({ role: "assistant", content });
          break;
        }
        coreMessages.push({
          role: "assistant",
          content: [
            { type: "text", text: content },
            ...toolInvocations.map(({ toolCallId, toolName, args: args2 }) => ({
              type: "tool-call",
              toolCallId,
              toolName,
              args: args2
            }))
          ]
        });
        coreMessages.push({
          role: "tool",
          content: toolInvocations.map((toolInvocation) => {
            if (!("result" in toolInvocation)) {
              throw new MessageConversionError({
                originalMessage: message,
                message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
              });
            }
            const { toolCallId, toolName, result } = toolInvocation;
            const tool2 = tools[toolName];
            return (tool2 == null ? undefined : tool2.experimental_toToolResultContent) != null ? {
              type: "tool-result",
              toolCallId,
              toolName,
              result: tool2.experimental_toToolResultContent(result),
              experimental_content: tool2.experimental_toToolResultContent(result)
            } : {
              type: "tool-result",
              toolCallId,
              toolName,
              result
            };
          })
        });
        break;
      }
      case "function":
      case "data":
      case "tool": {
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new MessageConversionError({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return coreMessages;
}
function standardizePrompt({
  prompt: prompt4,
  tools
}) {
  if (prompt4.prompt == null && prompt4.messages == null) {
    throw new InvalidPromptError({
      prompt: prompt4,
      message: "prompt or messages must be defined"
    });
  }
  if (prompt4.prompt != null && prompt4.messages != null) {
    throw new InvalidPromptError({
      prompt: prompt4,
      message: "prompt and messages cannot be defined at the same time"
    });
  }
  if (prompt4.system != null && typeof prompt4.system !== "string") {
    throw new InvalidPromptError({
      prompt: prompt4,
      message: "system must be a string"
    });
  }
  if (prompt4.prompt != null) {
    if (typeof prompt4.prompt !== "string") {
      throw new InvalidPromptError({
        prompt: prompt4,
        message: "prompt must be a string"
      });
    }
    return {
      type: "prompt",
      system: prompt4.system,
      messages: [
        {
          role: "user",
          content: prompt4.prompt
        }
      ]
    };
  }
  if (prompt4.messages != null) {
    const promptType = detectPromptType(prompt4.messages);
    if (promptType === "other") {
      throw new InvalidPromptError({
        prompt: prompt4,
        message: "messages must be an array of CoreMessage or UIMessage"
      });
    }
    const messages = promptType === "ui-messages" ? convertToCoreMessages(prompt4.messages, {
      tools
    }) : prompt4.messages;
    const validationResult = safeValidateTypes2({
      value: messages,
      schema: exports_external.array(coreMessageSchema)
    });
    if (!validationResult.success) {
      throw new InvalidPromptError({
        prompt: prompt4,
        message: "messages must be an array of CoreMessage or UIMessage",
        cause: validationResult.error
      });
    }
    return {
      type: "messages",
      messages,
      system: prompt4.system
    };
  }
  throw new Error("unreachable");
}
function calculateLanguageModelUsage(usage) {
  return {
    promptTokens: usage.promptTokens,
    completionTokens: usage.completionTokens,
    totalTokens: usage.promptTokens + usage.completionTokens
  };
}
function prepareResponseHeaders(init, {
  contentType,
  dataStreamVersion
}) {
  var _a114;
  const headers = new Headers((_a114 = init == null ? undefined : init.headers) != null ? _a114 : {});
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", contentType);
  }
  if (dataStreamVersion !== undefined) {
    headers.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return headers;
}
var name74 = "AI_NoObjectGeneratedError";
var marker74 = `vercel.ai.error.${name74}`;
var symbol74 = Symbol.for(marker74);
var _a74;
_a74 = symbol74;
var originalGenerateId = createIdGenerator3({ prefix: "aiobj", size: 24 });
var originalGenerateId2 = createIdGenerator3({ prefix: "aiobj", size: 24 });
var name84 = "AI_InvalidToolArgumentsError";
var marker84 = `vercel.ai.error.${name84}`;
var symbol84 = Symbol.for(marker84);
var _a84;
var InvalidToolArgumentsError = class extends AISDKError3 {
  constructor({
    toolArgs,
    toolName,
    cause: cause2,
    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage4(cause2)}`
  }) {
    super({ name: name84, message, cause: cause2 });
    this[_a84] = true;
    this.toolArgs = toolArgs;
    this.toolName = toolName;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker84);
  }
  static isInvalidToolArgumentsError(error4) {
    return error4 instanceof Error && error4.name === name84 && typeof error4.toolName === "string" && typeof error4.toolArgs === "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      cause: this.cause,
      stack: this.stack,
      toolName: this.toolName,
      toolArgs: this.toolArgs
    };
  }
};
_a84 = symbol84;
var name94 = "AI_NoSuchToolError";
var marker94 = `vercel.ai.error.${name94}`;
var symbol94 = Symbol.for(marker94);
var _a94;
var NoSuchToolError = class extends AISDKError3 {
  constructor({
    toolName,
    availableTools = undefined,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === undefined ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
  }) {
    super({ name: name94, message });
    this[_a94] = true;
    this.toolName = toolName;
    this.availableTools = availableTools;
  }
  static isInstance(error4) {
    return AISDKError3.hasMarker(error4, marker94);
  }
  static isNoSuchToolError(error4) {
    return error4 instanceof Error && error4.name === name94 && "toolName" in error4 && error4.toolName != null && typeof error4.name === "string";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      toolName: this.toolName,
      availableTools: this.availableTools
    };
  }
};
_a94 = symbol94;
function isNonEmptyObject(object2) {
  return object2 != null && Object.keys(object2).length > 0;
}
function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools)) {
    return {
      tools: undefined,
      toolChoice: undefined
    };
  }
  const filteredTools = activeTools != null ? Object.entries(tools).filter(([name114]) => activeTools.includes(name114)) : Object.entries(tools);
  return {
    tools: filteredTools.map(([name114, tool2]) => {
      const toolType = tool2.type;
      switch (toolType) {
        case undefined:
        case "function":
          return {
            type: "function",
            name: name114,
            description: tool2.description,
            parameters: asSchema2(tool2.parameters).jsonSchema
          };
        case "provider-defined":
          return {
            type: "provider-defined",
            name: name114,
            id: tool2.id,
            args: tool2.args
          };
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    }),
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}
var lastWhitespaceRegexp = /^([\s\S]*?)(\s+)(\S*)$/;
function splitOnLastWhitespace(text11) {
  const match21 = text11.match(lastWhitespaceRegexp);
  return match21 ? { prefix: match21[1], whitespace: match21[2], suffix: match21[3] } : undefined;
}
function removeTextAfterLastWhitespace(text11) {
  const match21 = splitOnLastWhitespace(text11);
  return match21 ? match21.prefix + match21.whitespace : text11;
}
function parseToolCall({
  toolCall,
  tools
}) {
  const toolName = toolCall.toolName;
  if (tools == null) {
    throw new NoSuchToolError({ toolName: toolCall.toolName });
  }
  const tool2 = tools[toolName];
  if (tool2 == null) {
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  const schema = asSchema2(tool2.parameters);
  const parseResult = toolCall.args.trim() === "" ? safeValidateTypes2({ value: {}, schema }) : safeParseJSON2({ text: toolCall.args, schema });
  if (parseResult.success === false) {
    throw new InvalidToolArgumentsError({
      toolName,
      toolArgs: toolCall.args,
      cause: parseResult.error
    });
  }
  return {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    args: parseResult.value
  };
}
function toResponseMessages({
  text: text11 = "",
  tools,
  toolCalls,
  toolResults
}) {
  const responseMessages = [];
  responseMessages.push({
    role: "assistant",
    content: [{ type: "text", text: text11 }, ...toolCalls]
  });
  if (toolResults.length > 0) {
    responseMessages.push({
      role: "tool",
      content: toolResults.map((toolResult) => {
        const tool2 = tools[toolResult.toolName];
        return (tool2 == null ? undefined : tool2.experimental_toToolResultContent) != null ? {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: tool2.experimental_toToolResultContent(toolResult.result),
          experimental_content: tool2.experimental_toToolResultContent(toolResult.result)
        } : {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: toolResult.result
        };
      })
    });
  }
  return responseMessages;
}
var originalGenerateId3 = createIdGenerator3({ prefix: "aitxt", size: 24 });
async function generateText({
  model,
  tools,
  toolChoice,
  system,
  prompt: prompt4,
  messages,
  maxRetries,
  abortSignal,
  headers,
  maxAutomaticRoundtrips = 0,
  maxToolRoundtrips = maxAutomaticRoundtrips,
  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,
  experimental_continuationSteps,
  experimental_continueSteps: continueSteps = experimental_continuationSteps != null ? experimental_continuationSteps : false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata: providerMetadata,
  experimental_activeTools: activeTools,
  _internal: {
    generateId: generateId32 = originalGenerateId3,
    currentDate = () => /* @__PURE__ */ new Date
  } = {},
  onStepFinish,
  ...settings
}) {
  if (maxSteps < 1) {
    throw new InvalidArgumentError4({
      parameter: "maxSteps",
      value: maxSteps,
      message: "maxSteps must be at least 1"
    });
  }
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { ...settings, maxRetries }
  });
  const initialPrompt = standardizePrompt({
    prompt: { system, prompt: prompt4, messages },
    tools
  });
  const tracer2 = getTracer(telemetry);
  return recordSpan({
    name: "ai.generateText",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.generateText",
          telemetry
        }),
        ...baseTelemetryAttributes,
        "ai.prompt": {
          input: () => JSON.stringify({ system, prompt: prompt4, messages })
        },
        "ai.settings.maxSteps": maxSteps
      }
    }),
    tracer: tracer2,
    fn: async (span3) => {
      var _a114, _b, _c, _d, _e, _f;
      const retry6 = retryWithExponentialBackoff({ maxRetries });
      const mode = {
        type: "regular",
        ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools })
      };
      const callSettings = prepareCallSettings(settings);
      let currentModelResponse;
      let currentToolCalls = [];
      let currentToolResults = [];
      let stepCount = 0;
      const responseMessages = [];
      let text11 = "";
      const steps = [];
      const usage = {
        completionTokens: 0,
        promptTokens: 0,
        totalTokens: 0
      };
      let stepType = "initial";
      do {
        if (stepCount === 1) {
          initialPrompt.type = "messages";
        }
        const promptFormat = stepCount === 0 ? initialPrompt.type : "messages";
        const promptMessages = await convertToLanguageModelPrompt({
          prompt: {
            type: promptFormat,
            system: initialPrompt.system,
            messages: [...initialPrompt.messages, ...responseMessages]
          },
          modelSupportsImageUrls: model.supportsImageUrls,
          modelSupportsUrl: model.supportsUrl
        });
        currentModelResponse = await retry6(() => recordSpan({
          name: "ai.generateText.doGenerate",
          attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
              ...assembleOperationName({
                operationId: "ai.generateText.doGenerate",
                telemetry
              }),
              ...baseTelemetryAttributes,
              "ai.prompt.format": { input: () => promptFormat },
              "ai.prompt.messages": {
                input: () => JSON.stringify(promptMessages)
              },
              "ai.prompt.tools": {
                input: () => {
                  var _a124;
                  return (_a124 = mode.tools) == null ? undefined : _a124.map((tool2) => JSON.stringify(tool2));
                }
              },
              "ai.prompt.toolChoice": {
                input: () => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : undefined
              },
              "gen_ai.system": model.provider,
              "gen_ai.request.model": model.modelId,
              "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
              "gen_ai.request.max_tokens": settings.maxTokens,
              "gen_ai.request.presence_penalty": settings.presencePenalty,
              "gen_ai.request.stop_sequences": settings.stopSequences,
              "gen_ai.request.temperature": settings.temperature,
              "gen_ai.request.top_k": settings.topK,
              "gen_ai.request.top_p": settings.topP
            }
          }),
          tracer: tracer2,
          fn: async (span22) => {
            var _a124, _b2, _c2, _d2, _e2, _f2;
            const result = await model.doGenerate({
              mode,
              ...callSettings,
              inputFormat: promptFormat,
              prompt: promptMessages,
              providerMetadata,
              abortSignal,
              headers
            });
            const responseData = {
              id: (_b2 = (_a124 = result.response) == null ? undefined : _a124.id) != null ? _b2 : generateId32(),
              timestamp: (_d2 = (_c2 = result.response) == null ? undefined : _c2.timestamp) != null ? _d2 : currentDate(),
              modelId: (_f2 = (_e2 = result.response) == null ? undefined : _e2.modelId) != null ? _f2 : model.modelId
            };
            span22.setAttributes(selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": result.finishReason,
                "ai.response.text": {
                  output: () => result.text
                },
                "ai.response.toolCalls": {
                  output: () => JSON.stringify(result.toolCalls)
                },
                "ai.response.id": responseData.id,
                "ai.response.model": responseData.modelId,
                "ai.response.timestamp": responseData.timestamp.toISOString(),
                "ai.usage.promptTokens": result.usage.promptTokens,
                "ai.usage.completionTokens": result.usage.completionTokens,
                "ai.finishReason": result.finishReason,
                "ai.result.text": {
                  output: () => result.text
                },
                "ai.result.toolCalls": {
                  output: () => JSON.stringify(result.toolCalls)
                },
                "gen_ai.response.finish_reasons": [result.finishReason],
                "gen_ai.response.id": responseData.id,
                "gen_ai.response.model": responseData.modelId,
                "gen_ai.usage.input_tokens": result.usage.promptTokens,
                "gen_ai.usage.output_tokens": result.usage.completionTokens
              }
            }));
            return { ...result, response: responseData };
          }
        }));
        currentToolCalls = ((_a114 = currentModelResponse.toolCalls) != null ? _a114 : []).map((modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools }));
        currentToolResults = tools == null ? [] : await executeTools({
          toolCalls: currentToolCalls,
          tools,
          tracer: tracer2,
          telemetry,
          abortSignal
        });
        const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);
        usage.completionTokens += currentUsage.completionTokens;
        usage.promptTokens += currentUsage.promptTokens;
        usage.totalTokens += currentUsage.totalTokens;
        let nextStepType = "done";
        if (++stepCount < maxSteps) {
          if (continueSteps && currentModelResponse.finishReason === "length" && currentToolCalls.length === 0) {
            nextStepType = "continue";
          } else if (currentToolCalls.length > 0 && currentToolResults.length === currentToolCalls.length) {
            nextStepType = "tool-result";
          }
        }
        const originalText = (_b = currentModelResponse.text) != null ? _b : "";
        const stepTextLeadingWhitespaceTrimmed = stepType === "continue" && text11.trimEnd() !== text11 ? originalText.trimStart() : originalText;
        const stepText = nextStepType === "continue" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;
        text11 = nextStepType === "continue" || stepType === "continue" ? text11 + stepText : stepText;
        if (stepType === "continue") {
          const lastMessage = responseMessages[responseMessages.length - 1];
          if (typeof lastMessage.content === "string") {
            lastMessage.content += stepText;
          } else {
            lastMessage.content.push({
              text: stepText,
              type: "text"
            });
          }
        } else {
          responseMessages.push(...toResponseMessages({
            text: text11,
            tools: tools != null ? tools : {},
            toolCalls: currentToolCalls,
            toolResults: currentToolResults
          }));
        }
        const currentStepResult = {
          stepType,
          text: stepText,
          toolCalls: currentToolCalls,
          toolResults: currentToolResults,
          finishReason: currentModelResponse.finishReason,
          usage: currentUsage,
          warnings: currentModelResponse.warnings,
          logprobs: currentModelResponse.logprobs,
          request: (_c = currentModelResponse.request) != null ? _c : {},
          response: {
            ...currentModelResponse.response,
            headers: (_d = currentModelResponse.rawResponse) == null ? undefined : _d.headers,
            messages: JSON.parse(JSON.stringify(responseMessages))
          },
          experimental_providerMetadata: currentModelResponse.providerMetadata,
          isContinued: nextStepType === "continue"
        };
        steps.push(currentStepResult);
        await (onStepFinish == null ? undefined : onStepFinish(currentStepResult));
        stepType = nextStepType;
      } while (stepType !== "done");
      span3.setAttributes(selectTelemetryAttributes({
        telemetry,
        attributes: {
          "ai.response.finishReason": currentModelResponse.finishReason,
          "ai.response.text": {
            output: () => currentModelResponse.text
          },
          "ai.response.toolCalls": {
            output: () => JSON.stringify(currentModelResponse.toolCalls)
          },
          "ai.usage.promptTokens": currentModelResponse.usage.promptTokens,
          "ai.usage.completionTokens": currentModelResponse.usage.completionTokens,
          "ai.finishReason": currentModelResponse.finishReason,
          "ai.result.text": {
            output: () => currentModelResponse.text
          },
          "ai.result.toolCalls": {
            output: () => JSON.stringify(currentModelResponse.toolCalls)
          }
        }
      }));
      return new DefaultGenerateTextResult({
        text: text11,
        toolCalls: currentToolCalls,
        toolResults: currentToolResults,
        finishReason: currentModelResponse.finishReason,
        usage,
        warnings: currentModelResponse.warnings,
        request: (_e = currentModelResponse.request) != null ? _e : {},
        response: {
          ...currentModelResponse.response,
          headers: (_f = currentModelResponse.rawResponse) == null ? undefined : _f.headers,
          messages: responseMessages
        },
        logprobs: currentModelResponse.logprobs,
        responseMessages,
        steps,
        providerMetadata: currentModelResponse.providerMetadata
      });
    }
  });
}
async function executeTools({
  toolCalls,
  tools,
  tracer: tracer2,
  telemetry,
  abortSignal
}) {
  const toolResults = await Promise.all(toolCalls.map(async (toolCall) => {
    const tool2 = tools[toolCall.toolName];
    if ((tool2 == null ? undefined : tool2.execute) == null) {
      return;
    }
    const result = await recordSpan({
      name: "ai.toolCall",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.toolCall",
            telemetry
          }),
          "ai.toolCall.name": toolCall.toolName,
          "ai.toolCall.id": toolCall.toolCallId,
          "ai.toolCall.args": {
            output: () => JSON.stringify(toolCall.args)
          }
        }
      }),
      tracer: tracer2,
      fn: async (span3) => {
        const result2 = await tool2.execute(toolCall.args, { abortSignal });
        try {
          span3.setAttributes(selectTelemetryAttributes({
            telemetry,
            attributes: {
              "ai.toolCall.result": {
                output: () => JSON.stringify(result2)
              }
            }
          }));
        } catch (ignored) {}
        return result2;
      }
    });
    return {
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      args: toolCall.args,
      result
    };
  }));
  return toolResults.filter((result) => result != null);
}
var DefaultGenerateTextResult = class {
  constructor(options3) {
    this.text = options3.text;
    this.toolCalls = options3.toolCalls;
    this.toolResults = options3.toolResults;
    this.finishReason = options3.finishReason;
    this.usage = options3.usage;
    this.warnings = options3.warnings;
    this.request = options3.request;
    this.response = options3.response;
    this.responseMessages = options3.responseMessages;
    this.roundtrips = options3.steps;
    this.steps = options3.steps;
    this.experimental_providerMetadata = options3.providerMetadata;
    this.rawResponse = {
      headers: options3.response.headers
    };
    this.logprobs = options3.logprobs;
  }
};
function mergeStreams(stream1, stream22) {
  const reader1 = stream1.getReader();
  const reader2 = stream22.getReader();
  let lastRead1 = undefined;
  let lastRead2 = undefined;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = undefined;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error4) {
      controller.error(error4);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = undefined;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error4) {
      controller.error(error4);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = undefined;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = undefined;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error4) {
        controller.error(error4);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
var originalGenerateId4 = createIdGenerator3({ prefix: "aitxt", size: 24 });
var name104 = "AI_NoSuchProviderError";
var marker104 = `vercel.ai.error.${name104}`;
var symbol104 = Symbol.for(marker104);
var _a104;
_a104 = symbol104;
function createCallbacksTransformer(cb) {
  const textEncoder = new TextEncoder;
  let aggregatedResponse = "";
  const callbacks = cb || {};
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      const content = typeof message === "string" ? message : message.content;
      controller.enqueue(textEncoder.encode(content));
      aggregatedResponse += content;
      if (callbacks.onToken)
        await callbacks.onToken(content);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal && !isOpenAICallbacks) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}
function isOfTypeOpenAIStreamCallbacks(callbacks) {
  return "experimental_onFunctionCall" in callbacks;
}
function trimStartOfStreamHelper() {
  let isStreamStart = true;
  return (text11) => {
    if (isStreamStart) {
      text11 = text11.trimStart();
      if (text11)
        isStreamStart = false;
    }
    return text11;
  };
}
var HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;
function createStreamDataTransformer() {
  const encoder2 = new TextEncoder;
  const decoder2 = new TextDecoder;
  return new TransformStream({
    transform: async (chunk4, controller) => {
      const message = decoder2.decode(chunk4);
      controller.enqueue(encoder2.encode(formatStreamPart("text", message)));
    }
  });
}
var utf8Decoder = new TextDecoder("utf-8");
var langchain_adapter_exports = {};
__export2(langchain_adapter_exports, {
  toAIStream: () => toAIStream,
  toDataStream: () => toDataStream,
  toDataStreamResponse: () => toDataStreamResponse
});
function toAIStream(stream3, callbacks) {
  return toDataStream(stream3, callbacks);
}
function toDataStream(stream3, callbacks) {
  return stream3.pipeThrough(new TransformStream({
    transform: async (value6, controller) => {
      var _a114;
      if (typeof value6 === "string") {
        controller.enqueue(value6);
        return;
      }
      if ("event" in value6) {
        if (value6.event === "on_chat_model_stream") {
          forwardAIMessageChunk((_a114 = value6.data) == null ? undefined : _a114.chunk, controller);
        }
        return;
      }
      forwardAIMessageChunk(value6, controller);
    }
  })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());
}
function toDataStreamResponse(stream3, options3) {
  var _a114;
  const dataStream = toDataStream(stream3, options3 == null ? undefined : options3.callbacks);
  const data = options3 == null ? undefined : options3.data;
  const init = options3 == null ? undefined : options3.init;
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a114 = init == null ? undefined : init.status) != null ? _a114 : 200,
    statusText: init == null ? undefined : init.statusText,
    headers: prepareResponseHeaders(init, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function forwardAIMessageChunk(chunk4, controller) {
  if (typeof chunk4.content === "string") {
    controller.enqueue(chunk4.content);
  } else {
    const content = chunk4.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}
var llamaindex_adapter_exports = {};
__export2(llamaindex_adapter_exports, {
  toDataStream: () => toDataStream2,
  toDataStreamResponse: () => toDataStreamResponse2
});
function toDataStream2(stream3, callbacks) {
  return toReadableStream2(stream3).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());
}
function toDataStreamResponse2(stream3, options3 = {}) {
  var _a114;
  const { init, data, callbacks } = options3;
  const dataStream = toDataStream2(stream3, callbacks);
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a114 = init == null ? undefined : init.status) != null ? _a114 : 200,
    statusText: init == null ? undefined : init.statusText,
    headers: prepareResponseHeaders(init, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function toReadableStream2(res) {
  const it = res[Symbol.asyncIterator]();
  const trimStartOfStream = trimStartOfStreamHelper();
  return new ReadableStream({
    async pull(controller) {
      var _a114;
      const { value: value6, done: done11 } = await it.next();
      if (done11) {
        controller.close();
        return;
      }
      const text11 = trimStartOfStream((_a114 = value6.delta) != null ? _a114 : "");
      if (text11) {
        controller.enqueue(text11);
      }
    }
  });
}
var __internal__OpenAIFnMessagesSymbol = Symbol("internal_openai_fn_messages");

// src/lib/ai.ts
class OpenAI extends Service()("OpenAI", {
  succeed: {}
}) {
}
var OpenAIProviderLayer = effect(OpenAI, suspend3(() => {
  const apiKey = process.env["GOOGLE_AI_API_KEY"];
  if (!apiKey) {
    return fail8(new Error("Missing GOOGLE_AI_API_KEY environment variable"));
  }
  const google2 = createGoogleGenerativeAI({ apiKey });
  const model = google2("models/gemini-2.5-flash");
  return succeed8({
    generateResourceJson: ({ prompt: prompt4, resourceBlock, verbose }) => pipe(tryPromise2({
      try: async () => {
        const { text: text11 } = await generateText({
          model,
          system: prompt4,
          prompt: [
            "Return ONLY a strict JSON object. No prose. No code fences.",
            "Validate allowed values per instructions.",
            "Respond in English.",
            "",
            resourceBlock
          ].join(`
`)
        });
        return text11.trim();
      },
      catch: (e) => new Error(`AI call failed: ${String(e)}`)
    }), tap2(() => verbose ? log3(`AI response received`) : _void)),
    generateSourceEntityJson: ({ prompt: prompt4, sourceBlock, verbose }) => pipe(tryPromise2({
      try: async () => {
        const { text: text11 } = await generateText({
          model,
          system: prompt4,
          prompt: [
            "Return ONLY a strict JSON object. No prose. No code fences.",
            "Validate allowed values per instructions.",
            "Respond in English.",
            "",
            sourceBlock
          ].join(`
`)
        });
        return text11.trim();
      },
      catch: (e) => new Error(`AI call failed: ${String(e)}`)
    }), tap2(() => verbose ? log3(`AI response received`) : _void))
  });
}));

// src/lib/notion.ts
var import_client = __toESM(require_src2(), 1);

// src/lib/schema.ts
function buildSchema() {
  const FocusArea = exports_external.enum([
    "Human-Centric",
    "Tech-Centric",
    "Collaboration",
    "Coding",
    "Business of AI"
  ]);
  const ResourceType = exports_external.enum([
    "Video",
    "Article",
    "Book",
    "Paper",
    "Tool",
    "Podcast",
    "Course"
  ]);
  const Tag4 = exports_external.enum([
    "LLMs",
    "Neural Networks",
    "Transformers",
    "Generative AI",
    "Concepts",
    "AI Ethics",
    "Prompt Engineering",
    "Context Engineering",
    "AI Agents",
    "LangChain",
    "LangGraph",
    "Vercel AI SDK",
    "RAG",
    "Fine-tuning",
    "Training",
    "Deployment",
    "AI Infrastructure",
    "APIs",
    "TypeScript",
    "Effect-TS",
    "Functional Programming",
    "Concurrency",
    "Error Handling",
    "Type Safety",
    "System Design",
    "Architecture",
    "Testing",
    "Frontend",
    "Backend",
    "JavaScript",
    "Next.js",
    "Systems Thinking",
    "Collaboration",
    "Productivity",
    "Startup",
    "Product Management",
    "Strategy",
    "Innovation",
    "Business Models"
  ]);
  return exports_external.object({
    resource_name: exports_external.string().min(1),
    resource_url: exports_external.string().url(),
    resource_type: ResourceType,
    curator_note: exports_external.string().min(1),
    focus_area: exports_external.array(FocusArea),
    tags: exports_external.array(Tag4).optional().default([]),
    source_entity_name: exports_external.string().nullable().optional(),
    read_time_minutes: exports_external.number().int().nullable().optional(),
    icon_name: exports_external.string().nullable().optional(),
    resource_series_name: exports_external.string().nullable().optional(),
    resource_series_part_number: exports_external.number().int().nullable().optional()
  });
}

// src/lib/notion.ts
var schema = buildSchema();

class Notion extends Service()("Notion", {
  succeed: {}
}) {
}
var { addResource } = serviceFunctions2(Notion);
function mapResourceToProperties(input) {
  return {
    Name: {
      title: [{ type: "text", text: { content: input.resource_name } }]
    },
    "Resource URL": { url: input.resource_url },
    Type: { select: { name: input.resource_type } },
    Icon: input.icon_name ? { rich_text: [{ type: "text", text: { content: input.icon_name } }] } : undefined,
    "Curator's Note": input.curator_note ? { rich_text: [{ type: "text", text: { content: input.curator_note } }] } : undefined,
    "Focus Area": {
      multi_select: input.focus_area.map((name15) => ({ name: name15 }))
    },
    Tags: input.tags?.length ? { multi_select: input.tags.map((name15) => ({ name: name15 })) } : { multi_select: [] },
    "Read Time (min)": typeof input.read_time_minutes === "number" ? { number: input.read_time_minutes } : undefined,
    Series: input.resource_series_name ? {
      rich_text: [
        { type: "text", text: { content: input.resource_series_name } }
      ]
    } : undefined,
    "Source Entity": input.source_entity_name ? {
      rich_text: [
        { type: "text", text: { content: input.source_entity_name } }
      ]
    } : undefined
  };
}
function mapSourceEntityToProperties(input) {
  return {
    Name: {
      title: [{ type: "text", text: { content: input.name } }]
    },
    Type: { select: { name: input.type } },
    URL: input.url ? { url: input.url } : undefined,
    Description: input.description ? { rich_text: [{ type: "text", text: { content: input.description } }] } : undefined,
    "Paul's Endorsement": input.endorsement ? { rich_text: [{ type: "text", text: { content: input.endorsement } }] } : undefined,
    "Focus Area": {
      multi_select: input.focus_area.map((name15) => ({ name: name15 }))
    }
  };
}
async function validateSelectOptions(notion, databaseId, input) {
  const db = await notion.databases.retrieve({
    database_id: databaseId
  });
  const typeProp = db.properties["Type"];
  const focusProp = db.properties["Focus Area"];
  const tagsProp = db.properties["Tags"];
  const ensureAllowed = (prop, values4, propName) => {
    if (!prop || prop.type !== "select" && prop.type !== "multi_select")
      return;
    const options3 = prop.type === "select" ? prop.select.options : prop.multi_select.options;
    const allowed = new Set(options3.map((o) => o.name));
    for (const v of values4) {
      if (!allowed.has(v)) {
        throw new Error(`Value '${v}' is not an allowed option for ${propName}. Please add it manually in Notion.`);
      }
    }
  };
  ensureAllowed(typeProp, [input.resource_type], "Type");
  ensureAllowed(focusProp, input.focus_area, "Focus Area");
  ensureAllowed(tagsProp, input.tags ?? [], "Tags");
}
var NotionClientLayer = effect(Notion, suspend3(() => {
  const apiKey = process.env["NOTION_API_KEY"];
  const databaseId = process.env["NOTION_RESOURCES_DATABASE_ID"];
  const sourceEntitiesDatabaseId = process.env["NOTION_SOURCE_ENTITIES_DATABASE_ID"];
  const resourceSeriesDatabaseId = process.env["NOTION_RESOURCE_SERIES_DATABASE_ID"];
  if (!apiKey)
    return fail8(new Error("Missing NOTION_API_KEY"));
  if (!databaseId)
    return fail8(new Error("Missing NOTION_RESOURCES_DATABASE_ID"));
  if (!sourceEntitiesDatabaseId)
    return fail8(new Error("Missing NOTION_SOURCE_ENTITIES_DATABASE_ID"));
  const notion = new import_client.Client({ auth: apiKey });
  return succeed8({
    addResource: (input, opts) => pipe(tryPromise2({
      try: async () => {
        await validateSelectOptions(notion, databaseId, input);
        const properties = mapResourceToProperties(input);
        const page = await notion.pages.create({
          parent: { database_id: databaseId },
          properties
        });
        return {
          pageId: page.id,
          url: page.url
        };
      },
      catch: (e) => new Error(`Notion API error: ${String(e)}`)
    }), tap2(() => opts?.verbose ? log3("Notion page created") : _void)),
    addSourceEntity: (input, opts) => pipe(tryPromise2({
      try: async () => {
        const db = await notion.databases.retrieve({
          database_id: sourceEntitiesDatabaseId
        });
        const typeProp = db.properties["Type"];
        const focusProp = db.properties["Focus Area"];
        const ensureAllowed = (prop, values4, propName) => {
          if (!prop || prop.type !== "select" && prop.type !== "multi_select")
            return;
          const options3 = prop.type === "select" ? prop.select.options : prop.multi_select.options;
          const allowed = new Set(options3.map((o) => o.name));
          for (const v of values4) {
            if (!allowed.has(v)) {
              throw new Error(`Value '${v}' is not an allowed option for ${propName}. Please add it manually in Notion.`);
            }
          }
        };
        if (typeProp)
          ensureAllowed(typeProp, [input.type], "Type");
        if (focusProp)
          ensureAllowed(focusProp, input.focus_area, "Focus Area");
        const properties = mapSourceEntityToProperties(input);
        const page = await notion.pages.create({
          parent: { database_id: sourceEntitiesDatabaseId },
          properties
        });
        return {
          pageId: page.id,
          url: page.url
        };
      },
      catch: (e) => new Error(`Notion API error: ${String(e)}`)
    }), tap2(() => opts?.verbose ? log3("Notion source entity page created") : _void)),
    listResources: (opts) => tryPromise2({
      try: async () => {
        const res = await notion.databases.query({
          database_id: databaseId,
          page_size: Math.min(Math.max(opts?.limit ?? 25, 1), 100)
        });
        return res.results.map((p3) => {
          const props = p3.properties ?? {};
          const name15 = props["Name"]?.title?.[0]?.plain_text?.trim?.() ?? "";
          const type2 = props["Type"]?.select?.name ?? null;
          const sourceEntityName = props["Source Entity"]?.rich_text?.[0]?.plain_text ?? null;
          const url2 = p3.url;
          return {
            id: p3.id,
            url: url2,
            name: name15,
            type: type2,
            sourceEntityName
          };
        });
      },
      catch: (e) => new Error(`Notion API error: ${String(e)}`)
    }),
    listSourceEntities: (opts) => tryPromise2({
      try: async () => {
        const res = await notion.databases.query({
          database_id: sourceEntitiesDatabaseId,
          page_size: Math.min(Math.max(opts?.limit ?? 25, 1), 100)
        });
        return res.results.map((p3) => {
          const props = p3.properties ?? {};
          const name15 = props["Name"]?.title?.[0]?.plain_text?.trim?.() ?? "";
          const type2 = props["Type"]?.select?.name ?? null;
          const url2 = p3.url;
          return { id: p3.id, url: url2, name: name15, type: type2 };
        });
      },
      catch: (e) => new Error(`Notion API error: ${String(e)}`)
    }),
    listResourceSeries: (opts) => tryPromise2({
      try: async () => {
        if (!resourceSeriesDatabaseId)
          throw new Error("Missing NOTION_RESOURCE_SERIES_DATABASE_ID");
        const res = await notion.databases.query({
          database_id: resourceSeriesDatabaseId,
          page_size: Math.min(Math.max(opts?.limit ?? 25, 1), 100)
        });
        return res.results.map((p3) => {
          const props = p3.properties ?? {};
          const name15 = props["Name"]?.title?.[0]?.plain_text?.trim?.() ?? "";
          const url2 = p3.url;
          return { id: p3.id, url: url2, name: name15 };
        });
      },
      catch: (e) => new Error(`Notion API error: ${String(e)}`)
    })
  });
}));

// src/lib/web.ts
function extractMeta(html, name15) {
  const re = new RegExp(`<meta[^>]+(?:name|property)=["']${name15}["'][^>]+content=["']([^"']+)["'][^>]*>`, "i");
  const m = html.match(re);
  return m?.[1] ?? null;
}
function extractTitle(html) {
  const m = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  return m?.[1]?.trim() ?? null;
}
function fetchPageMetadata(url2) {
  return tryPromise2({
    try: async () => {
      const res = await fetch(url2, { redirect: "follow" });
      const html = await res.text();
      const title = extractTitle(html) ?? extractMeta(html, "og:title");
      const description = extractMeta(html, "og:description") || extractMeta(html, "description");
      return { title, description };
    },
    catch: (e) => new Error(`Failed to fetch metadata: ${String(e)}`)
  });
}

// src/commands/addResource.ts
var verboseOption = boolean6("verbose").pipe(withAlias2("v"), withDescription3("Enable verbose output"));
var resourceCommand = pipe(make68("resource", {
  args: pipe(text10(), withDescription8("URL of the resource to add")),
  options: all9({ verbose: verboseOption })
}), withDescription7("Add a single resource by URL"), withHandler2(({ args: args2, options: options3 }) => handler(args2, Boolean(options3.verbose))));
var addResourceCommand = pipe(make68("add"), withDescription7("Add resources to Notion"), withSubcommands3([resourceCommand]));
function handler(resourceUrl, isVerbose) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const ai = yield* OpenAI;
    const notion = yield* Notion;
    if (isVerbose) {
      yield* log3("Reading prompt from prompts/addResources.txt");
    }
    const prompt4 = yield* fs.readFileString("prompts/addResources.txt");
    const meta = yield* fetchPageMetadata(resourceUrl);
    const resourceBlock = [
      `Resource Title: "${meta.title ?? ""}"`,
      `Resource URL: "${resourceUrl}"`,
      `Automatically fetched short description: "${meta.description ?? ""}"`
    ].join(`
`);
    const aiJson = yield* ai.generateResourceJson({
      prompt: prompt4,
      resourceBlock,
      verbose: isVerbose
    });
    const schema2 = buildSchema();
    const validated = yield* try_2({
      try: () => schema2.parse(JSON.parse(aiJson)),
      catch: (e) => new Error(`Validation failed: ${e}`)
    });
    const res = yield* notion.addResource(validated, { verbose: isVerbose });
    yield* log3(`Success: Created Notion page ${res.pageId}${res.url ? ` at ${res.url}` : ""}`);
  }).pipe(catchAll2((err) => error2(`Error: ${String(err)}`)));
}

// src/lib/sourceEntitySchema.ts
function buildSourceEntitySchema() {
  const SourceType = exports_external.enum([
    "Individual",
    "YouTube Channel",
    "Company",
    "Open Source Project",
    "Community",
    "Publication",
    "Podcast",
    "University"
  ]);
  const FocusArea = exports_external.enum([
    "Human-Centric",
    "Tech-Centric",
    "Collaboration",
    "Coding",
    "Business of AI"
  ]);
  return exports_external.object({
    name: exports_external.string().min(1),
    type: SourceType,
    url: exports_external.string().url().nullable().optional(),
    description: exports_external.string().min(1),
    endorsement: exports_external.string().min(1),
    focus_area: exports_external.array(FocusArea).nonempty()
  });
}

// src/commands/addSource.ts
var verboseOption2 = boolean6("verbose").pipe(withAlias2("v"), withDescription3("Enable verbose output"));
var urlOption = text8("url").pipe(withAlias2("u"), optional3, withDescription3("Optional URL for the source entity"));
var sourceCommand = pipe(make68("source", {
  args: text10().pipe(withDescription8("Source name (e.g., YouTube channel, author, company)")),
  options: all9({ verbose: verboseOption2, url: urlOption })
}), withDescription7("Add a source entity to Notion"), withHandler2(({ args: args2, options: options3 }) => handler2(args2, match2(options3.url, { onNone: () => null, onSome: (v) => v }), Boolean(options3.verbose))));
function handler2(sourceName, sourceUrl, isVerbose) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const ai = yield* OpenAI;
    const notion = yield* Notion;
    if (isVerbose) {
      yield* log3("Reading prompt from prompts/addSourceEntity.txt");
    }
    const prompt4 = yield* fs.readFileString("prompts/addSourceEntity.txt");
    const sourceBlock = [
      `Source Name: "${sourceName}"`,
      `Source URL: "${sourceUrl ?? ""}"`
    ].join(`
`);
    const aiJson = yield* ai.generateSourceEntityJson({
      prompt: prompt4,
      sourceBlock,
      verbose: isVerbose
    });
    const schema2 = buildSourceEntitySchema();
    const validated = yield* try_2({
      try: () => schema2.parse(JSON.parse(aiJson)),
      catch: (e) => new Error(`Validation failed: ${e}`)
    });
    const res = yield* notion.addSourceEntity(validated, {
      verbose: isVerbose
    });
    yield* log3(`Success: Created Source Entity page ${res.pageId}${res.url ? ` at ${res.url}` : ""}`);
  }).pipe(catchAll2((err) => error2(`Error: ${String(err)}`)));
}

// src/commands/list.ts
var limitOption = integer5("limit").pipe(withAlias2("n"), optional3, withDescription3("Max rows to list (default 25, max 100)"));
var listResourcesCommand = pipe(make68("resources", { options: all9({ limit: limitOption }) }), withDescription7("List recent resources"), withHandler2(({ options: options3 }) => listResources(getOrUndefined(options3.limit))));
var listSourcesCommand = pipe(make68("sources", { options: all9({ limit: limitOption }) }), withDescription7("List source entities"), withHandler2(({ options: options3 }) => listSources(getOrUndefined(options3.limit))));
var listSeriesCommand = pipe(make68("series", { options: all9({ limit: limitOption }) }), withDescription7("List resource series"), withHandler2(({ options: options3 }) => listSeries(getOrUndefined(options3.limit))));
var listCommand = pipe(make68("list"), withDescription7("List data from Notion tables"), withSubcommands3([
  listResourcesCommand,
  listSourcesCommand,
  listSeriesCommand
]));
var listResourcesTop = pipe(make68("list-resources", {
  options: all9({ limit: limitOption })
}), withDescription7("List recent resources"), withHandler2(({ options: options3 }) => listResources(getOrUndefined(options3.limit))));
var listSourcesTop = pipe(make68("list-sources", {
  options: all9({ limit: limitOption })
}), withDescription7("List source entities"), withHandler2(({ options: options3 }) => listSources(getOrUndefined(options3.limit))));
var listSeriesTop = pipe(make68("list-series", { options: all9({ limit: limitOption }) }), withDescription7("List resource series"), withHandler2(({ options: options3 }) => listSeries(getOrUndefined(options3.limit))));
function listResources(limitOpt) {
  return gen2(function* () {
    const notion = yield* Notion;
    const rows = yield* notion.listResources({ limit: limitOpt });
    for (const r of rows) {
      yield* log3(`${r.id} | ${r.name}${r.type ? ` [${r.type}]` : ""}${r.url ? ` <${r.url}>` : ""}`);
    }
  }).pipe(catchAll2((e) => error2(String(e))));
}
function listSources(limitOpt) {
  return gen2(function* () {
    const notion = yield* Notion;
    const rows = yield* notion.listSourceEntities({ limit: limitOpt });
    for (const r of rows) {
      yield* log3(`${r.id} | ${r.name}${r.type ? ` [${r.type}]` : ""}${r.url ? ` <${r.url}>` : ""}`);
    }
  }).pipe(catchAll2((e) => error2(String(e))));
}
function listSeries(limitOpt) {
  return gen2(function* () {
    const notion = yield* Notion;
    const rows = yield* notion.listResourceSeries({ limit: limitOpt });
    for (const r of rows) {
      yield* log3(`${r.id} | ${r.name}${r.url ? ` <${r.url}>` : ""}`);
    }
  }).pipe(catchAll2((e) => error2(String(e))));
}

// src/index.ts
var add7 = make68("add").pipe(withSubcommands3([resourceCommand, sourceCommand]));
var root = withSubcommands3(make68("wetware-cli"), [
  add7,
  listCommand,
  listResourcesTop,
  listSourcesTop,
  listSeriesTop
]);
var layer12 = mergeAll4(layer11, OpenAIProviderLayer, NotionClientLayer);
var run9 = run8(root, { name: "wetware-cli", version: "0.1.0" });
runMain3(provide2(run9(process.argv.slice(2)), layer12));
