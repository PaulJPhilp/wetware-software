"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reverse = exports.min = exports.max = exports.clamp = exports.between = void 0;
var order = _interopRequireWildcard(require("effect/Order"));
var monoid = _interopRequireWildcard(require("./Monoid.js"));
var semigroup = _interopRequireWildcard(require("./Semigroup.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * `Monoid` that returns last minimum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
const min = B => monoid.fromSemigroup(semigroup.min(B.compare), B.maxBound);
/**
 * `Monoid` that returns last maximum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
exports.min = min;
const max = B => monoid.fromSemigroup(semigroup.max(B.compare), B.minBound);
/**
 * Checks if a value is between the lower and upper limit of a bound.
 *
 * @category predicates
 * @since 0.24.0
 */
exports.max = max;
const between = B => order.between(B.compare)({
  minimum: B.minBound,
  maximum: B.maxBound
});
/**
 * Clamp a value between `minBound` and `maxBound` values.
 *
 * @category utils
 * @since 0.24.0
 */
exports.between = between;
const clamp = B => order.clamp(B.compare)({
  minimum: B.minBound,
  maximum: B.maxBound
});
/**
 * Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.
 *
 * @category utils
 * @since 0.24.0
 */
exports.clamp = clamp;
const reverse = B => ({
  compare: order.reverse(B.compare),
  minBound: B.maxBound,
  maxBound: B.minBound
});
exports.reverse = reverse;
//# sourceMappingURL=Bounded.js.map